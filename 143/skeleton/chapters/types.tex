% -*- coding: utf-8 -*-
\chapter{\ulambda-calcul et théorie des types}
%#############################################
\label{ch:types}
\Writetofile{solf}{\protect\newpage}
\Writetofile{solf}{\protect\section{Chapitre \protect\ref{ch:types}}}



L'enjeu de ce chapitre est de s'attaquer sérieusement et précisément à la compositionnalité.\is{compositionnalité|sq}
Les
chapitres précédents se sont consacrés essentiellement à la partie
interprétation du système formel, et plus précisément à
l'interprétation du langage {\LO} --~c'est ce qui correspond à la flèche droite du schéma de la figure~\ref{F:Archi2}.  
Nous allons continuer à développer
cette partie, mais nous allons aussi commencer à prêter une attention
soutenue à la flèche de gauche de la figure~\ref{F:Archi2}\footnote{Rappelons que par {\Ftrad} nous représentons une fonction de traduction possible (parmi d'autres) des expressions de la langue naturelle vers des expressions de {\LO} (cf.\ la conclusion du chapitre~\ref{LCP}, \S\ref{conclu:LCP}). C'est ce qui nous permet, par exemple, de noter : \(\Ftrad(\sicut{Alice dort})=\Xlo\prd{dormir}(\cns a)\).}, c'est-à-dire le lien entre la langue naturelle et
{\LO}. 

\begin{figure}[h]
\begin{center}
\begin{pspicture}(0,.8)(9,2)
\rput[l](0,1.2){\rnode{F}{\boitealu{\textbm{Français}}}}
\rput(5,1.2){\rnode{L}{\boitealu{\textbf{\LO}}}}
\rput[r](9,1.2){\rnode{M}{\boitealu{$\boldsymbol{\Modele}$}}}
\ncline[nodesep=3pt,linecolor=Red2,linewidth=1.5pt]{->}{F}{L}\Aput{\Ftrad}\Bput{\small traduction}
\ncline[nodesep=3pt,linewidth=1.5pt]{->}{L}{M}\Aput{\denote{\,}}\Bput{\small interprétation}
\end{pspicture}
\end{center}
\caption{Architecture du système sémantique formel}\label{F:Archi2}\is{F@\Ftrad}
\end{figure}

Il va s'agir de définir un ensemble de règles qui permettent d'obtenir
«automatiquement» la traduction d'une phrase dans {\LO}.  
Nous nous appuyons pour cela sur le principe de compositionnalité, et comme ce principe
dit que le sens d'une phrase dépend du sens de ses parties et de leur
mode combinaison syntaxique, le système de règles devra opérer sur des
phrases analysées syntaxiquement. %, c'est-à-dire (par exemple) des arbres.
Nous allons donc nous situer  à l'interface syntaxe-sémantique.
C'est là une tâche de grande envergure, qui va nous occuper pendant deux chapitres (celui-ci et le suivant) afin de mettre en place l'appareillage formel qui nous permettra de la mener à bien.
Le présent chapitre se consacre à une dernière amélioration de fond de {\LO} qui lui permettra de jouer proprement son rôle de pivot dans un système d'analyse sémantique compositionnelle.



\section{Tout est fonction (ou presque)}
%=======================================

\subsection{Des trous dans les formules}
%----------------------------------------
\label{ss:trous}

Nous savons traduire en {\LO} une phrase simple du français comme
\ref{x:trd1}.  Nous savons le faire car nous comprenons \ref{x:trd1},
c'est-à-dire que nous percevons ses conditions de vérité, et nous
connaissons maintenant suffisamment bien {\LO} pour symboliser ces
conditions dans une formule \ref{x:trd1b}.

\ex.\a.  \label{x:trd1}
 Alice regarde Bruno.
\b.
\(\Xlo\prd{regarder}(\cns a,\cns b)\) \label{x:trd1b}


En fait cet exemple montre que, pour l'instant, nous traduisons du
français vers {\LO} de la même manière qu'un polyglotte traduira, par
exemple, une phrase de l'italien vers l'anglais.  Nous accédons au sens
de la phrase de départ puis nous reformulons ce sens dans le langage
cible, en l'occurrence ici {\LO}. Cependant il ne faut pas perdre de
vue que les traductions que nous effectuons ici ne sont
qu'accessoires, et ce qui nous intéresse en sémantique c'est avant
tout de décrire le sens des expressions.  Pour dire les choses
autrement, la traduction vers {\LO} ne doit pas tellement être vue
comme une \emph{reformulation} d'un sens dans une autre langue, mais
plutôt comme une manière de \emph{dévoiler} (c'est-à-dire
d'expliciter) le sens.  Ainsi traduire dans {\LO} correspond à cette
étape d'accès au sens mentionnée ci-dessus ; cela consiste simplement à
faire de l'\emph{analyse} sémantique.
Une théorie de description formelle et suffisamment élaborée d'une
langue naturelle comme le français devra donc expliciter, et détailler, 
%cette opération de traduction en détaillant 
les mécanismes mis à l'\oe uvre dans
l'analyse sémantique d'une phrase.  


\sloppy

L'analyse sémantique pilote le processus de construction du sens d'une
phrase et doit donc respecter notre principe de compositionnalité
(\ref{p:compo2}, p.~\pageref{p:compo2}) qui, rappelons-le, dit que
l'interprétation ({\ie} le sens) d'une phrase dépend de l'interprétation
de ses parties et de leur mode de combinaison syntaxique.  Cela
implique d'abord que l'analyse sémantique doit tenir compte de la
syntaxe\footnote{Il s'agit là bien sûr de la syntaxe du français, pas
  de la syntaxe de {\LO} que nous avons vue dans les chapitres
  précédents} et donc opérer sur des phrases analysées syntaxiquement,
c'est-à-dire, par exemple, des arbres.\is{arbre!\elid\ syntaxique}

\fussy

Ainsi, si l'on dispose d'une règle syntaxique qui dit qu'une phrase se
réécrit en un groupe nominal suivi d'un groupe verbal, P {\reecr} GN
GV%
\footnote{Pour le moment, j'utilise encore les notations françaises GN, GV, P, pour désigner les constituants syntaxiques. Par la suite, nous serons amenés à manipuler beaucoup d'autres catégories syntaxiques. Nous passerons alors aux notations anglo-saxonnes, comme NP (\alien{noun phrase}), VP (\alien{verb phrase}), etc.\ qui sont plus universelles. }, 
alors le sens de P doit dépendre du sens de GN et de GV.  Et cela
a une implication supplémentaire importante : un GN et un GV doivent
en soi avoir un sens et donc correspondre à des expressions
reconnues et  interprétables dans {\LO}.  Et de même pour tous les
constituants syntaxiques de la phrase.

Reprenons l'exemple \ref{x:trd1} avec son analyse syntaxique, que
l'on peut, au moins en première approximation, représenter par l'arbre\is{arbre!\elid\ syntaxique}
de constituants en figure~\ref{x:arbrdec1}. Le principe de compositionnalité
nous dit que chaque constituant de la phrase est interprétable.  C'est
pourquoi nous pouvons décorer l'arbre en associant à chacun de ses
n\oe uds une expression de {\LO} (qui est, par définition,
interprétable).  Nous savons ce qui décore le n\oe ud P : c'est la
formule \ref{x:trd1b} ; et nous prévoyons assez naturellement que les
GN, \sicut{Alice} et \sicut{Bruno}, seront décorés respectivement des
constantes \cns a et \cns b, et le verbe \sicut{regarde} du prédicat
binaire \prd{regarder}.  Mais quelle expression de {\LO} pouvons-nous
associer au groupe verbal GV ?  Nous venons de voir que par
compositionnalité ce GV est interprétable : il devrait donc pouvoir se
traduire en soi dans {\LO}.
  


\begin{figure}[h]
\begin{center}
\leaf{Alice\\\cns{a}} 
\branch{1}{GN}
\leaf{regarde\\\prd{regarder}} 
\branch{1}{V} 
\leaf{Bruno\\\cns{b}}
\branch{1}{GN} 
\branch{2}{GV\zbox{\ $\leadsto$ ?}}  
\branch{2}{P\zbox{\ $\Xlo\prd{regarder}(\cns{a},\cns{b})$}} 
\qobitree 
\caption{Analyse de \sicut{Alice regarde Bruno}}\label{x:arbrdec1} 
\end{center}
\end{figure}

\newpage

Pour répondre à cette question, il faut d'abord essayer d'avoir une
idée claire sur ce à quoi correspond sémantiquement un tel GV.
Syntaxiquement, il s'agit,  d'une
certaine manière, de l'assemblage d'un verbe et d'un GN objet.  Et
sémantiquement cela correspond au prédicat verbal \prd{regarder} qui a
maintenant son second argument (\cns b)  mais pas encore le premier.  Autrement
dit c'est un prédicat auquel il \emph{manque} un argument.
Voir les choses en termes de manque ou d'absence peut être à ce sujet
très éclairant.  Un GV est une expression sémantiquement incomplète,
par opposition à une expression qui est, elle, complète, à savoir une
phrase ou, dans \LO, une formule.  Donc nous aurons intérêt à voir la
traduction d'un GV comme une formule incomplète, non saturée ou plus
exactement \emph{pas encore} saturée.
Cela est d'ailleurs généralisable aux prédicats eux-mêmes.  Par
exemple, un prédicat verbal binaire comme \prd{regarder} est une
expression qui lorsqu'on lui fournit deux arguments produit, avec ses
deux arguments, une formule. 

Mais  nous sommes ici face à  un problème technique très bloquant et
en même temps très simple : le langage {\LO}, tel qu'il est défini
formellement, ne nous permet tout bonnement pas de représenter le sens
d'un GV comme \sicut{regarde Bruno}, c'est-à-dire un prédicat binaire,
\prd{regarder}, qui possède son second argument, \cns b, mais pas
encore son premier argument.  Toute tentative que nous pourrions faire
pour implémenter cette idée, pourtant simple, dans {\LO}  est vouée à
l'échec. Essayons. 

Une première suggestion qui peut nous venir à
l'esprit serait de traduire le GV par \(\Xlo\prd{regarder}(x,\cns
b)\), en utilisant une variable, \vrb x, pour l'argument manquant. 
C'est une expression bien formée, légitime selon la syntaxe de {\LO} ;
mais le problème, c'est que c'est une formule, c'est-à-dire une
expression saturée, qui a la propriété sémantique de pouvoir être
vraie ou fausse. Or ce n'est pas ce que nous voulons pour un GV (un GV
n'est ni vrai ni faux). Certes une variable est un désignateur
anonyme, dans le sens où elle ne nous indique  pas d'elle-même sa dénotation
(c'est l'assignation $g$ fournie par le contexte qui nous l'indique),
mais  une variable est tout de même un terme à part entière de {\LO},
apte à occuper une position d'argument d'un prédicat. On peut toujours
retraduire \(\Xlo\prd{regarder}(x,\cns b)\) en français ; cela donnera
\sicut{il $($ou elle$)$ regarde Bruno} --~une phrase et non un GV. 

\sloppy

Une autre suggestion serait de traduire le GV par
\(\Xlo\prd{regarder}(\cns b)\).   Mais nous n'avons pas le droit, la
syntaxe de {\LO} nous l'interdit.  Car nous savons que le prédicat
\prd{regarder} est d'arité 2, et la seule règle qui nous permet
d'utiliser un tel prédicat  dans {\LO} est (\RSyn\ref{SynPApp}b)
(p.~\pageref{SynP}), qui nous oblige à accompagner le prédicat
d'exactement deux arguments. La définition de la syntaxe du langage
étant ce qu'elle est,  \(\Xlo\prd{regarder}(\cns b)\) n'est pas une
expression bien formée de {\LO}.

\fussy

En fait, ce dont nous aurions besoin pour traduire le GV, c'est
quelque chose comme \(\Xlo\prd{regarder}(\slot,\cns b)\), avec un
symbole spécial (\xlo{\slot}) pour représenter une place vide.  Bien
évidemment ce symbole n'existe pas dans {\LO}, et donc là encore nous
n'avons pas le droit d'écrire cette expression. Le problème n'est pas 
tant que le symbole est absent du langage, c'est surtout qu'il serait
difficile de lui attribuer rigoureusement une interprétation propre,
signifiant qu'il désigne une place vide.



%En fait chacune de ces hypothèses est, à sa manière, sur la bonne piste.



L'enjeu pour nous ici est donc d'augmenter l'expressivité de {\LO} en
se donnant les moyens de représenter rigoureusement dans le langage
des choses qui manquent, des places vides ou des «trous» dans les
formules%
\footnote{Et nous verrons d'ailleurs qu'à cet effet, les trois
  suggestions examinées ci-dessus ne sont pas complètement
  aberrantes. Nous pourrons nous apercevoir que l'amendement apporté à
  {\LO} reprend en quelque sorte le meilleur de chacune de ces
  suggestions : nous représenterons des trous comme {\xlo{\slot}},
  mais de façon plus efficace ; nous utiliserons des variables ; et
  nous nous autoriserons à donner aux prédicats moins d'arguments que
  prévu par leur arité.}.  
Par la suite, il nous faudra également expliciter
précisément le processus qui, dans la syntaxe de {\LO}, consiste à
combler ces vides, c'est-à-dire à fournir des arguments aux prédicats.
Et --~c'est extrêmement important~-- il va aussi nous falloir définir
explicitement la règle sémantique qui nous permettra d'interpréter les
formules «à trous».  C'est ce point que nous allons commencer par
aborder dans ce qui suit.


%% \ex.  {
%% \leaf{Alice\\\cns{a}}
%% \branch{1}{NP}
%% \leaf{dort\\\prd{dormir}}
%% \branch{1}{V}
%% \branch{1}{VP\zbox{ $\prd{dormir}$}}
%% \branch{2}{S\zbox{ $\prd{dormir}(\cns a)$}}
%% \qobitree
%% }


\subsection{Sémantique fonctionnelle des prédicats}
%--------------------------------------------------
\label{ss:SFP}\is{predicat@prédicat|sq}


Dans cette section, nous allons réviser la définition de
l'interprétation (\ie\ la dénotation) des prédicats, en la remplaçant
par une variante formellement plus efficace et qui, ensuite, nous permettra d'implémenter très facilement la notion de «trous» dans le système sémantique. 
Cela ne veut pas
dire que la définition que nous connaissons jusqu'ici va devenir
complètement caduque (nous la réutiliserons de temps en temps), mais
elle sera maintenant secondaire dans le système {\LO}.  Autrement dit,
il n'y aura pas de rupture
de cohérence avec ce que nous avons vu auparavant.

\subsubsection{Prédicats unaires}
%''''''''''''''''''''''''''''''''
\label{sss:SFP1}


Commençons avec le cas le plus simple, celui des prédicats unaires.
Selon la définition~\ref{RIcl} (p.~\pageref{RIcl}), nous le savons
bien, un prédicat unaire dénote un ensemble d'individus de \Unv{A}
(\ie\ un sous-ensemble de \Unv{A}).  Par exemple pour le prédicat
\prd{dormir}, cela nous donne :

\ex.
\(\denote{\prd{dormir}}^{\Modele,w,g}=\FI(w,\prd{dormir})=\)
l'ensemble de tous les individus de \Unv A qui dorment dans le
  monde $w$.


Les conditions de vérités définies par la règle (\RSem\ref{RIprd}a) (de
la définition~\ref{RI1}, p.~\pageref{RI1}, reprise en
définition~\ref{RI2}, p.~\pageref{RI2}) exploitent ce type de
dénotation en faisant appel à la relation ensembliste d'appartenance,
$\in$, pour vérifier que l'argument donné au prédicat le satisfait
bien. 


Mais il y a une autre manière de concevoir cette dénotation.  Il
s'agit d'une variante mathématique très simple et systématique, qui
consiste à voir la dénotation du prédicat comme une \kw{fonction},
allant de l'ensemble \Unv A vers l'ensemble des valeurs de vérité
\set{0;1}. Plus précisément, c'est la fonction qui, à tout élément de
\Unv A, attribue la valeur $1$ ssi cet élément satisfait le prédicat
dans le modèle (et dans le monde où l'on choisit d'interpréter le
prédicat).  Ainsi pour \prd{dormir}, sa dénotation fonctionnelle
générale est définie comme suit :

\ex.
\(\denote{\prd{dormir}}^{\Modele,w,g}=\FI(w,\prd{dormir})=
\begin{array}[t]{@{}l@{\:}l@{\:}l}
\Unv{A}&\longrightarrow &\set{0;1}\\
\Obj{x}&\longmapsto & \left\{\begin{array}{@{\,}l}1 \text{ si \Obj{x} dort dans
    $w$}\\0 \text{ sinon}\end{array}\right.
\end{array}\)

\sloppy

Illustrons immédiatement cela avec un exemple. Prenons un modèle-jouet
\(\Modele=\tuple{\Unv A, \Unv W, \FI}\), avec \(\Unv A =
\set{\Obj{Alice}; \Obj{Bruno}; \Obj{Charles}; \Obj{Dina}}\), et
plaçons-nous dans un monde $\w_1$ de \Unv W.  Une valeur possible pour
la dénotation du prédicat \prd{dormir} (et donc aussi du verbe intransitif
\sicut{dort}) dans $\w_1$ est donnée par la fonction explicitée en
\ref{x:xdormirf} :

\fussy

\ex. \label{x:xdormirf}
\(\denote{\Ftradf{\sicut{dort}}}^{\Modele,\w_1,g} =
\denote{\prd{dormir}}^{\Modele,\w_1,g} = 
\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt,offsetB=2pt]{->}{a}{1}
\ncline[nodesep=3pt]{->}{b}{1}
\ncline[nodesep=3pt]{->}{c}{0}
\ncline[nodesep=3pt,offsetB=-1pt]{->}{d}{1}
\)

Cette fonction nous indique que \Obj{Alice}, \Obj{Bruno} et \Obj{Dina}
dorment dans $\w_1$, et que 
\Obj{Charles} ne dort pas.  C'est très simple, il suffit de suivre les
flèches. 

\largerpage[-1]

Nous avons déjà manipulé beaucoup de fonctions\is{fonction} dans
les chapitres qui précédaient (fonction d'interprétation, fonction
d'assignation, intensions...), mais ça vaut la peine de revenir ici quelques
instants sur cette notion.  Une fonction est un système de mise en
correspondance entre les éléments de deux ensembles donnés, un
ensemble de départ et un ensemble d'arrivée. Elle doit respecter la
contrainte qu'à tout élément de l'ensemble de départ soit associé un
et un seul élément de l'ensemble d'arrivée.  Cela fait qu'il peut être
également pratique d'adopter une vision plus procédurale des
fonctions. Métaphoriquement, on peut voir une fonction comme petite
machine qui donne un résultat quand on lui a fourni un «ingrédient». L'ingrédient est ce que l'on nomme l'\kw{argument} de
la fonction (et bien sûr, ce n'est pas pour rien qu'on utilise le même
terme quand on parle des arguments de prédicats dans \LO), c'est un
élément de l'ensemble de départ ; et le résultat, que l'on appelle
aussi la \kwo{valeur}\is{valeur!\elid\ d'une fonction}, est l'élément de
l'ensemble d'arrivée que la 
fonction associe à l'argument donné.
Ainsi la fonction \ref{x:xdormirf} est cette machine qui retourne le
résultat $1$ (\sicut{vrai}) 
si et seulement si  l'argument qu'on lui a donné est un individu qui dort dans
$\w_1$. Autrement dit, elle répond à la question «est-ce que \Obj x
dort dans $\w_1$ ?» pour n'importe quel \Obj x de \Unv A --~ou plus globalement, à la question «qui dort dans $\w_1$ ?». 



\sloppy
Maintenant, puisque \(\denote{\prd{dormir}}^{\Modele,\w_1,g}\) est une
fonction, on peut lui donner un argument, par exemple \Obj{Alice}, ce
qui se fait en écrivant 
\(\denote{\prd{dormir}}^{\Modele,\w_1,g}(\Obj{Alice})\). 
Et le modèle
{\Modele}, tel qu'il est décrit (en partie) dans \ref{x:xdormirf},
nous dit que \(\denote{\prd{dormir}}^{\Modele,\w_1,g}(\Obj{Alice})=1\)
--~il suffit de suivre la flèche qui part d'\Obj{Alice}.
\label{SFP1@}
On devine facilement que c'est là la dénotation de la formule
\(\Xlo\prd{dormir}(\cns a)\).
De cette façon,  le prédicat  prévoit la dénotation finale de la formule
où il intervient. Cette dénotation dépend de l'argument qui sera
donné, mais c'est le prédicat, en tant que fonction, qui fournira la valeur
$1$ ou $0$.

\fussy

Comme je l'ai suggéré \alien{supra}, passer d'une dénotation
ensembliste à une dénotation fonctionnelle des prédicats n'est 
finalement
qu'une \emph{variante} formelle. % (c'est-à-dire mathématique). 
C'est exactement  ce que nous avons vu au chapitre précédent au sujet des propositions (\ie\ l'intension des formules).
Prenons le temps ici de rappeler le principe sous-jacent de cette variante.
Il y a un fait mathématique bien établi qui dit qu'il existe  
une équivalence  systématique entre la définition d'une fonction qui va d'un
ensemble donné $E$ vers un ensemble comme \set{0;1} et la définition
d'un sous-ensemble de $E$. 
En effet, si l'on dispose d'une fonction qui projette chaque élément
de $E$ sur $1$ ou $0$, on peut en déduire la donnée d'un sous-ensemble
particulier de $E$ : celui qui contient juste les éléments de $E$
auxquels la fonction assigne la valeur $1$.  Inversement, si l'on
connaît précisément le contenu d'un sous-ensemble donné de $E$, on
peut toujours définir une fonction particulière de $E$ vers 
\set{0;1} : la fonction qui retourne 
la valeur $1$ si et seulement si son argument appartient au
sous-ensemble en question. 
Une telle fonction, qui prend ses valeurs dans une paire comme
\set{0;1},  s'appelle la 
\kwo{fonction caractéristique}\is{fonction!\elid\ caractéristique} d'un ensemble ; elle caractérise
complètement un ensemble en disant, via la valeur $1$, quels sont les
éléments qui constituent l'ensemble.


\begin{defi}[Fonction caractéristique d'un ensemble]
Soit $E$ un ensemble non vide et $S$ un sous-ensemble  de $E$.
\\
La \kwo{fonction caractéristique}\is{fonction!\elid\ caractéristique} de  $S$ %(dans $E$) 
est la fonction de $E$ vers
\set{0;1} qui à tout élément de $E$ attribue la valeur $1$ si cet
élément appartient à $S$, et $0$ sinon.
\end{defi}


À tout ensemble d'objets, quels qu'ils soient, correspond une et une
seule fonction caractéristique ; et toute fonction qui prend ses
valeurs dans une paire comme \set{0;1}%
\footnote{Je dis «une paire comme \set{0;1}~» car en fait
  n'importe quel ensemble de \emph{deux} éléments peut faire l'affaire --~par
exemple \set{+;-} ou \set{\text{oui};\text{non}} ou \set{\bullet;\circ} ou
\set{\smiley;\frownie} etc. Il suffit seulement de poser par convention qu'un
des deux éléments s'interprète comme un confirmateur de l'appartenance
à l'ensemble (pour nous, c'est $1$), et l'autre comme un infirmateur ($0$).}
 détermine de façon univoque le
contenu d'un sous-ensemble précis de son ensemble de départ. 
Il ne s'agit pas exactement d'un équivalence formelle : un ensemble et
une fonction ne sont pas des objets mathématiques de même nature ;
mais on peut voir cela comme une équivalence de fond, dans la mesure
où la définition de l'un entraîne la définition de l'autre, et
réciproquement. 
Ainsi la fonction présentée en \ref{x:xdormirf} est la fonction
caractéristique de l'ensemble \set{\Obj{Alice}; \Obj{Bruno};
  \Obj{Dina}}. 
Par conséquent \ref{x:xdormirf} nous donne \emph{exactement} les mêmes
informations que \ref{x:xdormire}.

\ex. \label{x:xdormire}
\(\denote{\Ftradf{\sicut{dort}}}^{\Modele,\w_1,g} =
\denote{\prd{dormir}}^{\Modele,\w_1,g} = \set{\Obj{Alice}; \Obj{Bruno}; \Obj{Dina}}
\)


De ce fait, même en étant passé à des dénotations fonctionnelles, nous
ne pouvons guère oublier les ensembles (et ce n'est pas plus mal, car
cela prouve au moins que les formalisations que nous avions vues dans
les chapitres précédents ne sont pas fondamentalement remises en
question).  Mais nous allons voir que l'approche fonctionnelle est
beaucoup plus puissante et expressive pour notre système sémantique.

Il faut cependant préciser que, comme à présent nous formalisons la dénotation des prédicats unaires en tant que fonctions, alors ce qui est écrit en \ref{x:xdormire} n'est pas parfaitement rigoureux : la dénotation de \prd{dormir} ne peut pas être à la fois une fonction et un ensemble.  Nous devrons donc reprendre ici la convention que nous avions posée en \S\ref{ss:s&ig} et qui introduisait la notation \(\Ch{\denote{\cdot}}\). Ainsi \ref{x:xdormire} devra se reformuler en : 
\(\Ch{\denote{\prd{dormir}}}^{\Modele,\w_1,g} = \set{\Obj{Alice}; \Obj{Bruno}; \Obj{Dina}}
\).
Cette notation fait simplement passer d'une fonction caractéristique à l'ensemble caractérisé par cette fonction.



Et puisque nous allons manipuler une quantité de fonctions,
j'introduis ici un élément de notation qui va nous être très
utile. Quand on s'intéresse à des fonctions qui vont, par exemple,
d'un ensemble $A$ vers un ensemble $B$, il peut être pratique de
savoir regrouper \emph{toutes} les fonctions
\emph{possibles}  qui s'établissent entre $A$ et $B$.  
Les regrouper signifie les ranger dans un ensemble ; car bien sûr il
n'y a pas de raison de ne pas concevoir des ensembles de fonctions (et
nous ne nous en priverons pas).
En fait ce regroupement ne
demande aucun savoir-faire technique particulier, c'est juste une
question de notation%
\footnote{Cette notation rappelle celle des puissances en algèbre, et ce n'est
pas innocent. En effet, si $A$ contient $n$ éléments et $B$
  contient $m$ éléments, alors le nombre total de fonctions que
  contient $B^A$ est $m^n$. Il faut simplement bien se souvenir que
l'ensemble de départ est celui noté en exposant, et l'ensemble
d'arrivée celui noté en base.}.


\begin{nota}
Soit $A$ et $B$ deux ensembles non vides. L'ensemble de \emph{toutes}
les fonctions de $A$ vers $B$ se note $B^A$.
\end{nota}


Donc l'extension de \prd{dormir} dans $w$ est un élément de
$\set{0;1}^{\Unv{A}}$.  Et de manière générale, $\set{0;1}^{\Unv{A}}$
contient toutes les extensions possibles de tous les prédicats unaires
envisageables dans le modèle. 
%Et l'extension de \prd{regarder} est un
%élément de $(\set{0;1}^{\Unv{A}})^{\Unv{A}}$.



\subsubsection{Prédicats binaires et \emph{n}-aires}
%''''''''''''''''''''''''''''''''''''''''''''
\label{ss:fxnaires}

Nous avons rendu fonctionnelle la dénotation des prédicats unaires,
bien entendu, nous devons faire la même chose pour les prédicats
d'arité supérieure.  Les prédicats binaires expriment des relations (à
deux membres), et précédemment nous formalisions leurs extensions au
moyen d'ensembles de couples d'individus. 
En poursuivant notre entreprise de remplacement les ensembles par des
fonctions caractéristiques, nous pourrions proposer que la  dénotation
d'un prédicat binaire est donc une fonction qui associe une valeur de
vérité à chaque couple d'individus du domaine \Unv A.  L'ensemble de
tous les couples d'individus pris dans \Unv A se note $\Unv A \times
\Unv A$\is{produit cartésien} (ou $\Unv A^2$). Ainsi pour le
prédicat \prd{regarder}, nous aurions :

\ex.  \label{xregardf2}
\(\denote{\prd{regarder}}^{\Modele,w,g}=\FI(w,\prd{regarder})=
\begin{array}[t]{@{}c@{\:}c@{\:}l}
\Unv{A}\times \Unv{A}&\longrightarrow &\set{0;1}\\
\tuple{\Obj{x},\Obj{y}}&\longmapsto & \left\{\begin{array}{@{\,}l}1 \text{ si \Obj{x} regarde \Obj{y} dans
    $w$}\\0 \text{ sinon}\end{array}\right.
\end{array}\)


En soi cette formalisation n'est pas incorrecte, mais ce n'est pas
celle que nous allons retenir, car elle n'est pas suffisamment
compositionnelle.  Pour que la fonction \ref{xregardf2} puisse nous
donner un résultat, il faut qu'on lui fournisse directement un couple
d'individus ; autrement dit, on est obligé de fournir les deux arguments
du prédicat d'un coup.  Or nous avons vu précédemment
(\S\ref{ss:trous}) que nous aimerions pouvoir donner au prédicat ses
arguments un par un, et surtout pouvoir obtenir une interprétation
(\ie\ une dénotation) à chaque étape.   Il se trouve qu'un usage
adéquat des fonctions nous permet de faire cela.
%Or on peut s'arranger pour obtenir une interprétation en donnant les arguments un par un. 

Prenons un prédicat à deux places, par exemple \prd{regarder} ou le
verbe \sicut{regarde}.
Si nous fixons (\ie\ nous saturons) un de ses arguments, nous obtenons
sémantiquement l'équivalent d'un prédicat à une place.  Par exemple la
dénotation du GV \sicut{regarde Bruno}
(cf.\ \(\Xlo\prd{regarder}(\slot,\cns b)\)) est, à l'instar de celle d'un
verbe intransitif comme \sicut{dort}, une fonction de
\(\set{0;1}^{\Unv A}\).  C'est la fonction qui renvoie $1$ si et
seulement si son argument, \ie\ la dénotation du GN sujet, regarde
effectivement \Obj{Bruno} dans le monde d'évaluation. 
Voici en \ref{xregardfB} un exemple avec notre modèle-jouet pour le
monde $\w_1$ : 

\newcommand{\fxregardeB}%
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}%
\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt]{->}{a}{1}
\ncline[nodesep=3pt,offsetB=2pt]{->}{b}{0}
\ncline[nodesep=3pt]{->}{c}{0}
\ncline[nodesep=3pt,offsetB=-2pt]{->}{d}{0}%
}

\ex.  \label{xregardfB}
\(\denote{\Ftradf{\sicut{regarde Bruno}}}^{\Modele,\w_1,g} =
\fxregardeB
\) 


\ref{xregardfB} présente la  fonction qui nous dit qui regarde
\Obj{Bruno} dans $\w_1$ ; en l'occurrence seule \Obj{Alice} regarde \Obj{Bruno}. 

Bien évidemment, nous avons quelque chose d'analogue pour le GV
\sicut{regarde Alice} (cf.\ $\Xlo\prd{regarder}(\slot,\cns{a})$). Sa
dénotation dans $\w_1$ est la fonction qui répond à la question «qui regarde \Obj{Alice} dans $\w_1$ ?» (ici \Obj{Charles} et \Obj{Dina}) :

\newcommand{\fxregardeA}
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt,offsetB=1pt]{->}{a}{0}
\ncline[nodesep=3pt,offsetB=-1pt]{->}{b}{0}
\ncline[nodesep=3pt,offsetB=1pt]{->}{c}{1}
\ncline[nodesep=3pt,offsetB=-1pt]{->}{d}{1}%
}

\ex. \label{xregardfA}
\(\denote{\Ftradf{\sicut{regarde Alice}}}^{\Modele,\w_1,g} =
\fxregardeA
\)


Idem en \ref{xregardfC} pour le GV \sicut{regarde Charles} (personne
ne regarde \Obj{Charles}), et en \ref{xregardfD} pour \sicut{regarde
  Dina} (seul \Obj{Bruno} la regarde) :
%% $\Xlo\prd{regarder}(\slot,\cns{c})$ (<<~qui regarde
%% \Obj{Charles} ?~>>), pour $\Xlo\prd{regarder}(\slot,\cns{d})$ (<<~qui regarde
%% \Obj{Dina} ?~>>) etc.

\newcommand{\fxregardeC}
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt,offsetB=4pt]{->}{a}{0}
\ncline[nodesep=3pt,offsetB=2pt]{->}{b}{0}
\ncline[nodesep=3pt]{->}{c}{0}
\ncline[nodesep=3pt,offsetB=-2pt]{->}{d}{0}%
}

\ex.  \label{xregardfC}
\(\denote{\Ftradf{\sicut{regarde Charles}}}^{\Modele,\w_1,g} =
\fxregardeC
\)

\newcommand{\fxregardeD}
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt,offsetB=2pt]{->}{a}{0}
\ncline[nodesep=3pt]{->}{b}{1}
\ncline[nodesep=3pt]{->}{c}{0}
\ncline[nodesep=3pt,offsetB=-2pt]{->}{d}{0}%
}

\ex.  \label{xregardfD}
\(\denote{\Ftradf{\sicut{regarde Dina}}}^{\Modele,\w_1,g} =
\fxregardeD
\)


Nous constatons donc que quand on fait varier le second argument du
prédicat (\ie\ le complément d'objet du GV), on obtient à chaque fois
une nouvelle fonction, différente ; mais c'est toujours une fonction de
\(\set{0;1}^{\Unv A}\).  Nous commençons ainsi à avoir une vision
générale de la dénotation propre du prédicat \prd{regarder} : en
quelque sorte c'est une  \emph{série} de fonctions. Et ce qui est
important c'est que chaque fonction de la série est indexée par un
élément de \Unv A. Autrement dit, ce que fait la dénotation du  prédicat
\prd{regarder} en soi, c'est, pour chaque objet \Obj{y} de \Unv A, de
nous répondre à la question «qui regarde \Obj y ?». Et cela peut
se résumer au moyen d'une grande fonction, puisque la question à
laquelle répond \prd{regarder} dépend de \Obj y ; c'est tout
simplement la fonction \(\Obj y \longmapsto \text{«qui regarde \Obj
y ?»}\) :


\ex.
\(\denote{\prd{regarder}}^{\Modele,w,g} = 
\left[
\begin{array}{@{\;}l@{\qquad\qquad}l@{\,}}
\Obj{Alice}\rnode{a1}{\stx}&\rnode{q1}{\stx}\text{«qui regarde \Obj{Alice} dans $w$ ?~»}\\
\Obj{Bruno}\rnode{b1}{\stx}& \rnode{q2}{\stx}\text{«qui regarde \Obj{Bruno} dans $w$ ?~»}\\
\Obj{Charles}\rnode{c1}{\stx}&\rnode{q3}{\stx} \text{«qui regarde
  \Obj{Charles} dans $w$ ?~»}\\
\Obj{Dina}\rnode{d1}{\stx}& \rnode{q4}{\stx} \text{«qui regarde \Obj{Dina} dans $w$ ?~»}\\
%\dots\\
\end{array}%\rule{2.5cm}{0pt}
\right]
\ncline[nodesep=3pt]{->}{a1}{q1}
\ncline[nodesep=3pt]{->}{b1}{q2}
\ncline[nodesep=3pt]{->}{c1}{q3}
\ncline[nodesep=3pt]{->}{d1}{q4}
\)

Maintenant, pour expliciter complètement cette fonction en reprenant
les exemples \ref{xregardfB}--\ref{xregardfD} dans $\w_1$, cela nous
donne ce qui est représenté dans la figure \ref{f:regardf}.

%C'est-à-dire :

\begin{figure}[h]
\begin{bigcenter}
\scalebox{.95}%
{
\(\denote{\prd{regarder}}^{\Modele,\w_1,g} = 
\left[
\begin{array}{l}
\\[2ex]
\Obj{Alice}\rnode{a1}{\stx}\\[2ex]
\Obj{Bruno}\rnode{b1}{\stx}\\[2ex]
\Obj{Charles}\rnode{c1}{\stx}\\[2ex]
\Obj{Dina}\rnode{d1}{\stx}\\[2ex]
%\dots\\
\end{array}\rule{2.5cm}{0pt}
%
\begin{array}{l@{\;}}
\rnode{q1}{\stx}%
\fxregardeA
\\
\rnode{q2}{\stx}%
\fxregardeB
\\
\rnode{q3}{\stx}%
\fxregardeC
\\
\rnode{q4}{\stx}%
\fxregardeD %\left[\begin{array}{l}\dots\end{array}\right]
\end{array}
\right]%
\ncline[nodesep=3pt]{->}{a1}{q1}%
\ncline[nodesep=3pt]{->}{b1}{q2}%
\ncline[nodesep=3pt]{->}{c1}{q3}%
\ncline[nodesep=3pt]{->}{d1}{q4}\)
}
\end{bigcenter}
\caption{Un exemple de la dénotation fonctionnelle de \prd{regarder}}\label{f:regardf}
\end{figure}


Par conséquent, la dénotation du prédicat binaire \prd{regarder} est
une fonction qui prend un argument (en l'occurrence la dénotation du
complément d'objet) et qui en résultat nous donne une autre
fonction. Cette seconde fonction à son tour prend elle aussi un
argument (la dénotation du sujet), et nous retourne alors une valeur
de vérité.  Ce qui se synthétise en \ref{xregarderf} :

%\paragraph{Conclusion:} sémantiquement, un prédicat à deux arguments est
%d'abord une fonction à un argument qui retourne une fonction à un argument.

\ex.  \label{xregarderf}
\(\begin{array}[t]{l@{\ }l@{\ }l}
\denote{\prd{regarder}}^{\Modele,w,g} &=&\FI(w,\prd{regarder})\\
&=& \Unv A \longrightarrow \set{0;1}^{\Unv A}\\
&& \Obj y \longmapsto \left(\Obj x \longmapsto
\left\{\begin{array}{@{\,}l}1 \text{ si \Obj{x} regarde \Obj{y} dans
  $w$}\\0 \text{ sinon}\end{array}\right.\right) 
%% \begin{array}[t]{@{}l@{\:}l@{\:}l}
%% \Unv{A}&\longrightarrow & \left(\begin{array}{@{}l@{\:}l@{\:}l@{}}\Unv{A} & \longrightarrow
%%   & \set{0;1}\end{array}\right)\\
%% \Obj{y} & \longmapsto & 
%% \left(\begin{array}{@{}l@{\:}l@{\:}l@{}}
%% \Obj{x}&\longmapsto & \left\{\begin{array}{@{\,}l}1 \text{ si \Obj{x}
%%   regarde \Obj{y}  dans
%%     $w$}\\0 \text{ sinon}\end{array}\right.\end{array}\right)
%% \end{array}
  \end{array}
\)


On voit que c'est une fonction qui va de \Unv A vers \(\set{0;1}^{\Unv
A}\) ; autrement dit,
les prédicats binaires prennent donc leur dénotation dans l'ensemble%
\footnote{Attention, \((\set{0;1}^{\Unv{A}})^{\Unv{A}}\) n'est pas la
  même chose que \(\set{0;1}^{{\Unv{A}}^{\Unv{A}}}\). Car selon les
  conventions de notation mathématiques
  \(\set{0;1}^{{\Unv{A}}^{\Unv{A}}}\) équivaut à
  \(\set{0;1}^{({\Unv{A}}^{\Unv{A}})}\), qui est lui aussi un ensemble
de fonctions, mais complètement différentes.}
\mbox{\((\set{0;1}^{\Unv{A}})^{\Unv{A}}\)}. 
Et par cette formalisation, il devient donc possible de donner au
prédicat (\ie\ à sa dénotation) ses arguments un par un : le prédicat
en soi dénote une fonction de
\mbox{\((\set{0;1}^{\Unv{A}})^{\Unv{A}}\)}, et lorsqu'il est flanqué
d'un seul argument, la dénotation de l'ensemble est encore définie,
puisque c'est une fonction de \(\set{0;1}^{\Unv A}\).


On remarquera que l'ordre dans lequel la fonction \ref{xregarderf}
\is{argument!ordre des \elid s}
prend ses arguments (d'abord \Obj y puis \Obj x) est l'inverse 
de celui dans lequel on accole les arguments derrière le prédicat
\prd{regarder} dans {\LO} : on écrit \(\Xlo\prd{regarder}(x,y)\), où
\vrb x correspond au sujet et \vrb y au complément d'objet. Cette
inversion est purement conventionnelle, et même en quelque sorte
arbitraire. Nous aurions très bien pu définir la dénotation de
\prd{regarder} comme une fonction qui prend en  argument la
dénotation du sujet et qui renvoie une fonction qui, elle, prend en
argument la dénotation du complément d'objet.  Si on choisit
habituellement\footnote{C'est une convention que l'on retrouve par
  exemple chez \textcite{PTQ}.}
 d'inverser l'ordre des arguments, c'est pour des
raisons qui s'expliquent dans ce que nous avons observé en
\S\ref{ss:trous} sur la manière dont un prédicat binaire (un verbe
transitif) se combine avec ses arguments dans la structure syntaxique
du français.
Dans l'ordre de la composition syntaxique, le verbe rencontre d'abord
son complément d'objet (et forme avec lui un constituant, GV), puis
son sujet.  Donc si l'on se donne les moyens de fournir au prédicat
ses arguments un par un, il est préférable que le premier soit celui
qui est le plus proche dans la structure syntaxique.

Une fois familiarisé avec cette convention, il est assez
facile de voir comment la fonction de la figure~\ref{f:regardf} nous donne la
dénotation dans $\w_1$ de toute formule simple de la forme
\(\Xlo\prd{regarder}(\alpha,\beta)\) (où \vrb{\alpha} et \vrb{\beta} sont
deux de nos quatre constantes). La méthode consiste à interpréter, par
exemple, \(\Xlo\prd{regarder}(\cns c,\cns a)\) comme une feuille de
route qui nous indique quel trajet suivre dans le réseau de flèches de
la figure~\ref{f:regardf}.  On se positionne d'abord sur la dénotation de
\prd{regarder}, \ie\ à l'entrée du réseau sur la gauche. Puis on se
place sur la dénotation de \cns a, \Obj{Alice} ; on suit la flèche qui
part d'\Obj{Alice},
et on arrive sur une fonction (un sous-réseau de flèches). Là, on se
place sur la dénotation de \cns c, \Obj{Charles}, et on suit la
flèche, pour arriver finalement au résultat $1$.  
Effectivement, selon notre modèle, dans $\w_1$, il est vrai que Charles
regarde Alice.

\medskip

\input{exo/fxregarder}

\medskip

Pour les prédicats d'arité supérieure, le principe reste le
même. Les prédicats ternaires (comme \prd{donner}, \prd{envoyer})
dénotent des fonctions de
\mbox{\(((\set{0;1}^{\Unv{A}})^{\Unv{A}})^{\Unv A}\)}, c'est-à-dire
des fonctions qui prennent un individu de \Unv A en argument et qui
retournent une fonction qui prend un individu en argument et retourne
une fonction qui prend un individu en argument et (enfin !) retourne une
valeur de vérité.   
De même, \alien{mutatis mutandis}, pour les prédicats à 4 places, etc.  

Cette façon de définir toute fonction à $n$ arguments comme un
enchaînement de $n$ fonctions à un argument est très courante en
mathématique.  Elle porte le nom de 
\emph{curryfication}\is{curryfication} (ou
\emph{schönfinkelisation}\is{schonfinkelisation@schönfinkelisation}%
\footnote{\emph{Curryfication} (en anglais \alien{currying}) est forgé
sur le nom du mathématicien et logicien H.\ Curry;\index{Curry, Haskell} le terme
\emph{schönfinkelisation}, inventé par \citet{HeimKratzer:97},\Andex{Heim, I.}\Andex{Kratzer, A.} rend justice au mathématicien et logicien, moins connu,
M.\ Schönfinkel,\index{Schönfinkel, Moses} dont les travaux avaient précédé ceux de Curry dans
le même domaine de la logique combinatoire.}). En voici la définition
mathématique précise :
%% en fait ici c'est de la ``curryfication inversée que je fais''.

\begin{defi}[Curryfication] \label{d:currying}
Soit $A_1, A_2,\dotsc, A_n$ et $B$, $n+1$ ensembles non vides, et $f$
une fonction à $n$ arguments allant de $A_1 \times A_2\times \cdots \times A_n$
vers $B$ (donc \(f\in B^{A_1 \times A_2\times \cdots \times A_n}\)).\\
La version curryfiée de $f$ est la fonction $f^c$ de
\(((\dotsc(B^{A_n})^{\dotsc})^{A_2})^{A_1}\) telle que si $f :
\tuple{x_1,x_2,\dotsc,x_n} \longmapsto y$, alors 
$f^c : x_1 \longmapsto (x_2 \longmapsto (\dotsc \longmapsto (x_n
\longmapsto y)\dotsc))$.
\\Autrement dit \(f^c(x_1)(x_2)\dotsc(x_n) =
f(x_1,x_2,\dotsc,x_n)\). 
\end{defi}


Les lecteurs attentifs auront remarqué que dans  la
définition~\ref{d:currying}, l'ordre des arguments n'est pas inversé
entre $f$ et sa curryfiée $f^c$.
C'est normal, car il s'agit là de  la définition formelle générale. 
Notre convention d'inversion des arguments n'opère que dans {\LO},
pour écrire de séquences prédicat-arguments. Et dans le modèle --~là où
sont les fonctions~-- nous ne manipulerons que des versions
curryfiées. 



\section{Principes de base du \ulambda-calcul}
%=============================================
\label{s:lambda}
\is{la (lambda)@$\lambda$ (lambda)|(}


Nous venons de voir que, dorénavant, tous les prédicats dénotent des
fonctions. Nous pouvons maintenant revenir à la syntaxe de
{\LO}. Souvenons-nous que l'enjeu est de pouvoir représenter dans
{\LO} des expressions non saturées.  Le section précédente nous laisse
deviner que ces expressions seront, sémantiquement, des fonctions qui
ne possèdent pas tous leurs arguments.  Mais ici, ce qui va nous
occuper, c'est comment exprimer précisément cette idée d'incomplétude
dans les écritures de {\LO} ; autrement dit, finalement, comment
représenter des éléments manquants, des trous dans les expressions du
\mbox{langage}.   

À cet effet, nous allons adopter la stratégie décisive de R.~Montague,
\Andex{Montague, R.}%
qui fut l'un des premiers 
%(si ce n'est \emph{le} premier) 
à avoir
l'idée d'appliquer le \kwo{$\lambda$-calcul} à la sémantique du
langage naturel. Le {$\lambda$-calcul} est un système logique créé
dans les années 1930
par A. Church\ia{Church, Alonzo}, 
conçu pour formaliser très précisément la notion de fonction
et toutes ses manipulations. Il a eu un impact fondamental en
mathématiques, en logique ainsi qu'en programmation informatique,
mais à la suite de Montague (et à la lumière de ce que nous avons vu
dans la section précédente), il s'avère également un outil
extrêmement efficace pour la sémantique formelle, en particulier pour
élaborer un système d'analyse 
pleinement compositionnel. 

Dans les sous-sections qui suivent, je présenterai les bases du
$\lambda$-calcul, d'une manière assez simplifiée%
\footnote{Et je ne doute pas que des logiciens pourraient trouver ma
  présentation scandaleusement simpliste et hétérodoxe, mais je
  choisis délibérément de privilégier une approche pédagogique qui s'inscrit dans la
  continuité du système formel décrit jusqu'ici.}, 
en insistant sur les aspects qui relient le formalisme à nos présentes
préoccupations (à savoir une façon d'amender l'expressivité de {\LO}
pour le rendre opérationnel à tous les niveaux de la représentation
syntaxique). 
Dans la section~\ref{LOT}, nous redéfinirons fondamentalement et formellement la syntaxe et la sémantique de {\LO} afin d'y intégrer proprement les apports du \lcalcul.




\subsection{La \ulambda-abstraction}
%-----------------------------------
\is{la (lambda)@$\lambda$ (lambda)!$\lambda$-abstraction}

\subsubsection{Syntaxe de la \ulambda-abstraction}
%'''''''''''''''''''''''''''''''''''''''''''''''''


Notre objectif est de pouvoir écrire dans {\LO} des expressions non
saturées, incomplètes. 
Le principe général est le suivant : les «trous» d'une expression
non saturée seront représentés 
par des \emph{variables}, et au début de l'expression nous
\emph{annoncerons} que ces variables correspondent à des trous.  
Cette annonce se fait au moyen de l'opérateur $\Xlo\lambda$ (la lettre
grecque qui se prononce \alien{lambda}) qui accompagne  chacune de
ces variables. % et se place devant l'expression 
Du point de vue notationnel, $\Xlo\lambda$ se comporte donc 
dans {\LO} comme
$\Xlo\forall$, $\Xlo\exists$ et $\Xlo\atoi$ : c'est un
lieur\is{lieur} une variable, qui se place en tête d'une expression
bien formée.  

Prenons tout de suite un exemple. La formule \(\Xlo\prd{dormir}(x)\) est une
expression saturée, le prédicat a tous les arguments qu'il lui faut
(en l'occurrence un seul, \vrb x). Pour la désaturer en disant que $\vrb x$
représente en fait quelque chose qui manque, on écrira 
\(\Xlo\lambda x\,\prd{dormir}(x)\).
%Ainsi \(\Xlo\prd{regarder}(x,\cns b)\) est une expression saturée, le
%prédicat a tous ses arguments ; pour la désaturer en disant que $\vrb x$
%représente en fait quelque chose qui manque, on écrira \(\Xlo\lambda
%x\,\prd{regarder}(x,\cns b)\). 
La notation $\Xlo\lambda x$ peut ainsi se lire comme : «dans ce qui
suit, $\vrb x$ représente une place vide» ou «dans ce qui suit,
il manque une valeur à la variable \vrb x~».  On voit donc en quoi
l'opérateur $\Xlo\lambda$ effectue de la «désaturation» de formule
; il permet de faire \emph{abstraction} de la variable qu'il
lie%
\footnote{Et on dira que la variable est alors
  \emph{abstraite} (ou $\lambda$-\emph{abstraite}) dans (ou de) l'expression.}. 
C'est pourquoi $\Xlo\lambda$ est couramment nommé \emph{opérateur
  d'abstraction}, et l'opération qui consiste à préfixer une
expression par une séquence $\Xlo\lambda$-variable est ce qui se nomme
la \kwo{$\lambda$-abstraction}.
%{lambda ($\lambda$)!$\lambda$-abstraction}.  
Il s'agit, pour nous, d'une
nouvelle règle qui vient s'ajouter à la syntaxe de {\LO} :


\begin{defi}[\ulambda-abstraction]\label{d:labstr}
Si $\Xlo\alpha$ est une expression
bien formée de {\LO} et si $\vrb v$ est une variable de {\LO}, alors
$\Xlo\lambda v \alpha$ est une expression bien formée de {\LO}.\\
Nous dirons  que $\Xlo\lambda v \alpha$  est un \kwo{$\lambda$-terme}\footnotemark.
\is{la (lambda)@$\lambda$ (lambda)!$\lambda$-terme}
\end{defi}%
\footnotetext{On trouve souvent les variantes de notation suivantes pour les
  $\lambda$-termes : $\lambda v.\alpha$ ou $\lambda v\mathord{\cdot}\alpha$.
Notons également que je me permets de faire ici un usage un peu hétérodoxe de l'appellation \sicut{\lterme} : en \lcalcul\ classique, \emph{toute} expression du langage est appelée \lterme, qu'elle contienne ou non un symbole $\Xlo\lambda$.  Dans ces pages, pour plus de clarté, je préfère utiliser ce nom seulement pour désigner cette nouvelle catégorie d'expressions de \LO.}


Il est important de remarquer que la définition ne requiert pas que
$\Xlo\alpha$ soit une formule, mais simplement une
\emph{expression bien formée}. Jusqu'à présent, les seules expressions
bien formées de {\LO} que nous connaissions étaient les
formules (et accessoirement les termes et les prédicats) ; mais maintenant nous en
connaissons beaucoup d'autres  
puisque, selon la définition, la $\lambda$-abstraction produit
également des expressions bien formées.  Autrement dit,  l'application de
la règle peut s'itérer autant de fois qu'on le souhaite sur
des
$\lambda$-termes
pour ajouter
plusieurs $\lambda$ au début d'une expression.

%\(\Xlo\lambda x\,\prd{dormir}(x)\)
\sloppy

Ainsi \(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\) est une
expression correcte de {\LO}, car \(\Xlo\prd{regarder}(x,y)\) est une
expression bien formée (une formule),  et par $\lambda$-abstraction on
peut former \(\Xlo \lambda x\,\prd{regarder}(x,y)\), qui est la
formule de départ «sans» \vrb x (mais avec \vrb y), et à partir
de là,  encore
par $\lambda$-abstraction, on forme
\(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\), qui est le
%\fixme{$\lambda$-terme**formule?} 
{\lterme}
précédent mais cette fois vidé également de \vrb y.
Et comme la $\lambda$-abstraction s'applique sur n'importe quelle
expression bien formée, 
on peut construire  \(\Xlo\lambda
x\,\prd{regarder}(x,\cns b)\), ainsi que des  $\lambda$-termes
particulièrement intéressants comme \(\Xlo\lambda x
\exists y [\prd{oiseau}(y) \wedge \prd{regarder}(x,y)]\).
Ce dernier $\lambda$-terme correspond simplement à la formule 
\(\Xlo\exists y [\prd{oiseau}(y) \wedge \prd{regarder}(x,y)]\), mais
sans valeur pour \vrb x (ou privée de \vrb x), ce qui est ni plus ni
moins la traduction du GV \sicut{regarde un oiseau}.
On constate ainsi à quel point la quantité et la variété
d'expressions bien formées que l'on peut construire dans {\LO}
augmentent  par l'ajout de cette seule règle.  


On peut également remarquer que, si $\Xlo\lambda x\,\prd{dormir}(x)$
est, en quelque sorte, la formule $\Xlo\prd{dormir}(x)$ sans le \vrb
x, alors finalement ce $\lambda$-terme est la même chose que le
prédicat \prd{dormir} seul. Et c'est effectivement le cas\footnote{Il
  s'agit même d'un théorème du $\lambda$-calcul ;
  cf. \S\ref{ss:lambconv}.}.  De même, si \(\Xlo\lambda y \lambda
x\,\prd{regarder}(x,y)\) est \(\Xlo\prd{regarder}(x,y)\) sans \vrb x
ni \vrb y, alors cela équivaut simplement à \prd{regarder}. Est-ce à
dire que la $\lambda$-abstraction est juste une manière inutilement
compliquée d'écrire des choses qui existent déjà sous forme simple
dans {\LO} ? Les autres exemples vus ci-dessus nous prouvent bien que
non : on peut composer des $\lambda$-termes pour former des
expressions non saturées qui sont bien plus élaborées qu'une simple
constante de prédicat. De plus, les $\lambda$ apportent une plus value
informative dans les notations, en pouvant faire apparaître explicitement
l'arité\is{arité} des prédicats. 
Quand on a seulement le prédicat
\prd{regarder}, on a besoin de connaissances supplémentaires pour
savoir qu'il prend deux arguments, ce n'est pas écrit dessus. En
revanche, avec \(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\) on
voit immédiatement que le prédicat est à deux arguments (même s'ils ne 
sont pas instanciés dans le $\lambda$-terme). 
Enfin, nous pouvons former 
\(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\),
mais il n'y a pas de raison de ne pas former également 
\(\Xlo\lambda x \lambda y\,\prd{regarder}(x,y)\), qui est lui aussi la
formule \(\Xlo\prd{regarder}(x,y)\) sans \vrb x et \vrb y.  
Ces deux $\lambda$-termes sont ils équivalents ? La réponse est non,
car l'ordre des $\Xlo\lambda$ est significatif. 
Pour s'en convaincre, nous devons maintenant aborder la sémantique de
la $\lambda$-abstraction, c'est-à-dire la règle d'interprétation des
$\lambda$-termes. 

\fussy


\subsubsection{Sémantique de la \ulambda-abstraction}
%''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{ss:Semlabs}

\sloppy

Nous connaissons déjà un peu cette sémantique (cf. \S\ref{ss:SFP}) :
les $\lambda$-termes dénotent des fonctions.  Rappelons qu'une
fonction est un mécanisme qui produit un résultat quand on lui fournit
un ou plusieurs arguments. Or précisément, il se trouve que les
$\lambda$-termes détaillent explicitement ce type de mécanisme : les
préfixes $\Xlo\lambda$+variable indiquent les
arguments\is{argument} 
de la fonction, et le reste ($\Xlo\alpha$ dans la
définition~\ref{d:labstr}, 
que nous appellerons le \emph{corps} de la fonction ou du \lterme)
décrit le résultat que renvoie la fonction.  Ainsi \(\Xlo\lambda
x\,\prd{dormir}(x)\) dénote la fonction qui, pour chaque valeur
possible de \vrb x, renvoie la dénotation qu'a \(\Xlo\prd{dormir}(x)\)
lorsque \vrb x a cette valeur --~ce qui, bien entendu, est exactement
la même chose que la dénotation de \prd{dormir} (cf. \ref{x:xdormirf},
p.~\pageref{x:xdormirf}).  De même, \(\Xlo\lambda x \exists y
[\prd{oiseau}(y) \wedge \prd{regarder}(x,y)]\) dénote la fonction qui
renvoie la dénotation de la formule \(\Xlo\exists y [\prd{oiseau}(y)
  \wedge \prd{regarder}(x,y)]\) pour chaque valeur possible de \vrb x.
Et lorsqu'un \lterme\ comporte plusieurs $\Xlo\lambda$, il dénote une
fonction à plusieurs arguments, telle que nous en avons vue en
\S\ref{ss:fxnaires}, c'est-à-dire une fonction curryfiée.
\(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\) dénote la fonction
qui, pour chaque valeur de \vrb y, renvoie la dénotation de \(\Xlo
\lambda x\,\prd{regarder}(x,y)\) lorsque \vrb y a cette valeur ; et ce
résultat étant la dénotation d'un \lterme, il est lui aussi une
fonction qui, pour toute valeur de \vrb x, renvoie la dénotation de
\(\Xlo\prd{regarder}(x,y)\) lorsque \vrb x a cette valeur (et \vrb y
la valeur précédemment fixée). C'est exactement la définition de la
dénotation de \prd{regarder} donnée \alien{supra} en \ref{xregarderf}.
Mais ce n'est pas la même chose que la dénotation de 
\(\Xlo\lambda x \lambda y\,\prd{regarder}(x,y)\), car ce \lterme\ dénote
d'abord une fonction de \vrb x qui retourne une fonction de \vrb y,
alors que \(\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)\) dénote
d'abord une fonction de \vrb y qui retourne une fonction de \vrb x%
\footnote{En {«clair»} : \(\Xlo\lambda y \lambda
  x\,\prd{regarder}(x,y)\) dénote la fonction qui pour tout regardé
(potentiel)
  renvoie la fonction qui dit qui le regarde, et \(\Xlo\lambda x
  \lambda y\,\prd{regarder}(x,y)\) dénote la fonction qui pour tout
  regardeur (potentiel)
renvoie la fonction qui dit qui il regarde.}. 

\fussy\largerpage[1]

Donc de manière générale, en reprenant la définition~\ref{d:labstr},
on dira que \(\Xlo\lambda v \alpha\) dénote la fonction qui, pour
toute valeur possible de \vrb v, retourne la dénotation qu'a
$\Xlo\alpha$ lorsque \vrb v a cette valeur. 
Et nous savons définir la dénotation de $\Xlo\alpha$ pour une valeur
donnée de \vrb v : c'est la %valeur sémantique 
dénotation de  $\Xlo\alpha$
calculée relativement à une assignation qui fixe la valeur de \vrb v à 
cette valeur donnée.  Cela nous donne la règle d'interprétation des
\lterme s :


\begin{defi}[Interprétation des \ulambda-termes]\label{d:slabs}
$\denote{\Xlo\lambda v\alpha}^{\Modele,w,g}$ est la fonction 
%qui pour tout individu \Obj{d} de \Unv{A} donne 
$\Obj{x} \longmapsto
  \denote{\Xlo\alpha}^{\Modele,w,g_{[\Obj{x}/\vrb v]}}$, où \Obj x est un
  élément de \Unv A. 
\end{defi}


\newpage

Cette sémantique nous montre que la \labstraction\ est, par vocation, 
une opération qui sert à fabriquer des fonctions {à la chaîne}
dans {\LO}\footnote{Ou, pour être plus rigoureux vis-à-vis de notre
  formalisme, il faudrait dire : qui sert à fabriquer des expressions
  de {\LO} qui dénotent des fonctions.}.




\subsection{L'application fonctionnelle}
%---------------------------------------
\is{application fonctionnelle|(}

C'est dans la nature des fonctions d'attendre qu'on leur fournisse un
(ou plusieurs) argument(s).  De même, dans {\LO}, les \lterme s, étant
des expressions non saturées, sont en demande de saturation, en attente
d'être complétées. 
D'ailleurs, à cet égard, 
$\Xlo\lambda x$ peut se lire aussi comme : «j'attends une valeur pour
\vrb x afin d'interpréter ce qui suit» (cela peut être commode
parfois pour décoder le sens d'un \lterme\ un peu complexe).
Il est donc du devoir de {\LO} de se donner les moyens de satisfaire
ces attentes, c'est-à-dire de donner des arguments aux \lterme s. Il
s'agit en quelque sorte de l'opération inverse de la \labstraction,
opération qui sature les expressions au lieu de les désaturer. C'est
ce qu'on appelle l'\kw{application fonctionnelle}.


\subsubsection{Syntaxe de l'application fonctionnelle dans LO}
%''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{ss:Syn@}
Dans la syntaxe de {\LO}, l'application fonctionnelle joue le même
rôle que la règle (\RSyn\ref{SynPApp}) que nous connaissons déjà (et
à terme, nous allons même nous débarrasser de cette dernière, qui va devenir
inutile).  
D'ailleurs elles se ressemblent beaucoup : 

\begin{defi}[Notation de l'application fonctionnelle]\label{def:f@}
\is{application fonctionnelle}%
Si $\Xlo\alpha$ est %un $\lambda$-terme, c'est-à-dire 
une expression qui
dénote une fonction et si $\Xlo\beta$ est 
%une expression de {\LO} 
un terme,
alors pour
\kwo{appliquer} $\Xlo\alpha$ à $\Xlo\beta$, on écrit
$\Xlo[\alpha(\beta)]$.  
C'est une expression bien formée de {\LO}.  
\end{defi}


L'écriture $\Xlo[\alpha(\beta)]$ indique donc que l'on fournit
$\Xlo\beta$ comme argument à $\Xlo\alpha$ (c'est ce que signifie
«appliquer $\Xlo\alpha$ à $\Xlo\beta$~»).  
Par exemple, si l'on veut donner la constante \cns a en argument au
\lterme\ 
\(\Xlo\lambda x\,\prd{dormir}(x)\), on écrit 
\(\Xlo[\lambda x\,\prd{dormir}(x)(\cns a)]\).
Et il s'agit là d'une expression saturée (une formule) : 
$\Xlo\lambda x$
dit que \vrb x représente sémantiquement une place vide, mais de
l'autre côté, l'écriture $\Xlo(\cns a)$ dit que \cns a vient justement
occuper cette place ; le trou est donc bouché.

Le point commun graphique entre la règle de la définition~\ref{def:f@}
et la règle (\RSyn\ref{SynPApp}) est que la donnée d'un argument (à un
prédicat ou à une expression fonctionnelle) s'écrit au moyen de
parenthèses.  Mais il y a deux différences formelles non triviales :
i) avec l'application fonctionnelle, on ajoute des crochets%
\footnote{Certes, dans la littérature, la grande majorité des écrits
  ne s'embarrasse pas de ces crochets, et note l'application
  fonctionnelle simplement par $\Xlo\alpha(\beta)$. Mais nous verrons
  que dans quelques cas, cela n'est pas toujours très prudent ; voir
  en particulier l'exercice \ref{lcombin[]}, p.~\pageref{lcombin[]}.}, 
et ii) on
ne fournit qu'un seul argument à la fois (ce qui est normal puisque,
rappelons-nous, les prédicats et les \lterme s dénotent des fonctions
\emph{curryfiées}).  
Dans la syntaxe de {\LO},
cela a plusieurs conséquences qui méritent d'être observées
attentivement.

D'abord, on a tout à fait le droit d'effectuer l'application
fonctionnelle directement sur un prédicat comme \prd{dormir},
puisqu'il dénote une fonction. Appliqué à \cns a, cela nous donnera
$\Xlo[\prd{dormir}(\cns a)]$, alors que (\RSyn\ref{SynPApp}) donne 
$\Xlo\prd{dormir}(\cns a)$.

\sloppy

Ensuite, si l'on veut donner plusieurs arguments à un \lterme\ (ou un
prédicat), il faut répéter l'application fonctionnelle autant de fois
que nécessaire.  Par exemple, l'application \(\Xlo[\lambda y\lambda
  x\,\prd{regarder}(x,y)(\cns b)]\) indique que \cns b est donné comme
premier argument au \lterme\ \(\Xlo\lambda y\lambda
x\,\prd{regarder}(x,y)\) ; mais comme ce \lterme\ attend aussi un
second argument, \(\Xlo[\lambda y\lambda
  x\,\prd{regarder}(x,y)(\cns b)]\)
 dénote lui aussi une fonction
; on peut donc encore effectuer une application fonctionnelle, ce qui
donne, par exemple, \(\Xlo[[\lambda y\lambda
  x\,\prd{regarder}(x,y)(\cns b)](\cns a)]\).
C'est là que les crochets sont importants et utiles.
Ils permettent de repérer, sans aucune ambiguïté, quel argument est
donné à quelle expression fonctionnelle.  Lorsqu'une application
fonctionnelle  est écrite dans {\LO} encadrée de crochets, on sait que
l'argument est ce qui se trouve dans la paire de parenthèses située
\emph{juste avant} le crochet fermant, et tout ce qui précède et qui
commence \emph{exactement après} le crochet ouvrant est ce qui dénote la
fonction.  Et ainsi cela indique dans quel ordre un \lterme\ (ou une
expression fonctionnelle) «consomme» ses arguments.  Dans notre
exemple, \cns a est forcément le deuxième argument fourni puisqu'on
lui applique \(\Xlo[\lambda y\lambda x\,\prd{regarder}(x,y)(\cns b)]\)
qui contient \emph{déjà} \cns b comme argument
(cf. fig.~\ref{f:AFordreab}). 

\fussy

\begin{figure}[h]
\begin{center}
{\large
\({\Xlo[}\underbrace{{\Xlo[}\underbrace{\Xlo\lambda y\lambda
  x\,\prd{regarder}(x,y)}_{\text{%\lterme\ 
expression appliquée à \cns b}}\Xlo(\cns b)]}%
_{\text{%\lterme\ 
expression appliquée à \cns a}}
\Xlo(\cns a)]\)}
\caption{Ordre des applications dans \ensuremath{\Xlo[[\lambda y\lambda
  x\,\prd{regarder}(x,y)(\cns b)](\cns a)]}}\label{f:AFordreab}
\end{center}
\end{figure}

De même, la définition~\ref{def:f@} nous permet de créer
\(\Xlo[[\prd{regarder}(\cns b)](\cns a)]\).  En revanche, si --~comme je l'ai
annoncé~-- nous nous débarrassons de la règle (\RSyn\ref{SynPApp}), alors nous
ne pourrons carrément plus écrire \(\Xlo\prd{regarder}(\cns a,\cns b)\)
ou \(\Xlo\prd{regarder}(\cns b,\cns a)\), etc.  Évidemment, si nous
ne disposons que de la définition~\ref{def:f@}, nous allons très
rapidement obtenir des 
écritures surchargées, lourdes et peu agréables à
manipuler, comme par exemple \(\Xlo[[\prd{homme}(\cns c)] \wedge
  [[\prd{regarder}(\cns a)](\cns c)]]\). Heureusement, il est 
courant de s'autoriser quelques simplifications graphiques.

D'abord,
\emph{lorsque cela ne produit aucune ambiguïté possible}, on supprimera les
crochets générés par l'application fonctionnelle (ainsi que ceux qui
viennent des règles de (\RSyn\ref{SynPConn})\footnote{Les règles qui
  introduisent les connecteurs binaires.}).  Par exemple, on préférera souvent 
écrire \(\Xlo\prd{homme}(\cns{c}) \wedge \prd{regarder}(\cns{a})(\cns{c})\). 
%plutôt que  \([[\prd{homme}(\cns{j})] \wedge [[\prd{aimer}(\cns{a})](\cns{j})]]\).  
Mais attention : il s'agit
d'être très vigilant et de bien s'assurer que la suppression de
crochets est sémantiquement inoffensive ;  il n'est pas toujours si
évident de repérer au premier coup d'{\oe}il  les crochets
dispensables (voir à cet effet l'exercice~\ref{exo:types:crochets},
p.~\pageref{exo:types:crochets}).   


Ensuite, la seconde simplification
d'écriture nous autorise à revenir aux notations
du style de (\RSyn\ref{SynPApp}),
%plus traditionnelles des prédicats relationnels 
en regroupant les arguments sous forme de liste
entre une seule paire de parenthèses.  
Et c'est précisément ici qu'entre en jeu 
la convention d'inversion
des arguments que nous avons vue en \S\ref{ss:fxnaires}. La voici
dans sa formulation explicite%
\footnote{En toute rigueur, cette règle de simplification ne fait pas
strictement  partie de la syntaxe de {\LO}. C'est, disons, un cadeau
que nous nous faisons afin d'obtenir, après coup, des écritures plus
«conviviales».%«~\alien{user-friendly}~».
} : 



\begin{conv}[Règle de suppression des crochets]\label{c:suppr[]}\is{regle@règle!\elid\ de suppression des crochets}\sloppy
Dans {\LO}, on s'autorisera, quand cela sera possible et utile,  à
simplifier l'écriture 
$\Xlo[[\alpha(\beta)](\gamma)]$ en $\Xlo\alpha(\gamma,\beta)$ (ou seulement
$\Xlo[\alpha(\gamma,\beta)]$ si c'est nécessaire), et plus
généralement $\Xlo[[\dotso[[\alpha(\beta_1)](\beta_2)]\dots](\beta_n)]$ en
$\Xlo\alpha(\beta_n,\dotsc,\beta_2,\beta_1)$ 
(ou $\Xlo[\alpha(\beta_n,\dotsc,\beta_2,\beta_1)]$).
\end{conv}\fussy

\renewcommand{\firstrefdash}{-}

\sloppy

Ainsi nous pourrons reformuler 
\(\Xlo[[\prd{regarder}(\cns b)](\cns a)]\) en
\(\Xlo\prd{regarder}(\cns a,\cns b)\).
Cette règle a donc trois effets : supprimer les crochets, regrouper
les arguments successifs au sein d'une seule paire de parenthèses, et
inverser l'ordre des arguments.  Par conséquent, l'écriture de base de
l'application fonctionnelle (avec les crochets) nous rappelle dans
{\LO} que les fonctions du modèle sont curryfiées, et l'écriture
simplifiée fait le raccord avec la syntaxe plus traditionnelle de la
règle (\RSyn\ref{SynPApp}). 
Et cela va même encore plus loin, puisque maintenant on peut aisément
constater que (\RSyn\ref{SynPApp}) devient redondante (et donc
inutile) avec les effets conjugués de la définition~\ref{def:f@} et
de la convention~\ref{c:suppr[]}. 
Par exemple, \ref{x514} montre comment composer  complètement
\(\Xlo[[\lambda y\lambda   x\,\prd{regarder}(x,y)(\cns b)](\cns a)]\)
en utilisant uniquement les règles présentées dans ce chapitre :

\fussy

\ex. \label{x514}
\let\oldalph=\alph\let\alph=\arabic
\a. \(\prd{regarder}\) 
  \taquet{.4\textwidth}{\small prédicat d'arité 2}
\b. \(\Xlo[\prd{regarder}(y)]\) 
  \taquet{.4\textwidth}{\small application fonctionnelle sur \vrb y}
\b. \(\Xlo[[\prd{regarder}(y)](x)]\)
  \taquet{.4\textwidth}{\small application fonctionnelle sur \vrb x}
\b. \(\Xlo\prd{regarder}(x,y)\)
  \taquet{.4\textwidth}{\small suppression des crochets}
\b. \(\Xlo\lambda x\,\prd{regarder}(x,y)\)
  \taquet{.4\textwidth}{\small \labstraction\ sur \vrb x}
\b. \(\Xlo\lambda y\lambda x\,\prd{regarder}(x,y)\)
  \taquet{.4\textwidth}{\small \labstraction\ sur \vrb y}
\b. \(\Xlo[\lambda y\lambda x\,\prd{regarder}(x,y)(\cns b)]\)
  \taquet{.4\textwidth}{\small application fonctionnelle sur \cns b}
\b. \(\Xlo[[\lambda y\lambda x\,\prd{regarder}(x,y)(\cns b)](\cns a)]\)%
\footnote{On pourrait même continuer et simplifier encore en 
\(\Xlo\lambda y\lambda x\,\prd{regarder}(x,y)(\cns a,\cns b)\),
mais là, pour le coup, je ne le recommande pas du tout ! Nous allons
voir qu'il y d'autres façons de poursuivre la simplification.}
  \taquet{.4\textwidth}{\small application fonctionnelle sur \cns a}
\global\let\alph=\oldalph


\sloppy

Il est important de noter que selon l'ordre dans lequel on effectue
des \labstraction s et des applications fonctionnelles, on obtiendra
des expressions non équivalentes. Et dans certains cas, les crochets
seront justement placés différemment.  
Par exemple, 
quand on a construit \(\Xlo[[\prd{regarder}(y)](x)]\), on peut d'abord
$\lambda$-abstraire \vrb y, puis \vrb x (à l'inverse de \ref{x514}), ce
qui donne  \(\Xlo\lambda x\lambda y[[\prd{regarder}(y)](x)]\)
(simplifiable en \(\Xlo\lambda x\lambda y\,\prd{regarder}(x,y)\)) :

\fussy

\ex. \label{x515}
\let\oldalph=\alph\let\alph=\arabic
\a. \(\Xlo[\prd{regarder}(y)]\)
  \taquet{.4\textwidth}{\small application fonctionnelle sur \vrb y}
\b. \(\Xlo[[\prd{regarder}(y)](x)]\)
  \taquet{.4\textwidth}{\small application fonctionnelle sur \vrb x}
\b. \(\Xlo\lambda y[[\prd{regarder}(y)](x)]\)
  \taquet{.4\textwidth}{\small \labstraction\ sur \vrb y}
\b. \(\Xlo\lambda x\lambda y[[\prd{regarder}(y)](x)]\)
\label{x515d}
  \taquet{.4\textwidth}{\small \labstraction\ sur \vrb x}
\global\let\alph=\oldalph


Mais on peut procéder dans un ordre différent.
Après avoir formé \(\Xlo[\prd{regarder}(y)]\), on peut
faire la \labstraction\ de \vrb y,
% : \(\Xlo\lambda y[\prd{regarder}(y)]\).  Puis 
puis appliquer cela à \vrb x,
% : \(\Xlo[\lambda y [\prd{regarder}(y)](x)]\). Et 
et enfin $\lambda$-abstraire \vrb x : 
%\(\Xlo\lambda x[\lambda  y [\prd{regarder}(y)](x)]\).

\ex. \label{x516}
\let\oldalph=\alph\let\alph=\arabic
\a. \(\Xlo[\prd{regarder}(y)]\)
\taquet{.4\textwidth}{\small application fonctionnelle sur \vrb y}
\label{x516a}%
\b. \(\Xlo\lambda y[\prd{regarder}(y)]\)
\taquet{.4\textwidth}{\small \labstraction\ sur \vrb y}
\label{x516b}%
\b. \(\Xlo[\lambda y[\prd{regarder}(y)](x)]\)
\taquet{.4\textwidth}{\small application fonctionnelle sur \vrb x}
\label{x516c}%
\b. \(\Xlo\lambda x[\lambda y[\prd{regarder}(y)](x)]\)
\taquet{.4\textwidth}{\small \labstraction\ sur \vrb x}
\label{x516d}%
\global\let\alph=\oldalph


Les \lterme s \ref{x515d} et \ref{x516d} ne sont pas équivalents. 
D'abord \ref{x516d} n'est pas simplifiable par la
convention~\ref{c:suppr[]}\footnote{Car la règle de suppression des
  crochets s'applique sur des expressions qui commencent par une
  séquence ne comportant \emph{que} des crochets ouvrants ($\Xlo[[$,
      $\Xlo[[[$, etc.), rien ne doit s'intercaler entre deux crochets.}. 
Ensuite \ref{x515d} est relativement simple, il indique explicitement
qu'il attend deux arguments, d'abord \vrb x puis \vrb y.  Ce n'est pas
exactement ce qui se passe dans \ref{x516}. En \ref{x516b}, on désature
la position \vrb y de \(\Xlo[\prd{regarder}(y)]\), et en \ref{x516c},
on fournit \vrb x, pour venir saturer cette position. Autrement dit
\vrb x joue le rôle de \vrb y. Et \ref{x516d} indique qu'il manque une
valeur pour \vrb x.  Par conséquent, si, par application
fonctionnelle, on fournit un argument à \ref{x516d}, par exemple \cns
a, cet argument viendra jouer le rôle de \vrb x et aussi de \vrb y
(puisque \vrb x joue le rôle de \vrb y).  Alors que si on applique
\ref{x515d} à \cns a, cet argument viendra jouer le rôle de \vrb x
seulement, et \vrb y restera désaturé.

\renewcommand{\firstrefdash}{}

\medskip
%\Writetofile{solf}{\protect\largerpage}

\input{exo/lambdacombincrochets}

\input{exo/lambdacrochets}

\input{exo/varlambdacrochets}


\subsubsection{Interprétation de l'application fonctionnelle}
%''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{ss:Sem@F}

\sloppy
Ayant introduit l'application fonctionnelle dans la syntaxe de {\LO},
nous devons, comme d'habitude, aussitôt définir sa règle
d'interprétation sémantique.  Alors là, c'est très simple :
l'interprétation de l'application fonctionnelle,
c'est... l'application fonctionnelle.
Mais il s'agit à présent de l'application fonctionnelle \emph{opérationnelle},
la réelle application fonctionnelle%
\footnote{Car la définition \ref{def:f@} ne définit \emph{qu'une
    notation} : la
  façon d'écrire l'application fonctionnelle dans notre langage {\LO}.}, 
cette opération mathématique, présente dans le modèle, qui
non seulement réunit une fonction et un argument, mais aussi --~et
surtout~-- 
%qui 
livre le résultat que la fonction assigne à cet argument
(par un calcul ou simplement un système de correspondances).
C'est ce que nous avons utilisé en \S\ref{ss:SFP}, quand nous avons,
par exemple,
calculé la valeur de \(\denote{\prd{dormir}}^{\Modele,\w_1,g}(\Obj{Alice})\)
(p.~\pageref{SFP1@} ; cf. aussi l'exercice \ref{exo:fxregarder},
p.~\pageref{exo:fxregarder}). 

\fussy


\begin{defi}[Interprétation de l'application fonctionnelle]\label{d:Sem@}
\(\denote{\Xlo[\alpha(\beta)]}^{\Modele,w,g}=\denote{\Xlo\alpha}^{\Modele,w,g}(\denote{\Xlo\beta}^{\Modele,w,g})\)
\end{defi}


\sloppy
La règle dit simplement que la dénotation de l'application
\(\Xlo[\alpha(\beta)]\) est l'application de la dénotation de
$\Xlo\alpha$ à la dénotation de 
$\Xlo\beta$.  Quand on regarde l'application fonctionnelle dans le
modèle,
\(\denote{\Xlo\alpha}^{\Modele,w,g}(\denote{\Xlo\beta}^{\Modele,w,g})\), 
on voit qu'elle ressemble fort à ce que l'on écrit dans {\LO},
\(\Xlo[\alpha(\beta)]\) ; mais il faut toujours bien garder à
l'esprit que l'écriture
\(\denote{\Xlo\alpha}^{\Modele,w,g}(\denote{\Xlo\beta}^{\Modele,w,g})\) 
représente  \emph{le résultat} de
l'application de la dénotation de $\Xlo\alpha$ à la dénotation de
$\Xlo\beta$.  Et c'est bien ce que nous avons vu en \S\ref{ss:SFP},
en constatant que
\(\denote{\prd{dormir}}^{\Modele,\w_1,g}(\Obj{Alice})\) est
concrètement la même chose que la valeur $1$ (étant donné comment nous
avons défini les dénotations dans $\w_1$) ; 
de même que,
concrètement,   
\(\denote{\prd{regarder}}^{\Modele,\w_1,g}(\Obj{Alice})\) est la fonction 
décrite en \ref{xregardfA} (p.~\pageref{xregardfA}).

\fussy

Cette règle sémantique va, bien sûr, remplacer les règles
(\RSem\ref{RIprd2}) (cf. pp.~\pageref{RIprd}, \pageref{RIprd2}) qui
interprétaient les formules atomiques.  Mais elle 
se présente différemment.  
Les règles (\RSem\ref{RIprd2}) donnaient explicitement des conditions
de vérité : 
elles disaient dans quels cas on obtenait la valeur $1$ pour la
dénotation d'une formule (et on savait que la valeur serait $0$ dans les
autres cas).  
Ici, au lieu de nous proposer une valeur, la règle nous donne
directement l'opération  qui nous permet de la calculer. 
Et c'est beaucoup plus performant car, comme on la vu, le résultat peut
être autre chose qu'une valeur de vérité, à savoir  une fonction. 

\sloppy

En guise d'illustration, regardons ce qui se passe en particulier si
l'expression 
fonctionnelle $\xlo{\alpha}$ est un {\lterme}, \ie\ si
$\xlo{\alpha}=\xlo{\lambda v \gamma}$. Supposons d'abord que 
\(\denote{\Xlo\beta}^{\Modele,w,g} = \Obj{b}\).
Alors, d'après notre définition~\ref{d:Sem@}, nous avons
\(\denote{\Xlo[\lambda v \gamma(\beta)]}^{\Modele,w,g} = 
\denote{\Xlo\lambda v \gamma}^{\Modele,w,g}(\denote{\Xlo\beta}^{\Modele,w,g}) = 
\denote{\Xlo\lambda v \gamma}^{\Modele,w,g}(\Obj{b})\).  Nous savons
aussi que \(\denote{\Xlo\lambda v \gamma}^{\Modele,w,g}\) est la
fonction qui à tout \Obj x assigne la valeur 
\(\denote{\Xlo\gamma}^{\Modele,w,g_{[\Obj{x}/v]}}\),
selon la définition~\ref{d:slabs}. 
Et donc, lorsque c'est \Obj b que l'on donne  en argument à cette fonction, le
résultat obtenu est \(\denote{\Xlo\gamma}^{\Modele,w,g_{[\Obj{b}/v]}}\).
Autrement dit, 
\(\denote{\Xlo\lambda v \gamma}^{\Modele,w,g}(\Obj{b})
=
\denote{\Xlo\gamma}^{\Modele,w,g_{[\Obj{b}/v]}}\).
C'est bon à savoir.

\fussy

\begin{theo}\label{th:Seml@}
Si \(\denote{\Xlo\beta}^{\Modele,w,g} = \Obj b\), alors
\(\denote{\Xlo[\lambda v \gamma(\beta)]}^{\Modele,w,g} = 
\denote{\Xlo\gamma}^{\Modele,w,g_{[\Obj{b}/v]}}\).
\end{theo}

Pour terminer, l'exercice suivant reprend  les exemples \ref{x515} et
\ref{x516} en démontrant précisément que les deux termes n'ont pas le
même sens.

\input{exo/IlAbsApF.tex}


\subsubsection{La colle universelle}
%'''''''''''''''''''''''''''''''''''
\label{ss:glue}

Le \lamb-calcul augmente considérablement l'expressivité de {\LO} en
permettant d'affecter une sémantique fonctionnelle à
certaines\footnote{Et nous verrons, à terme, que quasiment
  \emph{toutes} les expressions interprétables du français peuvent
  recevoir une sémantique fonctionnelle.}  expressions du français,
via leur traduction par des \lterme s.  Cela a une conséquence
immédiate et fondamentale 
sur le traitement de la
compositionnalité\is{compositionnalité} dans notre système. 
En fait, c'est quelque chose que nous avons déjà vu en \S\ref{ss:SFP} :
certains constituants des phrases correspondent à des expressions non saturées
sémantiquement, \ie\ des fonctions, et ils se saturent au fur et à
mesure en rencontrant d'autres constituants dans l'arbre syntaxique
qui jouent précisément le rôle d'arguments de ces fonctions. Autrement
dit, la composition sémantique  se réalise
via  l'application fonctionnelle.  
Et il convient même d'insister ici en disant que, selon la proposition
de Montague,\Andex{Montague, R.}  
véritablement \emph{toute} composition sémantique
s'effectue  de cette façon\footnote{Même si, plus tard
  on s'est aperçu que les choses n'étaient peut-être pas aussi simple
  et que d'autres modes de composition pouvaient s'avérer utiles,
  voire nécessaires. Pour autant nous pouvons estimer que l'application
  fonctionnelle reste l'opération centrale, parce que la plus fréquente.}.
Cette idée de gérer la
compositionnalité au moyen d'un unique mécanisme sémantique
% a d'ailleurs été
%une des innovations les plus remarquables des travaux de Montague.
%Elle 
repose donc sur le présupposé que lorsqu'un constituant
(syntaxique) se décompose en deux\footnote{Nous verrons que cela
  fonctionne également pour plus de deux sous-constituants directs.}
 sous-constituants, forcément l'un des deux
dénote une fonction et l'autre dénote un argument de cette fonction.
C'est ce qu'illustre la figure~\ref{f:schemcompsem}, en montrant
comment, dans un arbre syntaxique décoré de traductions sémantique, le
sens des sous-constituants 
remonte au niveau du n\oe ud supérieur.

\begin{figure}[h]
\begin{center} 
{\large
\Tree
[.X\zbox{\ \(\Xlo[\rnode{ax1}{\alpha}(\rnode{bx1}{\beta})]\)}  
  Y\\$\Xlo\rnode{ay1}{\alpha}$ 
  Z\\$\Xlo\rnode{bz1}{\beta}$  §{\qbalance}
]  \nccurve[nodesep=2pt,angleA=45,angleB=-90,linecolor=gray]{->}{ay1}{ax1}\nccurve[nodesepA=2pt,nodesepB=1pt,angleA=45,angleB=-90,linecolor=gray]{->}{bz1}{bx1}
}
\qquad\qquad
ou
\qquad
{\large
\Tree
[.X\zbox{\ \(\Xlo[\rnode{bx2}{\beta}(\rnode{ax2}{\alpha})]\)}  
  Y\\$\Xlo\rnode{ay2}{\alpha}$ 
  Z\\$\Xlo\rnode{bz2}{\beta}$  §{\qbalance}
]  \nccurve[nodesep=2pt,angleA=45,angleB=-110,linecolor=gray]{->}{ay2}{ax2}\nccurve[nodesep=1pt,angleA=135,angleB=-90,linecolor=gray]{->}{bz2}{bx2}
}
\caption{Schémas de composition sémantique dans un sous-arbre syntaxique}\label{f:schemcompsem}
\end{center}
\end{figure}


La figure montre deux schémas possibles, selon que le n\oe ud
inférieur qui dénote la fonction est celui de gauche (Y) ou de droite
(Z).  Et c'est la grammaire de la langue qui nous donne cette
information.  
Par exemple, si nous nous situons au niveau d'un GV qui se décompose
en un V transitif et un GN (objet), alors nous savons que la fonction
est dénotée par le V (et le GN correspond à l'argument) --~nous le savons car, bien entendu, c'est dans la nature d'un verbe
d'être sémantiquement un prédicat  non saturé.
Et si nous nous situons au
niveau d'une phrase P se décomposant en un GN sujet et un GV, alors
c'est le GV qui fournit la fonction.

À partir de là, nous sommes en mesure de construire complètement et
pas à pas la traduction sémantique de notre phrase de départ
\ref{x:trd1} en affectant à chaque constituant de l'arbre une expression
interprétable de {\LO} :

\ex.  \label{x:compoArB}
Alice regarde Bruno.
\\
\Tree
[.{P\zbox{\ \(\Xlo[[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})](\cns{a})]\)}}
  [.GN \pile{Alice\\\cns a} ]
  [.{GV\zbox{\ \(\Xlo[\lambda y \lambda x \,\prd{regarder}(x,y)(\rnode{b1}{\cns{b}})]\)}} 
    [.V \pile{regarde\\\zcbox{\(\Xlo\lambda y \lambda x \,\prd{regarder}(x,y)\)\rule{3em}{0pt}}} ]
    [.GN \pile{Bruno\\\rnode{b0}{\cns b}} ]
  ]
]
%\nccurve[nodesep=2pt,angleA=20,angleB=-90,linecolor=gray]{->}{b0}{b1}


La traduction du V se combine par application fonctionnelle avec celle
du GN objet pour donner la traduction du GV, puis celle-ci est
appliquée à la traduction du GN sujet pour donner la traduction de la
phrase.
D'accord, le résultat obtenu ne ressemble pas vraiment à ce que l'on
avait prévu en  \ref{x:trd1b}.  Mais remarquons d'abord
qu'alternativement, nous aurions eu
tout à fait le droit d'utiliser simplement la constante de prédicat
\prd{regarder} pour traduire le verbe \sicut{regarde}, puisque nous
avons vu qu'elle est équivalente au \lterme\ 
\(\Xlo\lambda y \lambda x \,\prd{regarder}(x,y)\).
Dans ce cas, toujours par l'application fonctionnelle,
la traduction du GV aurait été 
\(\Xlo[\prd{regarder}(\cns b)]\), et celle de la phrase 
\(\Xlo[[\prd{regarder}(\cns b)](\cns a)]\). Et ensuite notre règle
de suppression des crochets nous aurait permis de simplifier en 
\(\Xlo\prd{regarder}(\cns a,\cns b)\), comme
attendu. \emph{Cependant}, la représentation 
\(\Xlo[[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})](\cns{a})]\)
que nous obtenons en \ref{x:compoArB} est parfaitement correcte et
adéquate pour traduire le sens de la phrase : c'est une formule et
nous savons qu'elle est équivalente à \(\Xlo\prd{regarder}(\cns a,\cns
b)\) ; il n'y a pas de raison de la rejeter sous prétexte qu'elle est
plus longue ou plus complexe.  Et puisque dorénavant nous 
adoptons explicitement les \lterme s pour formaliser les prédicats dans
{\LO}, c'est  donc ce genre de représentation que nous construirons
pour traduire compositionnellement le sens des phrases. 

Heureusement, nous allons voir qu'il existe tout de même des moyens de
revenir à des notations plus simples et plus traditionnelles tout en
utilisant le \lcalcul.

\is{application fonctionnelle|)}


\subsection{La \ubeta-réduction}
%-------------------------------
\label{ss:breduc}
\is{beta-reduction@$\beta$-réduction}

Le \lcalcul\ comprend quelques règles de simplification que l'on
appelle des réductions ou des conversions et qui sont regroupées sous
le terme général de 
\lamb-conversion.\is{la (lambda)@$\lambda$ (lambda)!$\lambda$-conversion}
Celle qui nous sera la plus utile s'appelle 
la \kwo{$\beta$-réduction}.  Voici sa définition :

\begin{defi}[\textit β-réduction]\label{d:breduc1}
Dans une expression de {\LO} qui contient une application
fonctionnelle de la forme \(\Xlo[\lambda v \alpha(\gamma)]\), on
peut remplacer cette application par 
\([\xlo{\gamma}/\vrb v]\xlo{\alpha}\).
\\
Effectuer la \kwo{${\beta}$-réduction} sur \(\Xlo[\lambda
  v \alpha(\gamma)]\) consiste simplement à effectuer cette substitution.
\end{defi}

Rappelons d'abord que l'écriture \([\xlo{\gamma}/\vrb v]\xlo{\alpha}\)
représente la variante de l'expression $\xlo{\alpha}$ dans laquelle on
a remplacé toutes les occurrences libres (cf. déf.~\ref{d:vlibr},p.~\pageref{d:vlibr}) de la variable \vrb v par
l'expression $\xlo{\gamma}$.  La règle de la $\beta$-réduction ne fait
qu'incarner dans {\LO} une idée que nous avons déjà rencontrée. En
effet, lorsque, par application fonctionnelle, on donne un argument
$\vrb\gamma$ à un \lterme\ $\Xlo\lambda v\alpha$, $\vrb\gamma$ vient
saturer la variable \vrb v du \lterme, c'est-à-dire que $\vrb\gamma$
joue le rôle de \vrb v à l'intérieur de $\vrb\alpha$ ; et donc dans ce
cas, \vrb v ne représente plus une place vide dans $\Xlo\alpha$ (\vrb v disparaît de $\Xlo\alpha$) et $\Xlo\lambda v$ n'a plus de raison d'être.

%\([\lambda x\, \alpha(\gamma)] \stackrel{\beta\text{-réd}}{\longrightarrow} [\gamma/x]\alpha\)
%\([\lambda v \alpha(\gamma)] \stackrel{\beta}{=} [\gamma/v]\alpha\)


En pratique la $\beta$-réduction est une simple opération graphique qui fait le ménage dans une application fonctionnelle ; les étapes de l'opération sont les suivantes. Pour $\beta$-réduire  \(\Xlo[\lambda v \alpha(\gamma)]\) :
\begin{enumerate}
\item on supprime la paire de crochets de l'application fonctionnelle ;
\item on supprime le $\Xlo\lambda v$ ;
\item on supprime l'argument donné $\Xlo(\gamma)$ avec ses parenthèses (mais on garde $\Xlo\gamma$ en mémoire) ;
\item dans ce qui reste, on remplace toutes les occurrences libres de la
  variable $\vrb v$ par  $\Xlo\gamma$.
\end{enumerate}

La $\beta$-réduction va beaucoup nous faciliter la vie, mais il faut bien prendre garde à ne pas commettre d'erreur dans son exécution. Il est primordial de reconnaître exactement le schéma d'application
fonctionnelle suivant : {\boldmath\(\Xlo[\lambda v \dots (\dots)]\)} (c'est-à-dire un $\Xlo\lambda$ qui suit \emph{immédiatement} un crochet ouvrant et un argument entre parenthèses qui précède \emph{immédiatement} le crochet fermant). 


\begin{figure}[h]
\begin{center}
{\Large ~\\[2em]
\sout{\Xlo$[\lambda v$}$\Xlo\rnode{aa}{\alpha}$\sout{\Xlo$(\rnode{ga}{\gamma})]$}}
\nccurve[nodesep=2pt,angleA=90,angleB=90,linecolor=gray,ncurv=2,labelsep=0pt]{->}{ga}{aa}%
\nbput{\footnotesize$[\xlo\gamma/\xlo v]$}
\caption{La $\beta$-réduction en image}
\end{center}
\end{figure}

Pour illustrer l'opération, revenons à l'arbre \ref{x:compoArB}, qui nous donnait comme traduction finale de la phrase \(\Xlo[[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})](\cns{a})]\).  Voici comment la simplifier, pas à pas, par $\beta$-réduction :

\ex.
\a. \(\Xlo[[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})](\cns{a})]\) ici nous reconnaissons que nous pouvons réduire l'application fonctionnelle qui se trouve entre dans la paire de crochets la plus intérieure (de $\Xlo\lambda y$ jusqu'à $\Xlo(\cns b)$)
\b. on supprime ces crochets : \(\Xlo[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})(\cns{a})]\) 
\b. on supprime $\Xlo\lambda y$ : \(\Xlo[\lambda x \,\prd{regarder}(x,y)(\cns{b})(\cns{a})]\) 
\b. on supprime $\Xlo(\cns b)$ : \(\Xlo[\lambda x \,\prd{regarder}(x,y)(\cns{a})]\) 
\b. on remplace \vrb y par  $\Xlo\cns b$ : \(\Xlo[\lambda x \,\prd{regarder}(x,\cns{b})(\cns{a})]\) 
\b. nous obtenons un nouveau schéma simplifiable \(\Xlo[\lambda x \,\prd{regarder}(x,\cns{b})(\cns{a})]\), nous pouvons donc recommencer :
\b. \(\Xlo\lambda x \,\prd{regarder}(x,\cns{b})(\cns{a})\)
\b. \(\Xlo\prd{regarder}(x,\cns{b})(\cns{a})\)
\b. \(\Xlo\prd{regarder}(\cns{a},\cns{b})\)


\sloppy
Bien entendu, dans l'arbre \ref{x:compoArB}, nous pouvions tout de suite (et nous avons intérêt à le faire) simplifier le GV \(\Xlo[\lambda y \lambda x \,\prd{regarder}(x,y)(\cns{b})]\) en 
\(\Xlo \lambda x \,\prd{regarder}(x,\cns b)\). 
Ainsi P aurait directement reçu la traduction \(\Xlo[\lambda x \,\prd{regarder}(x,\cns{b})(\cns{a})]\), simplifié comme ci-dessus en 
\(\Xlo\prd{regarder}(\cns{a},\cns{b})\).

\fussy

\bigskip

\begin{exo}\label{exo:betared3}

Soit le prédicat \prd{présenter} à 3 arguments  (\(\Xlo\prd{présenter}(x,y,z)\) signifie «~$x$ présente $y$ à $z$~»).  Effectuez toutes les $\beta$-réductions dans les expressions suivantes :
\begin{enumerate}
\item \(\Xlo[[[\lambda z\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)
\item \(\Xlo[[\lambda z[\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)
\item \(\Xlo[\lambda z[[\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)
\item \(\Xlo[\lambda z[\lambda y[\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)
\end{enumerate}
\begin{solu} (p. \pageref{exo:betared3})

Les \breduc s (cf. définition \ref{d:breduc1}, p.~\pageref{d:breduc1}) sont présentées ci-dessous  sous forme d'égalités.
\begin{enumerate}
\item \(\Xlo[[[\lambda z\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)
\\
= \(\Xlo[[\lambda y\lambda x\,\prd{présenter}(x,y,\cns a)(\cns b)](\cns c)]\)
\hfill{\small (\breduc\ sur \vrb z)}
\\
= \(\Xlo[\lambda x\,\prd{présenter}(x,\cns b,\cns a)(\cns c)]\)
\hfill{\small (\breduc\ sur \vrb y)}
\\
= \(\Xlo\prd{présenter}(\cns c,\cns b,\cns a)\)
\hfill{\small (\breduc\ sur \vrb x)}


\item \(\Xlo[[\lambda z[\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)\\
= \(\Xlo[[\lambda z\lambda x\,\prd{présenter}(x,\cns a,z)(\cns b)](\cns c)]\)
\hfill{\small (\breduc\ sur \vrb y)}
\\
= \(\Xlo[\lambda x\,\prd{présenter}(x,\cns a,\cns b)(\cns c)]\)
\hfill{\small (\breduc\ sur \vrb z)}
\\
= \(\Xlo\prd{présenter}(\cns c,\cns a,\cns b)\)
\hfill{\small (\breduc\ sur \vrb x)}

Ici on aurait pu aussi commencer par la \breduc\ sur \vrb z.

\item \(\Xlo[\lambda z[[\lambda y\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)\\
= \(\Xlo[\lambda z[\lambda x\,\prd{présenter}(x,\cns a,z)(\cns b)](\cns c)]\)
\hfill{\small (\breduc\ sur \vrb y)}
\\
= \(\Xlo[\lambda z\,\prd{présenter}(\cns b,\cns a,z)(\cns c)]\)
\hfill{\small (\breduc\ sur \vrb x)}
\\
= \(\Xlo\prd{présenter}(\cns b,\cns a,\cns c)\)
\hfill{\small (\breduc\ sur \vrb z)}

Là aussi plusieurs ordres sont possibles pour effectuer les \breduc s, par exemple : sur \vrb y, puis \vrb z, puis \vrb x, ou sur \vrb z, puis \vrb y, puis \vrb x.

\item \(\Xlo[\lambda z[\lambda y[\lambda x\,\prd{présenter}(x,y,z)(\cns a)](\cns b)](\cns c)]\)\\
= \(\Xlo[\lambda z[\lambda y\,\prd{présenter}(\cns a,y,z)(\cns b)](\cns c)]\)
\hfill{\small (\breduc\ sur \vrb x)}
\\
= \(\Xlo[\lambda z\,\prd{présenter}(\cns a,\cns b,z)(\cns c)]\)
\hfill{\small (\breduc\ sur \vrb y)}
\\
= \(\Xlo\prd{présenter}(\cns a,\cns b,\cns c)\)
\hfill{\small (\breduc\ sur \vrb z)}

Ici on peut effectuer les trois \breduc s dans l'ordre qu'on veut.

\end{enumerate}
\end{solu}
\end{exo}

\medskip



La $\beta$-réduction repose sur
l'équivalence sémantique présentée dans la
proposition~\ref{prop:betaequiv} ci-dessous.  Il ne s'agit que d'une
proposition car nous allons voir qu'en fait, cette équivalence n'en est
pas exactement une, c'est-à-dire qu'il existe des cas exceptionnels
où elle n'est pas valide.  Mais contentons-nous de cette première
approximation pour le moment.


\begin{prop}\label{prop:betaequiv}
Quels que soient le modèle \Modele, le monde $w$ et l'assignation $g$ :
\\\(\denote{\Xlo[\lambda v \alpha(\gamma)]}^{\Modele,w,g} =
\denote{[\xlo{\gamma}/\vrb v]\xlo{\alpha}}^{\Modele,w,g}\).
\end{prop}



La «démonstration» de cette proposition peut se présenter ainsi :
$\denote{\Xlo\lambda v \alpha}^{\Modele,w,g}$ est la fonction qui à chaque
objet \Obj{x} du domaine associe
$\denote{\Xlo\alpha}^{\Modele,w,g_{[\Obj{x}/\vrb v]}}$.  Par conséquent, si
$\denote{\Xlo\gamma}^{\Modele,w,g} = \Obj{c}$, alors \(\denote{\Xlo[\lambda
    v\alpha(\gamma)]}^{\Modele,w,g} =
\denote{\Xlo\alpha}^{\Modele,w,g_{[\Obj{c}/\vrb v]}}\).  Ainsi toutes les
occurrences libres de $\vrb v$ dans $\Xlo\alpha$ seront interprétées
relativement à $g_{[\Obj{c}/\vrb v]}$.  Autrement dit, pour toute
occurrence libre de $\vrb v$ dans $\Xlo\alpha$ sa valeur sémantique est
$\denote{\vrb v}^{\Modele,w,g_{[\Obj{c}/\vrb v]}}$, c'est-à-dire
$g_{[\Obj{c}/\vrb v]}(\vrb v)$, c'est-à-dire \Obj{c}, c'est-à-dire
$\denote{\Xlo\gamma}^{\Modele,w,g}$.  Donc ce que cela montre c'est que 
$\Xlo[\lambda v \alpha(\gamma)]$ s'interprète comme $\Xlo\alpha$ lorsque ses
occurrences libres de $\vrb v$ ont la même dénotation que $\Xlo\gamma$ ; ce qui
revient à interpréter $\Xlo\alpha$ avec $\Xlo\gamma$ à la place des
occurrences libres de $\vrb v$ (\ie\ $[\xlo\gamma/\vrb v]\Xlo\alpha$).

\sloppy

Pourquoi  nous
limitons-nous aux occurrences \emph{libres} de $\vrb v$ ? Parce que si
$\Xlo\alpha$ contient des occurrences liées de $\vrb v$, c'est qu'elles sont
liées par soit $\Xlo\exists v$, soit $\Xlo\forall v$, soit $\Xlo\atoi v$, soit
$\Xlo\lambda v$.  Or les règles sémantiques correspondant à ces lieurs
font intervenir une variante de la fonction d'assignation courante en
changeant la valeur de $\vrb v$.  Par exemple, si $\Xlo\alpha$ contient
$\Xlo\exists v\phi$, alors $\Xlo\phi$ et les occurrences de $\vrb v$ qu'elle
contient seront interprétées par rapport à
$g_{[\Obj{c}/\vrb v]_{[\Obj{d}/\vrb v]}}$, où \Obj{d}  est un certain individu
du domaine.  Et $g_{[\Obj{c}/\vrb v]_{[\Obj{d}/\vrb v]}}(\vrb v) = \Obj{d}$.
Or le problème de la démonstration ci-dessus, c'est qu'en s'occupant seulement des variables libres (comme il se doit), elle oublie un cas de figure qui est précisément là où l'équivalence proposée ne tient plus (et où donc la \breduc\ n'est pas permise).

\fussy

%Convention sur le nom des variables.

Pour nous faire une idée de ces cas de figures, regardons l'exemple présenté dans l'exercice suivant. Prenez le temps d'y réfléchir, les réponses sont données immédiatement après.

\medskip

\begin{exo}[Convention sur les noms de variables]
Par rapport à un modèle $\Modele$, un monde $w$ et une assignation $g$
quelconques :
\begin{enumerate}
\item Que dénote
\(\Xlo\lambda x \exists y\, \prd{regarder}(x,y)\) ?
\item Que dénote \(\Xlo\lambda x \exists u\, \prd{regarder}(x,u)\) ?
\item Que dénote \(\Xlo[\lambda x \exists y\, \prd{regarder}(x,y)(z)]\) ?
\item Effectuez la $\beta$-réduction dans l'expression précédente.
\item Tout va bien ?
\item Que dénote \(\Xlo[\lambda x \exists y\, \prd{regarder}(x,y)(y)]\) ?
\item Effectuez la $\beta$-réduction dans l'expression précédente.
\item Tout va bien ?
\end{enumerate}
\end{exo}

\medskip

\begin{enumerate}
\item Que vaut \(\denote{\Xlo\lambda x \exists y \,
  \prd{regarder}(x,y)}^{\Modele,w,g}\) ?  Et bien, c'est la fonction
qui pour toute valeur de $x$ nous renvoie la dénotation de
\(\Xlo\exists y \, \prd{regarder}(x,y)\) par rapport à {\Modele} et
$w$.  Autrement dit, c'est la fonction qui retourne $1$ ssi (la
dénotation de) l'argument qu'on lui donne regarde quelqu'un (ou
quelque chose) dans $w$.  Et en termes ensemblistes, on dira
simplement qu'il s'agit de l'ensemble de tous les individus qui
regardent quelqu'un dans $w$.  
\item  \(\Xlo\lambda x \exists u\, \prd{regarder}(x,u)\) dénote exactement la même chose, car ici le nom de la variable liée par $\Xlo\exists$ (\vrb y ou \vrb u) n'a pas d'importance.
\item
Par conséquent \(\Xlo[\lambda x \exists
  y \, \prd{regarder}(x,y)(z)]\) est vrai par rapport à {\Modele}, $w$
et $g$ ssi la dénotation de $\vrb z$ (par rapport à $g$) est un
individu qui regarde quelqu'un.  
\item C'est bien confirmé par la
$\beta$-réduction qui donne \(\Xlo\exists y \, \prd{regarder}(z,y)\).
\item Donc oui, tout va bien : la \breduc\ nous donne le résultat attendu.
\item \sloppy Et évidemment ce que nous venons de voir vaut pour n'importe quel argument donné à \(\Xlo\lambda
x \exists y \, \prd{regarder}(x,y)\), et notamment pour $\vrb y$ :
\(\Xlo[\lambda x \exists y \, \prd{regarder}(x,y)(y)]\) est vrai par
rapport à {\Modele}, $w$ et $g$ ssi la dénotation de $\vrb y$ est un
individu qui regarde quelqu'un.  
\item \fussy Mais ici la $\beta$-réduction va nous
donner \(\Xlo\exists y \, \prd{regarder}(y,y)\), formule qui signifie
qu'il existe \emph{quelqu'un qui se regarde lui-même}.  
\item Ce n'est bien sûr pas
le sens de la formule originale de 6, donc, non, tout ne va pas bien : la \breduc\ a causé une erreur. 
\end{enumerate}

\sloppy

D'où vient cette erreur ? Que s'est-il passé entre les étapes 3 et 6 ? 
La cause du problème est la suivante : d'une part, l'argument donné au \lterme\ dans \(\Xlo[\lambda x \exists y \, \prd{regarder}(x,y)(y)]\) contient une variable libre --~en l'occurrence, il se réduit même entièrement à cette variable, $\vrb y$\footnote{En effet, dans \(\Xlo[\lambda x \exists y \, \prd{regarder}(x,y)(y)]\) le dernier \vrb y est libre, car, rappelons-le, la portée de $\Xlo\exists y$ est simplement \(\Xlo\prd{regarder}(x,y)\), conformément à la définition de la portée que nous avons vu au chapitre~\ref{LCP}.} ; et d'autre part, cette même variable, \vrb y, figure en tant que variable liée (par $\Xlo\exists y$) dans le \lterme. 
Donc si nous effectuons la \breduc, alors le \vrb y argument, qui est libre, va prendre la place de \vrb x, et se retrouver ainsi lié par $\Xlo\exists y$. 
Mais nous ne devons pas faire cela, car sinon ce \vrb y changera de rôle dans la formule, il n'aurait plus la même interprétation --~précisément parce que dans la portée $\Xlo\exists y$, \vrb y n'est pas interprété par la même assignation qu'à l'extérieur de sa portée.
Autrement dit, une variable qui est libre dans l'argument d'un \lterme\ doit toujours rester libre.  C'est une contrainte importante pour la \breduc, elle est explicitée dans le théorème suivant.

\fussy

%\([\lambda x\, \alpha(\gamma)]\)
\begin{theo}[Contrainte sur la $\beta$-réduction]
Soit \(\Xlo[\alpha(\gamma)]\) une application fonctionnelle. Une variable libre dans $\Xlo\gamma$ ne
doit pas se retrouver liée dans $\Xlo\alpha$ après $\beta$-réduction.
\end{theo}

\sloppy
Cette contrainte nous interdit donc de faire la \breduc\ de 7 dans l'exercice.  C'est embêtant, mais la situation n'est pas désespérée, car il y a un moyen très simple de contourner le problème.  
Puisque \emph{dans} le \lterme, \vrb y est liée, nous pouvons sans aucun risque remplacer, \emph{à cet endroit}, \vrb y par une autre variable : \(\Xlo\lambda x \exists y\, \prd{regarder}(x,y)\)  est complètement équivalent à \(\Xlo\lambda x \exists u\, \prd{regarder}(x,u)\). 
À ce moment-là, il n'y a plus de collision possible entre l'argument \vrb y libre et une variable liée dans le {\lterme} : \(\Xlo[\lambda x \exists u\, \prd{regarder}(x,u)(y)]\) peut se $\beta$-réduire en \(\Xlo\exists u\, \prd{regarder}(y,u)\), qui est bien le résultat correct, prévu dans l'exercice en 6.

\fussy


Nous devrons donc toujours prendre la précaution de renommer les variables liées (par
$\Xlo\exists$, $\Xlo\forall$, $\Xlo\atoi$ et $\Xlo\lambda$) dans
un $\lambda$-terme lorsque ces variables apparaissent ailleurs dans
l'expression de \LO\ que l'on construit.

\begin{conv}
Si la variable $\vrb v$ est libre dans $\Xlo\gamma$ et liée dans $\Xlo\alpha$, alors
on remplacera toujours $\Xlo[\alpha(\gamma)]$ par $\Xlo[\alpha'(\gamma)]$ où
$\Xlo\alpha'$ est l'expression $\Xlo\alpha$ dans laquelle on a renommé toutes
les occurrences liées de $\vrb v$ par une nouvelle variable.
\end{conv}




Nous verrons en \S\ref{ss:lambconv} qu'il y a d'autres cas de figure où  la $\beta$-réduction n'est pas permise, mais il ne s'agit en fait que de cas particuliers de ce que nous venons de voir.




\subsection{Une variété de variables} 
%------------------------------------
\label{ss:VarPrd}\is{variable}


Dans \LO\ beaucoup
d'expressions sont maintenant des $\lambda$-termes ; elles dénotent des
fonctions. 
Cela veut dire que le monde (\ie\ le modèle) est peuplé de
fonctions.  Lorsque nous définissons \(\Modele = \tuple{\Unv A, \Unv
  W,\Unv R, \FI}\), nous ne donnons pas explicitement d'ensembles de
fonctions, mais elles sont là :  du moment que nous
connaissons l'ensemble \Unv A et l'ensemble \set{0;1}, nous sommes capables de
concevoir et de retrouver toutes les fonctions possibles qui opèrent
sur ces ensembles. Par exemple, l'ensemble de toutes les fonctions de
\Unv A vers \set{0;1}, \ie\ \(\set{0;1}^{\Unv A}\), est complètement
défini par la donnée de \Unv A et \set{0;1}, il se déduit directement 
du modèle. Cet ensemble contient
toutes dénotations possibles de tous les prédicats unaires.
Bref dans le modèle nous trouvons des tas de
fonctions. 

Mais si nous avons des expressions de \LO\  (notamment les constantes de
prédicats) qui dénotent des
fonctions, alors, rien de nous empêche de nous donner dans \LO\ des
\emph{variables} qui dénotent  aussi des fonctions. \is{variable!\elid\ de prédicats}
Les variables sont
interprétées par les assignations $g$.  Jusqu'à présent une assignation  $g$ allait
chercher ses valeurs dans \Unv A.\is{valeur!\elid\ d'une variable} 
Mais si nous autorisons $g$ à
aller aussi chercher ses valeurs dans par exemple \(\set{0;1}^{\Unv A}\), alors $g$ interprétera des variables de prédicats
unaires.  De même pour des variables de prédicats binaires, en allant chercher des valeurs dans \mbox{\((\set{0;1}^{\Unv{A}})^{\Unv{A}}\)}, etc.

Par exemple, si nous posons que \vrb P et \vrb Q sont des variables de prédicats unaires, alors nous saurons que les assignations leur feront correspondre des fonctions comme ce qui est illustré en figure~\ref{F:g1} pour, mettons, $g_1$ (qui continue, comme d'habitude, à assigner aussi des valeurs aux variables d'individus).


\newcommand{\fxFP}%
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}%
\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt]{->}{a}{1}
\ncline[nodesep=3pt,offsetB=2pt]{->}{b}{0}
\ncline[nodesep=3pt]{->}{c}{0}
\ncline[nodesep=3pt,offsetB=-1pt]{->}{d}{1}%
}

\newcommand{\fxFQ}
{\left[
\begin{array}{l}
\begin{array}{@{}l}
\Obj{Alice}\rnode{a}{\stx}\\
\Obj{Bruno}\rnode{b}{\stx}\\
\Obj{Charles}\rnode{c}{\stx}\\
\Obj{Dina}\rnode{d}{\stx}\\
%\dots\\
\end{array}\rule{2.5cm}{0pt}
\begin{array}{l@{}}
\rnode{1}{1}\\[2ex]\rnode{0}{0}
\end{array}
\end{array}\right]
\ncline[nodesep=3pt,offsetB=2pt]{->}{a}{0}
\ncline[nodesep=3pt]{->}{b}{0}
\ncline[nodesep=3pt]{->}{c}{1}
\ncline[nodesep=3pt,offsetB=-2pt]{->}{d}{0}%
}


%\ex.
\begin{figure}[h!]
\begin{center}
\(g_1 = \small\left[%
\begin{array}{c@{\rule{1.5cm}{0pt}}l}
\vrb x\rnode{x}{\stx} & \rnode{v2}{\stx}{\Obj{Alice}}\\
\vrb y\rnode{y}{\stx} & \rnode{v1}{\stx}{\Obj{Bruno}}\\
\vrb z\rnode{z}{\stx} & \rnode{v3}{\stx}{\Obj{Dina}}\\
\vdots &\\
\vrb P\rnode{P}{\stx} &\rnode{v4}{\stx}\fxFP\\[6ex]
\vrb Q\rnode{Q}{\stx} &\rnode{v5}{\stx}\fxFQ\\
\vdots &
  \end{array}\right]
\ncline[nodesep=3pt]{->}{x}{v1}
\ncline[nodesep=3pt]{->}{y}{v2}
\ncline[nodesep=3pt]{->}{z}{v3}
\ncline[nodesep=3pt]{->}{P}{v4}
\ncline[nodesep=3pt]{->}{Q}{v5}
\)
\end{center}
\caption{Une assignation interprétant différentes sortes de variables}\label{F:g1}
\end{figure}

Ainsi $g_1(\vrb P)$ est bien un fonction, et la figure~\ref{F:g1} nous montre laquelle. Et comme $g_1(\vrb P)$ est une fonction de \Unv A dans \set{0;1}, nous pouvons lui donner un argument, par exemple \Obj{Alice}, ce qui s'écrit : \(g_1(\vrb P)(\Obj{Alice})\). D'après la figure, nous savons que \(g_1(\vrb P)(\Obj{Alice})=1\), alors que \(g_1(\vrb Q)(\Obj{Alice})=0\).
De même, si $f$ est une certaine fonction de $\set{0;1}^{\Unv A}$, la variante $g_{1[f/\vrb P]}$ est définie : c'est l'assignation identique à $g_1$ sauf que $g_1(\vrb P)= f$.

\sloppy

L'ajout de variables de prédicats dans {\LO} n'est pas spécialement propre au {\lcalcul} ; et d'ailleurs nous avions déjà commencé dans les chapitres précédents, avec ce que nous appelions alors des «pseudo-prédicats» \vrb C pour limiter les domaines des quantificateurs, qui sont réellement des variables de prédicats unaires. Il suffit d'adapter les assignations $g$ pour intégrer correctement ce type de variables dans le système\footnote{Et il aurait alors suffi de dire qu'à une variable
de prédicat unaire, $g$ assigne une valeur prise non pas dans \Unv A,
mais dans \(\powerset(\Unv A)\). Et pour un prédicat binaire, dans
\(\powerset(\Unv A\times \Unv A)\), etc.}.  
Et cela a une application immédiate, déjà prévue par {\LO} : nous pouvons quantifier sur des prédicats, en écrivant par exemple \(\Xlo\forall P[P(\cns a)\implq P(\cns b)]\) et \(\Xlo\exists P[P(\cns a)\wedge P(\cns b)]\).
La première formule dit que Bruno possède, dans le monde d'évaluation, toutes les propriétés qu'Alice possède (dans ce monde) ; et la seconde qu'Alice et Bruno ont au moins une propriété commune (dans le monde d'évaluation).  
Ce sont des formules respectivement très fortes et très faibles, mais elles peuvent s'avérer utiles dans certaines analyses sémantiques.

\fussy\largerpage

Cependant c'est avec le \lcalcul\ que l'ajout de ces variables va littéralement décupler la puissance expressive de {\LO}. Car par la \labstraction, nous allons maintenant pouvoir «percer des trous en forme de prédicats» dans les formules. 
En effet nous pouvons fabriquer le \lterme\ \(\Xlo\lambda P[P(\cns a)]\).
Informellement, c'est une formule à laquelle il manque un prédicat mais qui lui prévoit déjà un argument, \cns a (\ie\ une phrase avec son sujet mais sans son GV).
Sémantiquement, ce \lterme\ dénote une fonction qui attend en argument la dénotation d'un prédicat et renvoie $1$ ssi \Obj{Alice} satisfait ce prédicat. 
Comme la dénotation d'un prédicat est elle-même une fonction (de $\set{0;1}^{\Unv A}$ s'il est unaire), la dénotation de \(\Xlo\lambda P[P(\cns a)]\) est donc une fonction de fonctions (de $\set{0;1}^{(\set{0;1}^{\Unv A})}$). 
Cela ne doit pas nous effrayer, les fonctions sont des objets du modèle et peuvent très bien servir d'argument à d'autres fonctions un peu plus complexes. L'explicitation de la dénotation de \(\Xlo\lambda P[P(\cns a)]\) en \Next\ nous montre qu'il s'agit simplement d'une fonction qui fait le tri parmi les fonctions de $\set{0;1}^{\Unv A}$ entre celles qui donnent le résultat $1$ pour \Obj{Alice} et les autres. 


\ex.
\(\denote{\Xlo\lambda P[P(\cns a)]}^{\Modele,w,g}=
\begin{array}[t]{@{}c@{\:}l@{\ }l}
\set{0;1}^{\Unv{A}}&\longrightarrow &\set{0;1}\\
f&\longmapsto & 1 \text{ ssi } f(\Obj{Alice}) = 1
\end{array}\) \label{x:s:lP[P(a)]}


Les \lterme s qui abstraient des prédicats deviennent vite moins impressionnants lorsqu'on les manipule dans des expressions de {\LO}.  Si \(\Xlo\lambda P[P(\cns a)]\) attend un prédicat en argument, nous allons pouvoir lui en fournir par l'application fonctionnelle en écrivant par exemple : 
\(\Xlo[\lambda P[P(\cns a)](\prd{dormir})]\).  
Et cela se simplifie immédiatement par \breduc, en remplaçant \vrb P par \prd{dormir}, ce qui donne : \(\Xlo[\prd{dormir}(\cns a)]\). 
Mais comme nous prenons l'habitude d'écrire les prédicats sous forme de \lterme s, nous aurons plutôt tendance à produire l'application fonctionnelle {\Next} :

\ex.
\(\Xlo[\lambda P[P(\cns a)](\lambda x\,\prd{dormir}(x))]\)\footnote{Notons ici que j'ai omis les crochets dans l'argument, pour ne pas surcharger l'écriture. En toute rigueur, le \lterme\ argument devrait être $\Xlo\lambda x[\prd{dormir}(x)]$. Mais cette omission est autorisée, car sans conséquence. Les crochets de $\Xlo[P(\cns a)]$ sont, eux, plus importants.}

\sloppy
Là aussi nous pouvons opérer la \breduc, en remplaçant \vrb P par l'argument, \ie\ $\Xlo\lambda x\,\prd{dormir}(x)$, ce qui donne \Next[a]. 
Et à présent nous reconnaissons un nouveau schéma de \breduc, que nous savons déjà faire, et qui nous donne \Next[b].

\fussy

\ex.
\a. \(\Xlo[\lambda x\,\prd{dormir}(x)(\cns a)]\)
\b. \(\Xlo\prd{dormir}(\cns a)\)


Nous voyons donc qu'une expression comme \LLast\ (qui est une formule) déclenche une réaction en chaîne de \breduc s qui finissent par simplifier sa complexité initiale. 
C'est encore plus spectaculaire quand les expressions multiplient les \labstraction s et applications fonctionnelles, comme ce que présentent les exercices \ref{exo:betared1} et \ref{exo:betared} \alien{infra}.
Car évidemment nous pouvons aller plus loin dans la fabrication de \lterme s. 
Par exemple \(\Xlo\lambda P\lambda Q[[P(\cns a)]\wedge [Q(\cns a)]]\) dénote une fonction à deux arguments ; elle attend un premier prédicat (\vrb P), puis un second (\vrb Q) et nous livre la conjonction de leur application à \cns a. 
Nous pouvons aussi faire \(\Xlo\lambda P\lambda y\lambda x[[P(y)](x)]\)
--~ou \(\Xlo\lambda P\lambda y\lambda x[P(x,y)]\)~-- qui présente simplement une structure prédicative binaire en attente de son «matériel» sémantique, c'est-à-dire un prédicat et deux termes. 

Notons également que l'application fonctionnelle \Next[a] est tout à fait possible. \(\Xlo\lambda P[P(\cns a)]\) sert à fournir \cns a à un prédicat (\vrb P) qui sera donné en argument ; et comme argument nous donnons un prédicat binaire (et non unaire).  Par une première passe de \breduc, nous obtenons \Next[b] --~$\Xlo\lambda y\lambda x\,\prd{aimer}(x,y)$ remplace \vrb P~--, puis par une seconde passe, \Next[c] (\cns a remplace \vrb y). 

\ex.
\a.  \(\Xlo[\lambda P[P(\cns a)](\lambda y\lambda x\,\prd{aimer}(x,y))]\)
\b.  \(\Xlo[\lambda y\lambda x\,\prd{aimer}(x,y)(\cns a)]\)
\b.  \(\Xlo\lambda x\,\prd{aimer}(x,\cns a)\)


Mais cet exemple nous montre que nous nous approchons d'une pente particulièrement dangereuse.  Par le jeu des règles de \labstraction\ et d'application fonctionnelle telles qu'elles sont définies dans les pages qui précèdent, nous pouvons écrire une grande quantité d'expressions, dont celles de \Next.

\ex.
\a. \(\Xlo[\lambda P[P(\cns a)](\cns b)]\)
\b. \(\Xlo[\lambda x[\prd{dormir}(x)](\prd{regarder})]\)
\b. \(\Xlo[\lambda x[\prd{dormir}(x)](\lambda y\lambda z\,\prd{regarder}(z,y))]\)


\sloppy

Mais ces expressions ne sont absolument pas interprétables ! Par exemple, \Last[a] donne une constante d'individu \cns b pour jouer un rôle de prédicat dans le \lterme, et inversement \Last[b] fournit un prédicat comme argument à un autre prédicat. Si nous effectuions les \breduc s, nous obtiendrions des aberrations comme \(\Xlo[\cns b(\cns a)]\), \(\Xlo[\prd{dormir}(\prd{regarder})]\), \(\Xlo[\prd{dormir}(\lambda y\lambda z\,\prd{regarder}(z,y))]\) qui n'appartiennent pas à \LO.
Il est indispensable d'exclure ces écritures du langage ; autrement dit 
nous avons un besoin urgent de discipliner les règles de \lcalcul\ pour ne pas anéantir la cohérence de {\LO}. C'est ce que nous abordons dans la section suivante.

\fussy

\is{la (lambda)@$\lambda$ (lambda)|)}%
%\is{$\lambda$ (lambda)|)}%

\medskip

%.................

\input{exo/betared1}

%\smallskip

\input{exo/betared}


%\largerpage

\section{Langage objet typé}
%===========================
\label{LOT}\is{langage objet!\elid\ typé}

Dans cette section nous allons définir précisément la syntaxe et la sémantique de {\LO} dans sa nouvelle mouture, pour le rendre apte à accueillir proprement les apports du \lcalcul.
Comme nous venons de le voir, nous avons besoin avant tout de régler scrupuleusement la syntaxe du langage pour garantir qu'elle ne produit que des expressions interprétables.  Pour ce faire, nous allons utiliser un outil formel central : \emph{les types}.  Notre langage va, de la sorte, devenir \emph{typé}, d'où le nom de {\LO} typé.

\subsection{Les types}
%--------------------------------------
\is{type|sqq}

La résolution du «danger» qui est apparu en \S\ref{ss:VarPrd} peut se résumer par le principe suivant : certaines expressions de {\LO} dénotent des fonctions, mais ces fonctions ne prennent pas n'importe quoi comme argument.
Les fonctions ne doivent s'appliquer qu'à des objets dont la nature est conforme à ce qu'elles attendent de par leur définition.%
\footnote{Ce principe est déjà informellement en germe dans les travaux de Frege \citep[p. ex.][]{Frege:COfr} et il reprend l'idée par laquelle Russell fonde sa fameuse théorie des types \citep{Russell:03}. Ce qui est présenté ici s'inscrit dans la lignée de la formulation de \citet{Church:40} de la théorie.}
Pour mettre cette contrainte en \oe uvre, nous allons \emph{catégoriser} toutes les expressions de {\LO}, un peu comme la grammaire catégorise les expressions de la langue (avec N, V, Adj, Det, GN, GV, etc.). 
Mais ici, en sémantique, nous ne parlerons pas de catégories mais de \kwo{types}.  Un type est une étiquette assignée à toute expression de {\LO} et qui caractérise la nature de sa dénotation. On parle d'ailleurs parfois de \emph{types dénotationnels} ou \emph{types de dénotation}.

Ensuite, la démarche consistera à contrôler la bonne formation des expressions de {\LO} grâce aux types, car ceux-ci sont spécialement conçus pour indiquer les bonnes combinaisons sémantiques.


\subsubsection{Une infinité de catégories}
%'''''''''''''''''''''''''''''''''''''''''

Nous allons commencer par introduire deux types de base, élémentaires. 
Ils sont représentés par des symboles simples : \typ e et \typ t.

Les expressions qui dénotent un individu de \Unv A, ce que nous appelons des termes depuis le chapitre~\ref{LCP}, vont recevoir le type \typ e. \is{e (type)}\is{type!e}%
Ce nom, \typ e, vient de \emph{\uline{e}ntité}.  Ce sera donc le type des constantes et variables d'individus, mais aussi de \atoi-termes de la forme \(\Xlo\atoi x\phi\).

Les expressions qui dénotent une valeur de vérité, c'est-à-dire les formules, reçoivent le type \typ{t} ; \typ t comme \alien{\uline truth value}, \ie\ «valeur de vérité» en anglais. \is{t (type)}\is{type!t}% 
\emph{Formule} et \emph{expression de type  t} seront donc pour nous des synonymes.

Quant aux autres expressions de {\LO},  elles dénotent toutes des fonctions, et nous en rendons compte en leur assignant des types complexes, que nous appellerons aussi des types fonctionnels.\is{type!\elid\ fonctionnel}
Un type fonctionnel caractérise une catégorie de fonctions (curryfiées) en spécifiant tout simplement le type de son argument et le type de son résultat. 
Un type fonctionnel aura toujours la structure générale \mtype{a,b} où \mtyp a et \mtyp b représentent des types\footnote{Dans les notations utilisées ici, \mtyp a et \mtyp b ne seront jamais des types, mais des symboles qui représentent n'importe quel type. Précisons aussi que certains auteurs, probablement malhabiles au traitement de texte, notent les types avec des parenthèses au lieu de chevrons, c'est une variante possible.}.  
Le premier, \mtyp a, indique le type de l'argument de la fonction et le second, \mtyp b, le type du résultat que donne cette fonction. 

\begin{point}
\mtype{a,b}
est le type des expressions qui dénotent des
fonctions dont les arguments sont les dénotations d'expressions de
type $a$ et dont les valeurs sont les dénotations d'expressions de
type $b$.  
\end{point}



Ainsi un prédicat unaire comme \prd{dormir} dénote une fonction qui prend en argument un individu de \Unv A, ce qui correspond au type \typ e, et retourne comme résultat une valeur de vérité, qui correspond au type \typ t.  
Le type du prédicat est donc \et, type qui étiquette toutes les expressions qui dénotent une fonction de $\set{0;1}^{\Unv A}$.

Un prédicat binaire comme \prd{regarder}, nous l'avons vu, dénote une fonction qui prend en argument un individu (type \typ e) et retourne une fonction. 
Cette dernière est une fonction de $\set{0;1}^{\Unv A}$, ce qui correspond au type \et.  Par conséquent le type d'un prédicat binaire est \eet.
Et un prédicat à trois places sera de type \type{e,\eet}, etc.


Un type fonctionnel peut donc évidemment enchâsser d'autres types fonctionnels, comme le détermine la définition \ref{DefTypes1}. Cette définition est récursive : avec la règle 2,
on construit un nouveau type à partir de deux types déjà connus. 
Elle implique ainsi qu'à partir des deux types de base \typ e et \typ t, nous disposons d'une infinité de types pour étiqueter les expressions de {\LO}.


\begin{defi}[Types]\label{DefTypes1}
%''''''''''''''''''
\begin{enumerate}
\item $\mathrm{e}$ et $\mathrm{t}$ sont des types ;
\item si $a$ et $b$ sont des types, alors \mtype{a,b} est un type ;
\item rien d'autre n'est un type.
\end{enumerate}
\end{defi}


\sloppy

Ainsi nous savons que, par exemple, 
\type{e,t},
\type{t,t},
\type{\type{e,t},t},
\type{e,\type{e,t}},
\type{\type{e,t},\type{e,t}}, 
\type{\type{e,t},\type{\type{e,t},t}} sont des types.
Car ils sont tous de la forme \mtype{a,b}  où \mtyp a et \mtyp b sont à leurs tours des types. 
En revanche,
\type{e}, \type{t}, \type{\type{\type{e,t},e,t}} ne sont pas des
types, car nous ne pouvons pas les obtenir à partir de la
définition~\ref{DefTypes1}. 

\fussy

Un type fonctionnel est donc toujours globalement binaire, \ie\ un couple \mtype{a,b}, puisqu'il sert à décrire une classe de fonctions curryfiées. 
Rappelons qu'une fonction curryfiée attend \emph{un} argument (cf.\ \mtyp a) et retourne une valeur (cf.\ \mtyp b) qui peut à son tour être elle-même une fonction.  
Et nous avons vu en \S\ref{ss:VarPrd} que certaines fonctions peuvent aussi prendre d'autres fonctions en argument, ce qui fait que le premier composant d'un type fonctionnel (\mtyp a) peut lui-même être un type fonctionnel.  Ainsi, le type \ett\ correspond aux fonctions qui prennent en argument une fonction de $\set{0;1}^{\Unv A}$ (\ie\ la dénotation d'un prédicat unaire de type \et) et retournent une valeur de vérité.  C'est ce qui caractérise la dénotation d'un \lterme\ comme $\Xlo\lambda P[P(\cns a)]$ vue en \S\ref{ss:VarPrd} (cf.\ \ref{x:s:lP[P(a)]}).
De même \type{\et,\et} correspond aux fonctions qui prennent une dénotation de prédicat unaire comme argument et retournent une dénotation de prédicat unaire comme valeur.

En général, la manière la plus simple d'interpréter un type est donc
de raisonner en termes de fonctions, en s'aidant de  la formulation (rapide mais pratique) suivante :
\emph{\mtype{a,b} est le type des fonctions qui attendent $a$ pour donner
$b$}. 
Il suffit  de bien repérer quels sont les deux membres principaux
($a$ et $b$) qui
forment le couple, sans se perdre dans la cascade de chevrons quand le
type devient très complexe.  Ainsi \type{\et,\ett}, à décoder comme \Next, 
est le type
des expressions fonctionnelles qui attendent un prédicat unaire pour donner... une
expression de type {\type{\type{e,t},t}}%
\footnote{Signalons une coutume qui simplifie parfois les notations des types en faisant l'économie de certains chevrons (ou parenthèses) et de virgules lorsque leur omission ne crée pas d'ambiguïté et facilite la lecture du type. Ainsi on pourra trouver, dans la littérature, le type \eet\ simplifié en $\typ e\type{et}$; \type{\et,\et} en $\type{et}\type{et}$; \type{\et,\ett} en $\type{{et},\type{et}t}$, etc.}. 

\ex. 
\type{\underbrace{\et},\underbrace{\ett}}


Nous pouvons également nous aider dans le décryptage d'un type en exploitant l'équivalence de fond entre la fonction caractéristique d'un ensemble et cet ensemble. 
Les types de la forme \mtype{a,\mathrm{t}} étiquettent des fonctions qui
renvoient $0$ ou $1$, donc des fonctions caractéristiques d'ensembles
composés d'objets correspondant au type $a$.  
C'est
bien ce qui se passe avec le type \et, étiquette des prédicats unaires dont les dénotations sont assimilables à des ensembles d'individus de \Unv A.  
De même, le type 
\ett\ est l'étiquette des expressions qui dénotent un ensemble d'objets correspondant au type {\et},  autrement dit à une ensemble d'objets qui correspondent à des ensembles d'individus; soit un ensemble d'ensembles d'individus.

\sloppy

Il est également utile de savoir décoder rapidement les types de la forme \mtype{a,\mtype{b,\typ t}}.  Ces types peuvent être vus comme les étiquettes des expressions qui dénotent une \emph{relation binaire} entre un objet de type \mtyp a et un objet de type \mtyp b. 
En effet, nous avons vu que \eet\ est le type des prédicats binaires, qui dénotent bien des relations entre individus. 
Et donc \type{\et,\ett} peut être vu comme correspondant à des relations entre deux ensembles d'individus. 

\fussy

Profitons-en enfin pour introduire un raccourci de notation que nous utiliserons parfois pour abréger nos écritures et aussi, surtout, pour formuler des généralisations sur certains types.  Soit \mtyp a et \mtyp b deux types ; nous pourrons nous autoriser à abréger le type \mtype{a,\mtype{a,b}} en \mtype{a^2,b}, le type \mtype{a,\mtype{a,\mtype{a,b}}} en \mtype{a^3,b}, etc. et de manière générale, le type \mtype{a,\mtype{a,\mtype{\dotsc\mtype{a,b}\dotsc}}} où \mtyp a est répété $n$ fois s'abrégera en \mtype{a^n,b}.  Ainsi nous pourrons dire que le type de ce que nous avons appelé jusqu'ici un prédicat $n$-aire est \type{e^{\mathit n},t}.

%\medskip




\subsubsection{Rencontre du troisième type}
%---------------------------------------
\label{ss:3etype}

%% Le lecteur indulgent me pardonnera, j'espère, la facétie innocente de ce titre
%% de sous-section ; d'autant plus <<~innocente~>> qu'il est en fait
%% inapproprié de parler d'un troisième type.  

Nous allons voir qu'un point crucial de {\LO} typé est que toute expression du langage devra être étiquetée par un et un seul type.
Mais nous devons alors
remarquer une insuffisance : il existe des
expressions de {\LO} qui dénotent bien des fonctions mais qu'il n'est
pas possible de typer avec les système présenté ci-dessus.  Il s'agit
des expressions intensionnelles (\S\ref{sss:^v}), de la forme $\Xlo\Intn\alpha$, qui, rappelons-le,
dénotent des fonctions associant, à tout monde possible de \Unv W, la
dénotation de $\Xlo\alpha$ dans ce monde.  Or nous n'avons pas les moyens
(pour l'instant) de définir des types pour les fonctions qui prennent des
mondes possibles en arguments.  Par conséquent, il nous  faut augmenter
encore notre ensemble de types (bien qu'il soit déjà infini !...).



À cet égard, en vérité, il est ici un peu inexact de parler d'un troisième type.
Ce que nous devons
introduire ici, c'est un élément de notation qui permette de
représenter les %types des expressions intensionnelles de {\LO}.
%($\Intn\alpha$).  
%Ces expressions dénotent des fonctions de $\Unv{W}$ ;
%il nous faut donc pouvoir faire référence aux 
mondes de $\Unv{W}$ dans l'écriture
des types, et nous utiliserons pour cela le symbole $\typ{s}$.  Ainsi, si
$a$ est le type de $\vrb\alpha$, alors $\Xlo\Intn\alpha$ est de type
\mtype{\mathrm{s},a}, qui étiquette les fonctions de $\Unv{W}$ vers l'ensemble
des dénotations des expressions de type $a$.  Par exemple pour une
formule $\vrb\phi$ (de type $\mathrm{t}$),  $\Xlo\Intn\phi$ est de type \type{s,t}, ce
qui correspond bien aux fonctions de $\Unv{W}$ vers \set{0;1}, %ou si
%l'on préfère, à des ensembles de mondes possibles, 
\ie\ des
propositions. 

%>>>>>>>>


Nous redonnons ici la définition des types (définition complète cette
fois-ci) en définissant par induction l'ensemble {\Types} de tous les types
possibles.\is{T@\Types}


\begin{defi}[\Types]
{\Types} est le plus petit ensemble\footnotemark\ tel que :
\begin{enumerate}
\item \(\mathrm{e} \in \Types\) et \(\mathrm{t} \in \Types\) ;
\item si \(a \in \Types\) et \(b \in \Types\), alors \(\mtype{a,b} \in
\Types\) et \(\mtype{\mathrm{s},a}\in\Types\).
\end{enumerate}
\end{defi}%
\footnotetext{On le définit comme le
  plus petit ensemble, afin d'être sûr qu'on y trouvera rien d'autre
  que ce que spécifient les conditions qui suivent.}

Nous remarquons donc qu'en vertu de cette définition, $\mathrm{s}$ n'est pas un type
(ce serait, tout au plus, ce que l'on pourrait appeler un
«proto-type», si le terme ne prêtait pas à confusion) ; $\mathrm{s}$ n'est
en fait qu'un symbole qui permet de construire des types complexes.
Dans {\Types}, nous ne rencontrerons jamais de type de la forme
\mtype{a,\mathrm{s}} : $\mathrm{s}$ doit se trouver immédiatement à droite d'un chevron
ouvrant, comme le stipule la règle 2 de la définition.
Par exemple, \type{s,e}, \type{s,\type{s,t}}, \type{t,\type{s,t}} et
\type{\type{s,\type{\type{s,\type{e,t}},t}},\type{e,t}}, sont
des types ; \type{s,s} et \type{e,s} n'en sont pas.

\subsection{Syntaxe de {LO} typé}
%---------------------------------
\subsubsection{Syntaxe réglée par les types}
%'''''''''''''''''''''''''''''''''''''''''''

À l'aide de cet ensemble de types, nous allons pouvoir définir la
syntaxe de {\LO} typé.  La syntaxe fournit les règles de bonne
formation de toutes expressions interprétables de {\LO}.  L'intérêt du
langage typé est que les règles syntaxiques ne vont plus se contenter
de dire si telle ou telle expression est une expression bien formée de
{\LO}, elles vont aussi nous indiquer quel est le type de chaque
expression formée.  Introduisons tout de suite à cet effet un élément
de notation, $\ME$\footnote{Je reprends ici le symbole $\ME$ de \citet{PTQ} qui est l'abréviation de \alien{\uline{m}eaningful \uline{e}xpressions}, c'est-à-dire «expressions interprétables».\is{expression!\elid\ interprétable}}.

\begin{nota}
L'ensemble de toutes les expressions de type $a$ de {\LO} est noté
$\ME_a$.\\
Et on notera $\ME$ l'ensemble de toutes les expressions bien formées
de {\LO} (donc $\ME$ est l'union de tous les $\ME_a$ : $\ME = \bigcup_{a\in\Types} \ME_a$).
\end{nota}\is{ME@$\ME$}

Ainsi, $\vrb\alpha \in \ME_a$ est une manière rapide d'écrire que «~\vrb\alpha\ est de type \mtyp{a}~»  ; et
$\vrb\alpha \in \ME$ signifie simplement que $\vrb\alpha$ est une expression
bien formée de {\LO}.  Cette notation implique qu'avoir un type (dans \Types) signifie la même chose qu'être une expression bien formée de \LO.
Autrement dit, toute expression bien formée du langage doit avoir un (et un seul) type.

Et comme un type est une catégorie d'expressions de {\LO}, nous pouvons prévoir, au vu de \Types, que nous allons avoir dans le langage des expressions fonctionnelles de types extrêmement variés.
En \S\ref{ss:VarPrd}, nous avons introduit des variables de prédicats, c'est-à-dire des variables qui dénotent des fonctions.  
Dès lors que ce pas est franchi, il n'y a aucune raison de ne pas continuer : 
dans le vocabulaire de {\LO} nous allons nous donner, au moins potentiellement, des variables de n'importe quel type de {\Types} ; nous n'aurons pas de problème pour les interpréter, la plupart dénoteront des fonctions, conformément à ce qu'indique leur type.  
De même nous allons considérer que le vocabulaire possède une collection de constantes pour (potentiellement) n'importe quel type. 
Formellement, cela veut dire que nous avons, pour tout type \mtyp a de \Types,  les ensembles $\CON_a$ et $\VAR_a$, respectivement l'ensemble des constantes de type \mtyp a et l'ensemble des variables de type \mtyp a.
Et comme d'habitude, \CON\ et \VAR\ sont les réunions respectivement de tous les $\CON_a$ et de tous les $\VAR_a$.


%\[\bigcup_{a \in \Types} \ME_a = {\text{\LO}}\]

\begin{defi}[Vocabulaire]
Le vocabulaire de {\LO} comporte :
\begin{itemize}\raggedright
\item un ensemble de variables $\VAR_a$ et un ensemble de constantes
$\CON_a$ pour chaque type $a$ de {\Types} ;
\item un ensemble de symboles logiques :\\ 
\set{\xlo\neg ; \xlo\wedge ; \xlo\vee$,
$\xlo\implq ; \xlo\ssi ; \xlo= ; \xlo\forall ; \xlo\exists ; \xlo\atoi ; 
%\xlo\doit ; \xlo\peut ; 
\xlo{\doitn n} ; \xlo{\peutn{n}} ;
\xlo\lambda ; \xlo\textIntn ; \xlo\textExtn}, où $n$ peut représenter divers entiers de $\mathbb N$ dans $\xlo{\doitn n}$ et \xlo{\peutn{n}} (cf.\ \S\ref{ss:LOInt}) ;
\item les crochets $\Xlo[\,]$ et les parenthèses $\Xlo(\,)$.
\end{itemize}
\end{defi}

\sloppy

En pratique, évidemment, nous n'aurons pas besoin de variables et de constantes pour \emph{tous} les types de {\Types}, ce qui fait que pour certains types \mtyp a, $\VAR_a$ ou $\CON_a$ pourront être vides.
Il serait particulièrement utile de disposer d'un moyen de reconnaître facilement le type des variables que nous utiliserons.  Une pratique consiste à indicer les variables par leur type (en écrivant, par exemple, \vrbi{x}{\typ e}, \vrbi{P}{\et}, \vrbi{R}{\eet}...). 
Mais cela a tendance à allonger épouvantablement les écritures, et nous choisirons ici plutôt d'indiquer le type des variables à l'extérieur des expressions de {\LO},   en essayant de maintenir des conventions de notation suffisamment intuitives.

\fussy

Les variables et les constantes de type \typ e seront notées comme d'habitude (\vrb x, \vrb y, \vrb z, \vrb u, \vrb v, \vrbi x1, \vrbi x2... et 
$\cns{a}$, $\cns{b}$, $\cns{c}$,..., $\cnsi{a}{1}$, $\cnsi{a}{2}$,...). Les variables de types plus complexes seront notées par des majuscules (\vrb P, \vrb Q, \vrb R, \vrb N, \vrb X, \vrb Y...), avec quelques petites spécificités typographiques le cas échéant. 
Les constantes de prédicats, quel que soit leur type, seront toujours notées en gras
(\prd{homme}, \prd{dormir}, \prd{aimer},
\prd{donner}...) en utilisant parfois des majuscules.  Les variables de $\VAR_{\typ{t}}$ seront notées $\vrb\phi$,
$\vrb\psi$, $\vrb\chi$..., et celles de $\VAR_{\type{s,t}}$ $\vrb p$, $\vrb q$, $\vrb r$... 
%et nous considérerons que {\LO} ne comporte pas de constantes de type $\mathrm{t}$.  

La syntaxe de {\LO} typé peut maintenant être définie comme suit :

\begin{defi}[Syntaxe de \LO\ typé] \label{RSyn:ltype}
%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\begin{enumerate}[syn,series=RglSynT,itemsep=.4ex] %[(\RSyn1)]
\item si $\vrb\alpha \in \VAR_a$ ou $\vrb\alpha \in \CON_a$, alors $\vrb\alpha \in \ME_a$ ;
\label{SynTBase}
\item si $\vrb\alpha \in \ME_{\mtype{b,a}}$ et $\vrb\beta \in \ME_b$, alors
$\xlo{[\alpha(\beta)]} \in \ME_a$ ;
\label{SynTApp}
\item si $\vrb\alpha$ et $\vrb\beta \in \ME_a$, alors $\xlo{[\alpha=\beta]} \in \ME_{\mathrm{t}}$ ;
\label{SynT=}
\item si \(\vrb\phi, \vrb\psi  \in \ME_{\mathrm{t}}\), alors :
  \begin{enumerate}
     \item \(\xlo{\neg\phi} \in \ME_{\mathrm{t}}\),
     \item \(\xlo{[\phi \wedge \psi]}, \xlo{[\phi \vee \psi]}, 
       \xlo{[\phi \implq\psi]}\) et \(\xlo{[\phi \ssi \psi]} \in \ME_{\mathrm{t}}\) ;
  \end{enumerate}
\label{SynTConn}
\item si $\vrb\phi \in \ME_{\mathrm{t}}$, alors \(\xlo{\doitn n\phi}\) et \(\xlo{\peutn{n}\phi} \in \ME_{\mathrm{t}}\) ; 
%%idem pour tous les autres opérateurs modaux (\peut,\mP,\mF,\mG,\mH\dots) ; de manière générale : si $\phi \in \ME_{\mathrm{t}}$ et si $*$ est un opérateur modal de {\LO}, alors $*\phi \in \ME_{\mathrm{t}}$ ;
\label{SynTMod}
\item si $\vrb\phi \in \ME_{\mathrm{t}}$ et $\vrb v \in \VAR_a$, alors $\Xlo\forall v \phi$ et
     $\xlo{\exists v \phi} \in \ME_{\mathrm{t}}$, et $\xlo{\atoi v \phi} \in \ME_a$ ;
\label{SynTQ}
\item si $\vrb\alpha \in \ME_a$ et $\vrb v \in \VAR_b$, alors $\xlo{\lambda v
     \alpha} \in \ME_{\mtype{b,a}}$ ;
\label{SynTlamb}
\item si $\vrb\alpha \in \ME_a$, alors $\xlo{\Intn\alpha} \in \ME_{\mtype{\mathrm{s},a}}$ ;
\label{SynTInt}
\item si $\vrb\alpha \in \ME_{\mtype{\mathrm{s},a}}$, alors $\xlo{\Extn\alpha} \in \ME_a$
\label{SynTExt}
\end{enumerate}
\end{defi}

La règle (\RSyn\ref{SynTBase}) nous donne les expressions de base de {\LO},
c'est-à-dire celles qui, d'office, figurent dans \ME.  Ce sont les
variables et les constantes, et elles peuvent être de n'importe quel
type.

%\subparagraph%
{La règle~(\RSyn\ref{SynTApp})}\is{application fonctionnelle}
introduit l'application fonctionnelle, mais de façon plus disciplinée que ce que nous avons précédemment : une expression fonctionnelle (\vrb\alpha) de type \mtype{b,a} n'acceptera  que des arguments (\vrb\beta) dont le type lui convient, \ie\ \mtyp b.
C'est cette règle qui résout le problème vu en \S\ref{ss:VarPrd} ; nous ne risquerons plus de donner n'importe quoi comme argument à une fonction, nous sommes sauvés. 
Remarquons aussi qu'avec (\RSyn\ref{SynTApp}), nous obtenons toujours un type
plus simple que celui de $\Xlo\alpha$ :  nous  passons de \mtype{b,a} à
$a$. 


La règle~(\RSyn\ref{SynT=}) permet de formuler des identités de
dénotation entre deux expressions.\is{identite@identité}  %\is{$=$}%
Dans le chapitre~\ref{LCP}, cette
règle était présentée comme une variante de la précédente en
considérant que $\Xlo=$ pouvait être vu comme un prédicat binaire. Il y a
à présent une différence importante : dans le chapitre~\ref{LCP}, les
membres de l'égalité devaient être des termes (variables ou
constantes), c'est-à-dire ce que nous nommons maintenant des
expressions de type \typ{e} ; or ici la règle~(\RSyn\ref{SynT=}) peut
mettre en relation deux expressions de n'importe quel type, du moment
qu'il s'agit du même type pour les deux.  Cela rend le langage
beaucoup plus puissant et expressif. 
Notons aussi que nous ne pouvons plus \label{=categ}
aussi facilement considérer (\RSyn\ref{SynT=}) comme une simple variante
de (\RSyn\ref{SynTApp}) : si $\Xlo=$ devait correspondre à un prédicat
binaire ordinaire, il devrait avoir un type.  Mais quel serait ce type
?  Certes il serait de la \emph{forme} \mtype{a,\mtype{a,\typ{t}}},
mais cela n'est pas un type précis (cette notation n'est
qu'un \emph{format} de type).  En fait il faudrait envisager autant de
types différents pour le «prédicat» $\Xlo=$ qu'il y a de types dans
{\Types} ; par exemple \type{e,\type{e,t}}  pour l'identité
d'individus, \type{\type{e,t},\type{\type{e,t},t}} pour l'identité de
prédicats unaires, etc.


Les règles~(\RSyn\ref{SynTConn}) introduisent les connecteurs (ou constantes)
logiques.  Elles sont tout à fait similaires à celles vues dans le
définition~\ref{SynP} du chapitre~\ref{LCP}, p.~\pageref{SynP}, (il y
avait alors deux groupes de règles qui s'appelaient (\RSyn\ref{SynPNeg}) et
(\RSyn\ref{SynPConn})). Les connecteurs logiques sont vérifonctionnels,
c'est-à-dire qu'ils ne s'appliquent que sur des formules et produisent
à leurs tours des formules (plus complexes).  C'est bien ce que
spécifient les règles : elles ne concernent que les expressions de $\ME_{\mathrm{t}}$.


Les règles~(\RSyn\ref{SynTMod})  introduisent les opérateurs modaux, et là
encore les règles s'appliquent à des formules (donc de $\ME_{\mathrm{t}}$)
pour produire des formules.  


Les règles~(\RSyn\ref{SynTQ}) introduisent les quantifications et la
description définie.  Il est important de remarquer  que ces règles
sont un peu plus générales que celles vues au chapitre~\ref{LCP} : en
effet ici nous nous autorisons à quantifier sur des variables de n'importe
quel type (noté $\mtyp a$ dans la règle), alors que jusqu'à présent les
quantifications ne s'effectuaient que sur des variables de type
\typ{e} (nous n'en avions pas d'autres).  
De même,  \xlo{\atoi} peut lier une variable de n'importe quel type et --~c'est important de le noter~-- le \atoi-terme construit a le même type que cette variable.\is{i@\atoi\ (iota)}
%Cela rend notre langage
%objet beaucoup plus expressif.  Nous pouvons par exemple écrire
%$\Xlo\exists P [P(\cns a)]$, signifiant littéralement : il y a un prédicat,
%$\vrb P$, que \cns{a} vérifie.

La règle~(\RSyn\ref{SynTlamb}) présente la $\lambda$-abstraction ;
c'est la règle qui construit les expressions fonctionnelles et, partant, qui
complexifie les types des expressions.  On fabrique une fonction à
partir d'une expression $\vrb{\alpha}$, de type $a$, en «l'amputant»
d'une variable $\vrb v$ de type $b$.  Le résultat est donc bien une
expression qui attend un argument de type $b$ pour redonner alors une
expression %compléter 
du type de $\vrb{\alpha}$ ; le type de l'expression
fonctionnelle $\Xlo\lambda v \alpha$ est donc \mtype{b,a}.

Les règles~(\RSyn\ref{SynTInt}) et (\RSyn\ref{SynTExt}) introduisent
respectivement les opérateurs $\Xlo\textIntn$ et $\Xlo\textExtn$ vus en \S\ref{s:intension}. (\RSyn\ref{SynTInt})
complexifie aussi le type d'une expression et c'est ici la seule règle
insère \typ s dans nos types.  Rappelons que $\Xlo\Intn\alpha$
dénote %le sens (l'intension) 
l'intension
de $\Xlo\alpha$.  Sa dénotation est bien une
fonction, comme l'indique le type \mtype{\mathrm s,a} (tel que nous
l'avons défini en \S\ref{ss:3etype} \alien{supra}).  L'opérateur
$\Xlo\textExtn$ est l'inverse de $\Xlo\textIntn$ : en quelque sorte il ramène la
dénotation d'une expression déjà intensionnelle à son extension dans
le monde où on l'interprète.  
Au chapitre~\ref{Ch:t+m},  $\Xlo\textExtn$ ne pouvait apparaître que devant $\Xlo\textIntn$ ; mais maintenant il a un peu plus de liberté. 
(\RSyn\ref{SynTExt}) dit que 
%Il y a donc une précondition sur l'application de 
$\Xlo\textExtn$ ne peut préfixer qu'une expression intensionnelle, c'est-à-dire de type \mtype{\mathrm s,a}.
Mais à présent, rien ne nous empêchera d'envisager dans {\LO} des
constantes et des variables qui sont directement et par elles-mêmes d'un type
\mtype{\mathrm s,a}.  Par exemple, si \vrb p est de type \type{s,t}, alors $\Xlo\Extn p$ est bien formée et de type \typ t.




\subsubsection{Exemples}
%'''''''''''''''''''''''

Pour illustrer de manière plus appliquée le fonctionnement de ces
règles, regardons pas à pas comment se calcule le type d'une
expression bien formée de \LO.    Le moyen le  plus simple et le plus
sûr d'y parvenir consiste tout bonnement à reconstruire par devers soi
l'expression dont on cherche le type en appliquant correctement les
règles syntaxiques nécessaires.  Si une expression est bien formée, il
n'y a qu'une seule dérivation qui mène à sa construction, et son type
s'obtient donc automatiquement à partir de la connaissance du type de
ses composants de base.  Dans les exemples qui suivent, nous
utiliserons des variables et des constantes ainsi typées : 
$\vrb x, \vrb y \in \VAR_{\typ e}$, $\vrb P \in \VAR_{\type{e,t}}$, $\cns a \in
\CON_{\typ e}$, $\prd{dormir} \in \CON_{\type{e,t}}$, $\prd{regarder}\in \CON_{\eet}$.  

Commençons avec un cas très simple :

\ex.
\(\Xlo\lambda x[\prd{dormir}(x)]\) \label{x:exTyp1}
\\
%
La constante de prédicat \prd{dormir} est de type \type{e,t} et $\vrb x$ de type \typ e, ce qui
permet d'appliquer la règle (\RSyn\ref{SynTApp}) de l'application
fonctionnelle pour produire \(\Xlo[\prd{dormir}(x)]\) qui est donc de type
\typ t.
Ensuite la règle (\RSyn\ref{SynTlamb}) de
$\lambda$-abstraction est appliquée pour ajouter $\Xlo\lambda x$. Et la règle nous dit que l'expression est de type \et, puisque \typ e est le type de \vrb x.
Ce calcul du type de {\Last} peut se résumer graphiquement comme suit :
\\[.5ex]
\(\utyp{\xlo\lambda \vrb x\utyp{\xlo[\utyp{\prd{dormir}}{\et}\xlo(\utyp{\vrb x}{\typ e}\Xlo)]}{\typ t}}{\et}\)


Par la suite, avec ce genre de \lterme, nous prendrons l'habitude de souvent user de la règle de suppression des crochets, pour écrire \(\Xlo\lambda x\,\prd{dormir}(x)\).  De même, nous reconnaîtrons rapidement que \(\Xlo\lambda y\lambda x\,\prd{regarder}(x,y)\) est de type {\eet} ; informellement c'est parce que nous y voyons un prédicat binaire, \prd{regarder}, qui possède ses arguments, \vrb x et \vrb y, et ceux-ci sont $\lambda$-abstraits par (\RSyn\ref{SynTlamb}).  Formellement il s'agit de la simplification de 
\(\Xlo\lambda y\lambda x [[\prd{regarder}(y)](x)]\)
dont le typage est détaillé en {\Next} :

\ex.
\(\utyp{\xlo\lambda\vrb y\utyp{\xlo\lambda\vrb x \utyp{\xlo[\utyp{\xlo[\utyp{\prd{regarder}}{\eet}\xlo(\utyp{\vrb y}{\typ e}\xlo{)]}}{\et}\xlo(\utyp{\vrb x}{\typ e}\Xlo)]}{\typ t}}{\et}}{\eet}\)

\ex. \(\Xlo\lambda P\lambda x [\prd{dormir}(x) \wedge P(\cns a)]\) \label{ex:typ1}
\\
Nous savons déjà que $\Xlo\prd{dormir}(x)$ est de type \typ t. \vrb P est de type \et\ et \cns a de type \typ e, donc pour les mêmes raisons (\ie\ (\RSyn\ref{SynTApp})), $\Xlo[P(\cns a)]$ --~simplifié en $\Xlo P(\cns a)$~-- est de type \typ t.
Cela nous permet d'appliquer la règle (\RSyn\ref{SynTConn}.b) pour produire $\Xlo[\prd{dormir}(x) \wedge P(\cns a)]$ de type \typ t.
Ensuite comme en \ref{x:exTyp1}, nous trouvons que $\Xlo\lambda x [\prd{dormir}(x) \wedge P(\cns a)]$ est de type \et\ (\RSyn\ref{SynTlamb}). 
Et en appliquant encore une fois la règle de \labstraction\ (\RSyn\ref{SynTlamb}), \vrb P étant de type \et, nous obtenons le type \type{\et,\et} pour 
\(\Xlo\lambda P\lambda x [\prd{dormir}(x) \wedge P(\cns a)]\).
\\[.5ex]
%\ex. 
\(\underbrace{\xlo\lambda\underbrace{\vrb P}_{\et}\underbrace{\xlo\lambda\underbrace{\vrb x}_{\typ e} \underbrace{\xlo[\utyp{\xlo{\prd{dormir}(x)}}{\typ t} \wedge \utyp{\xlo{P(\cns a)}}{\typ t}\xlo]}_{\typ t}}_{\type{e,t}}}_{\type{\type{e,t},\type{e,t}}}\)

%--


\ex. \(\Xlo\lambda x\lambda P [\prd{dormir}(x) \wedge P(\cns a)]\)
%--
\\
% 
\sloppy 
Ici les mêmes règles syntaxiques que précédemment sont appliquées, mais
les deux $\lambda$-abstractions n'interviennent pas dans le même
ordre.  Donc nous trouverons d'abord {\ett} pour \(\Xlo\lambda P
[\prd{dormir}(x) \wedge P(\cns a)]\) puis \type{e,\ett}
pour \(\Xlo\lambda x\lambda P [\prd{dormir}(x) \wedge P(\cns a)]\) : 
\\[.5ex]
%\ex.
\(\underbrace{{\Xlo\lambda x}\underbrace{{\Xlo\lambda P} \underbrace{\Xlo[\prd{dormir}(x) \wedge P(\cns a)]}_{\typ t}}_{\type{\type{e,t},t}}}_{\type{e,\type{\type{e,t},t}}}\)

\fussy

\ex. \(\Xlo\atoi P [P(\cns a)]\)
%--
\\
%
Il ne s'agit pas à proprement parler d'un \lterme, mais c'est une expression que la nouvelle expressivité de {\LO} nous permet de former. 
Elle utilise (\RSyn\ref{SynTQ}) ; nous avons le droit de  l'appliquer car $\Xlo[P(\cns a)]$ est bien de type \typ t. Et cette règle dit qu'un \atoi-terme a le même type que la variable liée par $\Xlo\atoi$ :
\\[.5ex]
%
\(\utyp{\xlo\atoi \utyp{\vrb P}{\et} \utyp{\xlo{[P(\cns a)]}}{\typ t}}{\et}\)


Corsons maintenant l'exercice en ajoutant de l'intensionnalité avec $\Xlo\textIntn$.

\ex. \(\Xlo\lambda P\lambda x \Intn[\prd{dormir}(x) \wedge P(\cns a)]\)
%--
\\
Après avoir formé \(\Xlo[\prd{dormir}(x) \wedge P(\cns a)]\) de type \typ
t, on applique la règle (\RSyn\ref{SynTInt}) pour ajouter l'opérateur
{\Xlo\textIntn}.   (\RSyn\ref{SynTInt}) est simple : elle nous dit que juste
qu'il faut ajouter \typ s au début du nouveau type obtenu ; donc  \(\Xlo\Intn[\prd{dormir}(x)
  \wedge P(\cns a)]\) est de type \type{s,t}.    Ensuite on applique
deux fois  (\RSyn\ref{SynTlamb}) comme en \ref{ex:typ1} ce qui va donner
successivement les types \type{e,\type{s,t}} et
\type{\type{e,t},\type{e,\type{s,t}}} : 
\\[.5ex]
%\ex.
\(\underbrace{{\Xlo\lambda P}\underbrace{{\Xlo\lambda x}
    \underbrace{\xlo{\Intn}\underbrace{\Xlo[\prd{dormir}(x) \wedge P(\cns a)]}_{\typ
      t}}_{\type{s,t}}}_{\type{e,\type{s,t}}}}_{\type{\type{e,t},\type{e,\type{s,t}}}}\)



\ex. \(\Xlo\lambda P \Intn\lambda x [\prd{dormir}(x) \wedge P(\cns a)]\)
%--
\\\sloppy
Ici {\Xlo\Intn} ne se place plus devant une formule mais devant le \lterme\
(de type \type{e,t}) \(\Xlo\lambda x [\prd{dormir}(x) \wedge P(\cns
  a)]\).  Donc selon (\RSyn\ref{SynTInt}), \(\Xlo\Intn\lambda x
[\prd{dormir}(x) \wedge P(\cns a)]\) est de type \type{s,\type{e,t}}.
Puis par (\RSyn\ref{SynTlamb}) on trouve
{\type{\type{e,t},\type{s,\type{e,t}}}} pour toute l'expression : 
\\[.5ex]
\(\underbrace{{\Xlo\lambda P}\underbrace{\xlo{\Intn}\underbrace{{\Xlo\lambda x} \underbrace{\Xlo[\prd{dormir}(x) \wedge P(\cns a)]}_{\typ t}}_{\type{e,t}}}_{\type{s,\type{e,t}}}}_{\type{\type{e,t},\type{s,\type{e,t}}}}\)


\fussy

\ex. \(\Xlo\lambda P\lambda x [\prd{dormir}(x) \wedge \Intn P(\cns a)]\)
%--
\\
Cette expression, quant à elle, est mal formée, quelle que soit la
manière dont on supplée les crochets qui manquent à $\Xlo\Intn P(\cns
a)$.  En effet $\Xlo[\Intn P(\cns a)]$ est en soi mal formée. Car les
crochets nous disent qu'il s'agirait d'une application fonctionnelle,
engendrée par (\RSyn\ref{SynTApp}), où l'argument est \cns a et la
fonction $\Xlo\Intn P$.  Donc pour arriver là, on aurait d'abord
appliqué la règle (\RSyn\ref{SynTInt}) sur $\vrb P$ (de type
\type{e,t}).  Par (\RSyn\ref{SynTInt}), $\Xlo\Intn P$ est donc de type
\type{s,\type{e,t}}.  Mais alors on n'a pas le droit d'appliquer
(\RSyn\ref{SynTApp}), puisque \cns a est de type \typ e, type qui ne
convient pas à celui de $\Xlo\Intn P$.  En revanche le type de \cns
a (\typ e) convient à  $\vrb P$ (\type{e,t}), et on a le
droit d'écrire $\Xlo[P(\cns a)]$ qui est de type \typ t.  On peut
aussi écrire $\Xlo\Intn[P(\cns a)]$, qui est de type \type{s,t} (par la
règle (\RSyn\ref{SynTInt})).  Mais à présent, c'est $\Xlo[\prd{dormir}(x)
  \wedge \Intn [P(\cns a)]]$ qu'on n'a plus le droit d'écrire.  Car la
règle (\RSyn\ref{SynTConn}), qui introduit la conjonction $\Xlo\wedge$,
exige deux expressions de type \typ t.  Et ce n'est pas le cas de
$\Xlo\Intn[P(\cns a)]$.


En résumé, les deux règles les plus emblématiques du \lcalcul\ sont (\RSyn\ref{SynTApp}) et (\RSyn\ref{SynTlamb}).
(\RSyn\ref{SynTlamb}) pourra toujours s'appliquer, il n'y a pas de condition à son application et le type du \lterme\ produit se déduit simplement et directement, avec la «recette» qui dit que  le type de $\Xlo\lambda v \alpha$ est composé du type de \vrb v et de celui de {\vrb\alpha} (cf.\ fig.~\ref{f:recettetypes}, page suivante). 
La règle (\RSyn\ref{SynTApp}) est plus contrainte : dans une application fonctionnelle, elle contrôle d'abord que le type de l'argument et celui attendu par la fonction sont bien identiques, et ensuite elle transmet alors le type résultant de la fonction à toute l'expression.

\begin{figure}[h!]
\begin{center}
\begin{tabular}{lll}
\(\overbrace{\xlo\lambda \underbrace{\vrb v}_{\rnode{V}{\zzboxb{$\textstyle b$}\phantom{\textstyle a}}} \underbrace{\vrb\alpha}_{\Rnode{A}{\textstyle\mtyp a}}}^{\textstyle\mtype{\rnode{b}{b},\rnode{a}{a}}}\)%
\nccurve[nodesepA=2pt,nodesepB=1pt,angleA=5,angleB=-10,ncurv=1,%
linecolor=gray]{->}{A}{a}%
\nccurve[nodesepA=2pt,nodesepB=1pt,angleA=120,angleB=-100,ncurv=1,%
linecolor=gray]{->}{V}{b}%
%%
&
\hstrab[5em]
&
%%
{\(\overbrace{\xlo[\underbrace{\xlo\alpha}_{\textstyle\mtype{\Rnode{b}{b},\Rnode{a}{a}}}\xlo(\underbrace{\xlo\beta}_{\textstyle\Rnode{bb}{\zzboxb{$\textstyle b$}\phantom{\textstyle a}}}\Xlo)]}^{\textstyle\Rnode{aa}{\mtyp a}}\)}%
\nccurve[nodesep=2pt,angleA=70,angleB=-140,%ncurv=.4,
linecolor=gray]{->}{a}{aa}%
\ncbar[nodesep=2pt,angle=-90,linecolor=gray]{b}{bb}\ncput*{$=$}
\end{tabular}
\end{center}
\caption{Types de la \labstraction\ et types de l'application fonctionnelle}\label{f:recettetypes}
\end{figure}

\newpage%\bigskip

\input{exo/typesebf}

\input{exo/typesQA}



\subsection{Sémantique de {LO} typé}
%------------------------------------
\label{ss:SemLOTypé}
\subsubsection{Calcul de toute sorte de dénotations}
%'''''''''''''''''''''''''''''''''''''''''''''''''''

Dans les chapitres précédents, les règles d'interprétation sémantique de {\LO} consistaient essentiellement à spécifier le calcul de la dénotation des \emph{formules}, \ie\ d'établir leurs conditions de vérité.  À présent les expressions bien formées de {\LO} ne sont plus seulement des formules, mais des expressions d'une extrême variété de types.  Et n'oublions pas que les types, par définition, prévoient la nature de la dénotation des expressions qu'ils catégorisent.
Il va donc nous être utile de pouvoir identifier simplement la nature des dénotations associées à chaque type.  Pour cela il nous suffira de regrouper dans un même ensemble toutes les dénotations possibles 
correspondant à un type donné, en nommant cet ensemble suivant la convention suivante.

\begin{nota}[Domaines de dénotation]
L'ensemble des dénotations possibles d'une expression de type $a$ est
noté $\DoM_a$.
\end{nota}\is{D@$\DoM$}

Ainsi, si $\vrb\alpha \in \ME_a$, alors
\(\denote{\vrb\alpha}^{\Modele,w,g} \in \DoM_a\).  
En clair : si \vrb\alpha\ est de type \mtyp a, sa dénotation se trouve dans $\DoM_{\mtyp a}$.
On appelle $\DoM_a$
le \kwo{domaine de dénotation}\is{domaine!\elid\ de denotation@\elid\ de dénotation}, ou d'interprétation, de $\vrb\alpha$ (ainsi que de $\ME_a$).
Il nous faut ensuite spécifier que vaut $\DoM_a$ pour tout type \mtyp a, c'est ce que donne la définition~\ref{d:DoM}.

\begin{defi}[Domaines de dénotation]\label{d:DoM}
Soit un modèle intensionnel
\(\Modele=\tuple{\Unv{A},\Unv{W},\Unv R,\FI}\). 
\begin{enumerate}
\item \(\DoM_{\typ e} = \Unv{A}\) ;
\item \(\DoM_{\typ t} = \set{0;1}\) ;
\item \(\DoM_{\mtype{a,b}} = \DoM_b^{\DoM_a}\), pour $a \neq \typ s$ ;
\item \(\DoM_{\mtype{\typ{s},a}} = \DoM_a^{\Unv{W}}\).
\end{enumerate}
\end{defi}


Les deux premières définitions nous disent que les expressions de type \typ e et \typ t dénotent respectivement des éléments de \Unv A et des valeurs de vérité.
La troisième dit qu'une expression fonctionnelle de type \mtype{a,b} a pour domaine de dénotation l'ensemble de \emph{toutes} les fonctions qui vont de $\DoM_{\mtyp a}$ vers $\DoM_{\mtyp b}$.
Par exemple, \(\DoM_{\type{e,t}} = \DoM_t^{\DoM_e} =
\set{0;1}^{\Unv{A}}\), c'est-à-dire l'ensemble de toutes les fonctions de \Unv A vers \set{0;1}, ou si l'on préfère l'ensemble de toutes les fonctions 
caractéristiques de sous-ensembles de \Unv{A}.
La quatrième règle traite du cas particulier des types intensionnels \mtype{\typ s,a}, car $\DoM_{\typ s}$ n'est pas défini (\typ s n'est pas un type), mais s'il existait, $\DoM_{\typ s}$ serait identifié à l'ensemble des indices intensionnels, \Unv W.

Comme d'habitude, les expressions de {\LO} sont interprétées par rapport à un modèle intensionnel \(\Modele=\tuple{\Unv{A},\Unv{W},\Unv R,\FI}\) et une assignation $g$. Il faut dire ici un mot sur  \FI\ et $g$, ces fonctions qui interprètent respectivement les constantes et les variables qui maintenant peuvent être de n'importe quel type.  Cela implique que $\FI$ et $g$ sont sensibles aux types, elles «savent» dans quel ensemble d'arrivée trouver leurs valeurs pour chaque type de {\Types}\footnote{Et nous le savons aussi.  Si l'on tient à rentrer dans les détails techniques, l'ensemble de toutes les assignations possibles par rapport à {\Modele} est \(\bigcup_{a\in\Types}\DoM_a^{\VAR_a}\) et celui de toutes les fonctions d'interprétations possibles est \(\bigcup_{a\in\Types}(\DoM_a^{\CON_a})^{\Unv{W}}\). }.  Par exemple, pour toute variable \vrb v de type \mtyp a, une assignation $g$ saura toujours que les valeurs à lui assigner sont dans $\DoM_a$. 


La définition~\ref{d:SemLOt} donne les règles d'interprétations de {\LO} typé.
Dans ces règles, les crochets introduits par la syntaxe ont été omis pour ne pas surcharger les écritures. %; de plus le terme \emph{objet} est employé dans son acception la plus large pour désigner tout ce que l'on peut trouver dans le modèle, y compris donc des fonctions.


\begin{defi}[Sémantique de \LO\ typé]\label{d:SemLOt}
Soit un modèle intensionnel \(\Modele=\tuple{\Unv{A},\Unv{W},\Unv R,\FI}\) et une assignation $g$.
\begin{enumerate}[sem,series=RglSemT,itemsep=.5ex] %[(\RSem1)]
\item si $\vrb\alpha \in \CON$,
\(\denote{\Xlo\alpha}^{\Modele,w,g}=F(w,\vrb\alpha)\) ;
\\
si $\vrb\alpha \in \VAR$, \(\denote{\Xlo\alpha}^{\Modele,w,g}=g(\vrb\alpha)\) ;
\label{SemTBase}
\item \(\denote{\Xlo\alpha(\beta)}^{\Modele,w,g} =
\denote{\Xlo\alpha}^{\Modele,w,g}(\denote{\Xlo\beta}^{\Modele,w,g})\) ;%
\label{SemTApp}
\item \(\denote{\Xlo\alpha=\beta}^{\Modele,w,g}=1\) ssi
 \(\denote{\Xlo\alpha}^{\Modele,w,g}=\denote{\Xlo\beta}^{\Modele,w,g}\) ; 
\label{SemT=}
\item  \(\denote{\Xlo\neg\phi}^{\Modele,w,g}=1\) ssi
\(\denote{\Xlo\phi}^{\Modele,w,g}=0\) ; \\
 \(\denote{\Xlo\phi \wedge \psi}^{\Modele,w,g}=1\),  ssi
 \(\denote{\Xlo\phi}^{\Modele,w,g}=1\) et
 \(\denote{\Xlo\psi}^{\Modele,w,g}=1\) ;  \\ 
 \(\denote{\Xlo\phi \vee \psi}^{\Modele,w,g}=1\),  ssi
 \(\denote{\Xlo\phi}^{\Modele,w,g}=1\) ou
 \(\denote{\Xlo\psi}^{\Modele,w,g}=1\) ;  \\ 
 \(\denote{\Xlo\phi \implq \psi}^{\Modele,w,g}=1\),  ssi
 \(\denote{\Xlo\phi}^{\Modele,w,g}=0\) ou
 \(\denote{\Xlo\psi}^{\Modele,w,g}=1\) ;  \\ 
 \(\denote{\Xlo\phi \ssi \psi}^{\Modele,w,g}=1\),  ssi
 \(\denote{\Xlo\phi}^{\Modele,w,g}=\denote{\Xlo\psi}^{\Modele,w,g}\) ;  
%[\phi \vee \psi], [\phi \implq
%     \psi]\) et \([\phi \ssi \psi] \in \ME_t\) ;
\label{SemTConn}
\item \(\denote{\Xlo\doitn n\phi}^{\Modele,w,g}=1\) ssi pour tout
 $w'\in\Unv{W}$ t.q. $w \Rel_{g(n)} w'$,
 \(\denote{\Xlo\phi}^{\Modele,w',g}=1\) ;
\\ 
\(\denote{\Xlo\peutn{n}\phi}^{\Modele,w,g}=1\) ssi il existe %un
 $w'\in\Unv{W}$ t.q. $w \Rel_{g(n)} w'$ et
 \(\denote{\Xlo\phi}^{\Modele,w',g}=1\) ;%
% si $\phi \in \ME_t$, alors \(\doit\phi \in \ME_t\) ; idem pour
%      tous les autres opérateurs modaux (\peut,\mP,\mF,\mG,\mH\dots) ;
%      de manière générale : si $\phi \in \ME_t$ et si $*$ est un
%      opérateur modal de {\LO}, alors $*\phi \in \ME_t$ ;
\label{SemTMod}
\item si $\vrb v \in \VAR_a$, alors :\\
\(\denote{\Xlo\forall v \phi}^{\Modele,w,g}=1\) ssi pour tout \(\Obj{x}
\in \DoM_a\), \(\denote{\Xlo\phi}^{\Modele,w,g_{[\Obj{x}/\vrb v]}}=1\) ;
\\
\(\denote{\Xlo\exists v \phi}^{\Modele,w,g}=1\) ssi il existe \(\Obj{x}
\in \DoM_a\) t.q. \(\denote{\Xlo\phi}^{\Modele,w,g_{[\Obj{x}/\vrb v]}}=1\) ;
\\
\(\denote{\Xlo\atoi v \phi}^{\Modele,w,g}\) est défini ssi 
il existe un \emph{unique} $\Obj x \in \DoM_a$ 
%=\Obj{x}\) ssi \(\Obj{x}
%\in \DoM_a\) et \Obj{x} est l'\emph{unique} élément de $\DoM_a$ 
t.q. \(\denote{\Xlo\phi}^{\Modele,w,g_{[\Obj{x}/\vrb v]}}=1\) ; alors \(\denote{\Xlo\atoi v \phi}^{\Modele,w,g} = \Obj x\) ;%
\label{SemTQ}
\item si $\vrb\alpha \in \ME_a$ et $\vrb v \in \VAR_b$, alors
 \(\denote{\Xlo\lambda v \alpha}^{\Modele,w,g}\) est la fonction de
 \(\DoM_a^{\DoM_b}\) qui pour tout \(\Obj{x}\in\DoM_b\) donne
 \(\Obj{x} \mapsto \denote{\Xlo\alpha}^{\Modele,w,g_{[\Obj{x}/v]}}\) ;
\label{SemTlamb}
\item si $\vrb\alpha \in \ME_a$, alors
 \(\denote{\Xlo\Intn\alpha}^{\Modele,w,g}\) est la fonction de
 \(\DoM_a^{\Unv{W}}\) qui pour tout $w' \in \Unv{W}$ donne \(w' \mapsto
 \denote{\Xlo\alpha}^{\Modele,w',g}\) ;
\label{SemTInt}
\item \(\denote{\Xlo\Extn\alpha}^{\Modele,w,g}=\denote{\Xlo\alpha}^{\Modele,w,g}(w)\).
%si $\alpha \in \ME_{\mtype{\mathrm{s},a}}$, alors $\Extn\alpha \in \ME_a$
\label{SemTExt}
\end{enumerate}
\end{defi}

La règle (\RSem\ref{SemTApp}) de l'application fonctionnelle reprend la  
définition~\ref{d:Sem@} vue en \S\ref{ss:Sem@F} ;\is{application fonctionnelle} 
et la règle (\RSem\ref{SemTlamb}) de la \labstraction\ reprend la définition~\ref{d:slabs} de \S\ref{ss:Semlabs}. 
Remarquons aussi,\label{H=<->} en passant, que si \vrb\phi\ et \vrb\psi\ sont de type \typ t, alors  $\Xlo[\phi=\psi]$ et $\Xlo[\phi\ssi\psi]$ signifient exactement la même chose, ce qui rend le connecteur $\Xlo\ssi$ redondant. Nous pourrions donc nous en passer, mais nous le conserverons car il est très usuel en sémantique formelle.  

La sémantique de {\LO} typé nous permet aussi de confirmer sous forme de théorèmes des observations que nous avons faites dans les pages qui précèdent (le terme \emph{objet} est employé ici dans son acception la plus large pour désigner tout ce que l'on peut trouver dans le modèle, y compris donc des fonctions). 

\newpage

\begin{theo}\label{th:f2E}
Toute expression de type \mtype{a,\typ{t}} dénote la fonction caractéristique d'un {ensemble}
d'objets, et plus précisément d'un sous-ensemble de $\DoM_a$. 
\end{theo}

La démonstration est immédiate du fait que $\DoM_{\mtype{a,\typ t}}=\set{0;1}^{\DoM_a}$. 
De même, le théorème~\ref{th:aat} s'appuie sur le fait qu'une relation\is{relation} binaire peut toujours se formaliser comme une fonction à deux arguments qui prend ses valeurs dans \set{0;1}.


\begin{theo}\label{th:aat}
Toute expression de type \mtype{a, \mtype{a,\typ t}} dénote une
\kwo{relation} (binaire) sur les objets de $\DoM_a$. 
\\
Et plus généralement, une expression de type \mtype{a, \mtype{b,\typ
    t}} dénote une {relation} (binaire) entre les objets de $\DoM_a$
et ceux de $\DoM_b$.
\end{theo}


Ces théorèmes s'incarnent directement dans notre notation $\Ch{\denote{\,}}$ que nous définissons formellement à présent :


\begin{nota}[\(\Ch{\denote{\;}}\)]
\begin{enumerate}\raggedright
\item Si \vrb\alpha\ est de type \type{\mtyp a,t}, \(\Ch{\denote{\vrb\alpha}}^{\Modele,w,g}=\set{\Obj x\in \DoM_{\mtyp a}\tq \denote{\vrb\alpha}^{\Modele,w,g}(\Obj x)=1}\).
\item Si \vrb\alpha\ est de type \type{\mtyp a,\type{\mtyp b,t}}, \(\Ch{\denote{\vrb\alpha}}^{\Modele,w,g}=\set{\tuple{\Obj x,\Obj y}\in \DoM_{\mtyp b}\times\DoM_{\mtyp a}\tq \denote{\vrb\alpha}^{\Modele,w,g}(\Obj y)(\Obj x)=1}\).
\item Si \vrb\phi\ est de type \typ t, \(\Ch{\denote{\vrb\phi}}^{\Modele,g}=\set{ w\in \Unv W\tq \denote{\vrb\phi}^{\Modele,g}(w)=1}\).
\end{enumerate}
\end{nota}


\subsubsection{Entraînement à la lecture des \lterme s}
%''''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{sss:lectureltermes}

L'expressivité de notre langage objet a considérablement décuplé. 
Il n'est pas inutile de prendre le temps ici d'apprivoiser la multitude des nouvelles écritures pour se familiariser avec leurs significations.
Nous allons passer en revue une série de \lterme s et, pour chaque exemple, je donnerai une description formelle de sa dénotation dans un modèle (a) et une glose plus informelle et rapide de sa lecture «syntaxique» (b).

\largerpage

\ex.
\(\Xlo\lambda x[\prd{dormir}(x)\wedge\prd{ronfler}(x)]\) est de type \et
\a. Il dénote une fonction de $\set{0;1}^{\Unv A}$ qui à chaque individu de \Unv A associe $1$ ssi cet individu dort et ronfle dans le monde d'évaluation.  En termes ensemblistes, c'est l'ensemble de tous ceux qui dorment et ronflent dans le monde d'évaluation.
\b. \sloppy C'est une expression qui attend un argument de type \typ e pour produire la formule $\Xlo[\prd{dormir}(x)\wedge\prd{ronfler}(x)]$ (quand \vrb x aura la valeur de cet argument).

\fussy

\ex.
\(\Xlo\lambda\phi\neg\phi\) est de type \type{t,t}
\a. Il dénote une fonction de $\DEUX^{\DEUX}$ qui renvoie $1$ pour $0$ et $0$ pour $1$. En termes ensemblistes, c'est donc l'ensemble \set{0}.
\b. C'est une expression qui attend une formule et retourne sa négation.


\ex.
\(\Xlo\lambda x\, x\) est de type \type{e,e}
\a. Il dénote une fonction de $\Unv A^{\Unv A}$ qui renvoie tel quel l'argument qu'on lui donne. C'est ce que l'on appelle la \emph{fonction d'identité}\is{identite@identité!fonction d'\elid} (sur \Unv A).
\b. C'est une expression qui attend un argument de type \typ e et redonne cet argument.


\ex.
\(\Xlo\lambda x\, \cns a\) est de type \type{e,e}
\a. Il dénote une fonction de $\Unv A^{\Unv A}$ qui renvoie toujours \Obj{Alice}, quel que soit son argument. C'est ce que l'on appelle une \emph{fonction constante}.\label{fctconstante}
\b. C'est une expression qui attend un argument de type \typ e mais qui n'en tient pas compte et retourne toujours \cns a\footnote{Ce \lterme\ n'est pas, en soi, équivalent à la constante \cns a, car il est fonctionnel --~de type \type{e,e}~-- alors que la constante est de type \typ e. Par {\breduc} $\Xlo[\lambda x\,\cns a(\cns b)]$ se simplifie en \cns a, mais il aura fallu donner l'argument \cns b, même si celui-ci est finalement escamoté. Bien sûr, dans une démarche d'analyse sémantique, un tel \lterme\ ne nous sera pas vraiment utile (mais le fait est qu'il existe dans {\LO}).}.



\ex.
\(\Xlo\lambda P\exists x [P(x)]\) est de type \ett
\a.  Il dénote une fonction de $\DEUX^{(\DEUX^{\Unv A})}$ qui à la fonction caractéristique de tout sous-ensemble de \Unv A associe le résultat $1$ ssi ce sous-ensemble contient au moins un élément. En termes ensemblistes, c'est l'ensemble de tous les sous-ensembles non vides de \Unv A.
\b. C'est une expression qui attend un prédicat unaire comme argument et produit la formule \(\Xlo\exists x [P(x)]\) (quand \vrb P vaut ce prédicat).


\sloppy

Profitons-en ici pour mentionner différentes façons --~alternatives mais équivalentes~-- d'envisager conceptuellement l'interprétation de \lterme s à plusieurs arguments (\ie\ avec plusieurs $\xlo\lambda$).  Ils peuvent d'abord bien sûr s'interpréter comme des fonctions à plusieurs arguments, mais aussi comme des relations entre plusieurs objets, ou encore comme une fonction à un argument qui, à partir de cet argument, construit un nouvel objet (qui peut lui-même être une fonction, un ensemble, une relation).  Cette dernière vision, plus constructive, peut parfois aider à décoder les \lterme s, comme le montrent les exemples suivants.


\fussy

\ex.
\(\Xlo\lambda x\lambda P [P(x)]\) est de type  \type{e,\ett}
\a.  Il dénote une fonction de $(\DEUX^{(\DEUX^{\Unv A})})^{\Unv A}$ qui prend en argument un individu de \Unv A (cf.\ \vrb x) et renvoie une fonction qui prend en argument la fonction caractéristique d'un ensemble d'individus (cf.\ \vrb P) et renvoie finalement $1$ ssi le premier individu (\vrb x) appartient à cet ensemble (\vrb P).  En termes ensemblistes, c'est une relation entre un individu et un ensemble et qui établit que l'individu est un élément de l'ensemble ; c'est tout simplement la relation d'appartenance $\in$.  On peut également voir cela comme une fonction qui prend en argument un individu et renvoie l'ensemble de tous les sous-ensembles de \Unv A qui contiennent cet individu ($\Xlo\lambda P [P(x)]$).
\b. C'est une expression qui attend un argument de type \typ e puis un prédicat unaire, et qui applique ce prédicat à cet argument.  Elle ne fait que réaliser l'application fonctionnelle.


\ex.
\(\Xlo\lambda P\lambda x [P(x)]\) est de type \type{\et,\et} \label{x:lPlxPx}
\a. Il dénote une fonction de  $(\DEUX^{\Unv A})^{(\DEUX^{\Unv A})}$ qui prend en argument la fonction caractéristique d'un ensemble d'individus (cf.\ \vrb P) et renvoie une fonction qui prend en argument un individu (cf.\ \vrb x) et renvoie $1$ ssi cet individu (\vrb x) appartient à cet ensemble (\vrb P).  En termes ensemblistes, c'est la relation dite de «possession» entre un ensemble et un individu, et qui peut se noter $\ni$.  On peut le voir aussi comme une fonction qui prend en argument un ensemble d'individus et qui, en résultat, reconstruit (la fonction caractéristique de) ce même ensemble (puisque $\Xlo\lambda x [P(x)]$ dénote l'ensemble de tous les individus qui appartiennent à \vrb P). C'est la fonction d'identité\is{identite@identité!fonction d'\elid} sur les ensembles (d'individus de \Unv A).
\b.  Comme la précédente, c'est une expression qui réalise l'application fonctionnelle entre un prédicat (unaire) et un argument (de type \typ e).  


Il est important de noter que même s'ils donnent à l'arrivée le même résultat, les \lterme s \LLast\ et \Last\ ne sont pas sémantiquement équivalents. Déjà parce qu'ils n'ont pas le même type, et donc parce qu'ils ne «travaillent»  pas de la même façon : ils attendent leurs arguments dans l'ordre inverse. 
Nous nous en rendons compte facilement en leur fournissant seulement leur premier argument.  Pour \LLast, nous aurons par exemple 
$\Xlo[\lambda x\lambda P[P(x)](\cns a)]$ 
qui se $\beta$-réduit en $\Xlo\lambda P[P(\cns a)]$, \ie\ l'ensemble de tous les ensembles qui contiennent \Obj{Alice} (ou plus informellement, l'ensemble de tous les prédicats que vérifie \cns a).  Pour \Last, nous aurons par exemple 
\(\Xlo[\lambda P\lambda x [P(x)](\lambda y\,\prd{dormir}(y))]\) qui se
$\beta$-réduit en 
\(\Xlo\lambda x [\lambda y\,\prd{dormir}(y)(x)]\) 
puis en 
\(\Xlo\lambda x\,\prd{dormir}(x)\), \ie\ la même chose que $\Xlo\lambda y\,\prd{dormir}(y)$.


\ex.
\(\Xlo\lambda x [x=\cns a]\) est de type \et
\a.  Il dénote une fonction de $\set{0;1}^{\Unv A}$ qui à chaque individu de \Unv A associe $1$ ssi cet individu est \Obj{Alice}. En termes ensemblistes, c'est le singleton \set{\Obj{Alice}}.
\b. C'est une expression qui attend un argument de type \typ e et produit une formule qui identifie cet argument à \cns a. 


\ex.
\(\Xlo\lambda x\lambda y [x=y]\) est de type \eet 
\a.  Il dénote une fonction de $(\set{0;1}^{\Unv A})^{\Unv A}$ qui prend en arguments un premier individu, puis un second et retourne $1$ ssi il s'agit deux fois du même individu.  C'est la relation d'identité\is{identite@identité!relation d'\elid} (sur \Unv A). En termes ensemblistes, on peut également le voir comme une fonction qui pour tout individu \Obj x de \Unv A construit le singleton \set{\Obj x} ($\Xlo\lambda y [x=y]$).
\b. C'est une expression qui attend deux arguments de type \typ e et retourne la formule qui dit que ces deux arguments ont la même dénotation.


Examinons enfin quelques expressions qui contiennent l'opérateur $\Xlo\textIntn$.



\ex.
\(\Xlo\lambda x \Intn[\prd{dormir}(x)]\) est de type \type{e,\type{s,t}}
\a. Il dénote une fonction de $(\DEUX^{\Unv W})^{\Unv A}$ qui à chaque individu de \Unv A associe (la fonction caractéristique de) l'ensemble de tous les mondes où cet individu dort.
\b. C'est une expression prédicative qui attend un argument de type \typ e et renvoie une proposition (qui dit que celui qu'on aura donné comme valeur pour \vrb x dort).


\ex.
\(\Xlo\Intn\lambda x\,\prd{dormir}(x)\) est de type \type{s,\et}
\a.  Il dénote une fonction de $(\DEUX^{\Unv A})^{\Unv W}$ qui à tout monde possible $w$ associe (la fonction caractéristique de) l'ensemble de tous ceux qui dorment dans $w$.
\b.  Ce n'est pas une expression prédicative, elle n'attend pas par elle-même d'argument dans {\LO} ; elle dénote la \emph{propriété} de dormir.

\sloppy

Si nous voulons saturer la position \vrb x de \Last\ en donnant un argument, nous devons d'abord la «désintensionnaliser» au moyen de $\Xlo\textExtn$, en écrivant par exemple \(\Xlo[\Extn\Intn\lambda x\,\prd{dormir}(x)(\cns a)]\).
En toute rigueur, nous n'avons pas le droit d'effectuer la \breduc\ sur cette application fonctionnelle (car elle ne commence pas par $\Xlo[\lambda$), mais nous avons vu dans le théorème~\ref{theo:v^} (p.~\pageref{theo:v^}) que 
$\Xlo\Extn\Intn\lambda x\,\prd{dormir}(x)$ est équivalent à $\Xlo\lambda x\,\prd{dormir}(x)$ ; nous pouvons donc simplifier en 
$\Xlo[\lambda x\,\prd{dormir}(x)(\cns a)]$ 
puis 
$\Xlo\prd{dormir}(\cns a)$.

\fussy



\subsubsection{Les \ulambda-conversions}
%'''''''''''''''''''''''''''''''''''''''
\label{ss:lambconv}\is{la (lambda)@$\lambda$ (lambda)!$\lambda$-conversion}

Nous avons vu en \S\ref{s:lambda} que le \lcalcul\ s'accompagne d'une série de règles de simplifications, fondées sur des équivalences sémantiques, et que l'on regroupe sous le nom de $\lambda$-conversions. %\is{lambda-conversion@$\lambda$-conversion} 
Nous avons assez longuement examiné et discuté celle qui nous est la plus utile : la {\breduc}.\is{beta-reduction@$\beta$-réduction}
Elle simplifie les applications fonctionnelles en --~pour résumer~-- remplaçant la variable $\lambda$-abstraite par l'argument donné au \lterme. 
Sa définition est redonnée ci-dessous, en précisant les situations où la {\breduc} n'est pas licite.

\largerpage

\begin{defi}[\textit β-réduction]\label{d:breduc2}
L'expression \(\Xlo[\lambda v \alpha(\gamma)]\) est équivalente à et remplaçable par
\([\xlo{\gamma}/\vrb v]\xlo{\alpha}\), \emph{sauf} :
\begin{itemize}
\item si une variable libre dans \vrb\gamma\ devait se retrouver liée dans \vrb\alpha, et 
\item si \vrb\gamma\ devait se retrouver dans la portée d'un opérateur intensionnel ($\Xlo\doitn n$, $\Xlo\peutn{n}$ ou $\Xlo\textIntn$) de \vrb\alpha. 
\end{itemize}
\end{defi}



Le premier cas de figure qui interdit la {\breduc} a déjà été présenté en \S\ref{ss:breduc}.  Le second procède du même principe (et cela apparaîtra plus clairement en \S\ref{s:Ty2}), mais il ne se contourne pas aussi facilement que le premier (pour le moment). 
Il interdit d'effectuer la {\breduc} si l'argument du \lterme\ atterrit dans la portée d'un opérateur intensionnel, et cela se comprend facilement : dans \(\denote{\Xlo[\lambda v \alpha(\gamma)]}^{\Modele,w,g}\), \vrb\gamma\ est interprété dans le monde $w$ (cf.~(\RSem\ref{SemTApp})) ; mais si dans \vrb\alpha, \vrb v est dans la portée de $\Xlo\doitn n$, $\Xlo\peutn{n}$ ou $\Xlo\textIntn$, alors après {\breduc} \vrb\gamma\ serait interprété par rapport à d'autres mondes que $w$ et il n'aurait donc pas la même dénotation qu'avant la {\breduc}.
Pour s'en convaincre, regardons les formules \Next[a] et \Next[b], que nous traduirons ici simplement par \sicut{il est nécessaire que le Pape soit chauve} (sans s'interroger d'avantage sur le type de modalité en question).

\ex.
\a. \(\Xlo[\lambda x \doitn n\prd{chauve}(x)(\atoi y\,\prd{pape}(y))]\)
\b. \(\Xlo \doitn n\prd{chauve}(\atoi y\,\prd{pape}(y))\)

\Last[b] serait le résultat de la {\breduc} de \Last[a]. Mais si nous les interprétons par rapport à un monde $w$, alors dans \Last[a], \(\Xlo\atoi y\,\prd{pape}(y)\) dénote l'unique individu qui est Pape dans $w$ ; appelons-le François.  
Et \Last[a] sera vraie dans $w$ ssi François est chauve dans tous les mondes accessibles à $w$.  Or \Last[b] est vraie dans $w$ ssi, dans tout monde $w'$ accessible à $w$, celui qui est Pape dans $w'$ est chauve dans $w'$.  Les deux formules ne sont donc pas équivalentes ; \Last[b] pourrait approximativement se paraphraser en \sicut{si quelqu'un, quel qu'il soit, est le Pape, alors nécessairement il sera chauve}, alors que \Last[a] parle du seul Pape du monde d'évaluation.


\sloppy
À titre informatif, je présente ici les deux autres règles de $\lambda$-conversion courantes, la $\eta$-réduction\footnote{Rappel : $\eta$ est la lettre grecque \emph{êta}.} et l'$\alpha$-équivalence. 
Nous avons déjà rencontré la $\eta$-réduction quand nous avions constaté que \(\Xlo\lambda x\,\prd{dormir}(x)\) et \prd{dormir} étaient équivalents.

\fussy

\is{eta-reduction@$\eta$-réduction}
\begin{defi}[\textit η-réduction]
Si \vrb v n'est pas libre dans $\vrb\alpha$, l'expression \(\Xlo\lambda v [\alpha(v)]\) est équivalente à et remplaçable par \(\Xlo \alpha\).
\end{defi}

\sloppy

La définition prend garde d'exclure les cas où $\Xlo\lambda v$ lie aussi des occurrences de \vrb v \emph{dans} \vrb\alpha. 
En effet \(\Xlo\lambda x [[\prd{regarder}(y)](x)]\) (c'est-à-dire \(\Xlo\lambda x\,\prd{regarder}(x,y)\), qui correspond au GV \sicut{regarde \vrb y}) équivaut à \(\Xlo[\prd{regarder}(y)]\), 
mais \(\Xlo\lambda x [[\prd{regarder}(x)](x)]\) (c'est-à-dire \(\Xlo\lambda x\,\prd{regarder}(x,x)\), qui correspond au GV \sicut{se regarde}) n'équivaut pas à \(\Xlo[\prd{regarder}(x)]\) (\sicut{regarde {\vrb x}}).  C'est parce que \vrb x est libre dans \(\Xlo[\prd{regarder}(x)]\).

\fussy

L'$\alpha$-équivalence \is{alpha-equivalence@$\alpha$-équivalence}%
a déjà été rencontrée également. Elle dit simplement que l'on peut renommer sans risque la variable liée par un $\xlo\lambda$.
Ainsi $\Xlo\lambda x\,\prd{dormir}(x)$ 
peut être remplacé par $\Xlo\lambda y\,\prd{dormir}(y)$, et 
$\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)$ par   
$\Xlo\lambda x \lambda y\,\prd{regarder}(y,x)$\footnote{Précisons cependant qu'en toute rigueur, cette dernière substitution se fait avec plusieurs étapes intermédiaires : par exemple
$\Xlo\lambda y \lambda x\,\prd{regarder}(x,y)$ est remplacé par   
$\Xlo\lambda y \lambda z\,\prd{regarder}(z,y)$, qui est remplacé par   
$\Xlo\lambda x \lambda z\,\prd{regarder}(z,x)$, qui est remplacé par 
$\Xlo\lambda x \lambda y\,\prd{regarder}(y,x)$. Ceci afin d'éviter de tomber par exemple sur $\Xlo\lambda y \lambda y\,\prd{regarder}(y,y)$.}.   


\begin{defi}[\textit α-équivalence]\label{d:alpha-eq}
Soit \vrb u et \vrb v deux variables de même type. Si \vrb u n'apparaît pas  dans \vrb\alpha, alors l'expression \(\Xlo\lambda v\alpha\) est équivalente à et remplaçable par \(\xlo\lambda\vrb u [\vrb u/\vrb v]\Xlo\alpha\).
\end{defi}


\subsubsection{Conséquence logique et monotonie}
%''''''''''''''''''''''''''''''''''''''''''''''''
\is{consequence logique@conséquence logique}
\label{sss:CL+Mon}

\sloppy

Au chapitre \ref{Ch:t+m}, nous avons défini l'équivalence sémantique pour n'importe quelle expression de {\LO} (déf.~\ref{d:eqsemw} p.~\pageref{d:eqsemw}).
Cette définition vaut toujours mais à présent nous pouvons également généraliser la définition de la conséquence logique à d'autres expressions que les seules formules de type \typ t.
Par exemple, il peut être utile de reconnaître une conséquence logique entre des prédicats de type \et\ ou \ett.  En effet lorsque nous concluons que \sicut{Jim est un éléphant} $\satisf$ \sicut{Jim est un animal} c'est bien parce que nous savons qu'il y a une conséquence logique du prédicat \sicut{être un éléphant} vers le prédicat \sicut{être un animal}, autrement dit $\prd{éléphant}\satisf\prd{animal}$.
Avec {\LO} typé nous pouvons assez facilement étendre la définition de $\satisf$ pour de telles expressions en partant de la définition de base (déf.~\ref{d:conslogw} p.~\pageref{d:conslogw}) que nous manipulons depuis quelque temps.  Rappelons cette définition, en nous limitant ici au cas d'une conséquence entre seulement deux formules : si \vrb\phi\ et $\vrb\psi \in \ME_{\typ t}$, alors $\vrb\phi\satisf\vrb\psi$ ssi pour tout modèle \Modele, tout monde $w$ et toute assignation $g$ tels que 
$\Modele,w,g\satisf\vrb\phi$, on a aussi $\Modele,w,g\satisf\vrb\psi$.    

\fussy

Il faut cependant d'abord prendre une petite précaution : $\satisf$ ne peut pas s'appliquer à \emph{tous} les types de $\Types$.  Par exemple, cela n'aurait pas beaucoup de sens de définir la relation entre des expressions de type \typ e.  Nous devons nous limiter à un sous-ensemble de $\Types$, que nous appellerons l'ensemble des \emph{types booléens}\footnote{Attention, il ne s'agit pas ici de ce qui est couramment appelé \emph{type booléen} en logique et en informatique et qui renvoie simplement à notre type \typ t. Ce que je désigne ici par types booléen est également appelé, dans la littérature anglophone, \alien{conjoinable types}, que nous pourrions traduire (un peu maladroitement) par «types conjoignables». Cf. \S\ref{ss:ConConGen}.}\is{type!\elid\ booléen}\is{booléen|see{type (booléen)}}, $\TypesB$, défini de la manière suivante :

\begin{defi}[Types booléens]\label{d:TBooleen}
$\TypesB$ est le plus petit sous-ensemble de $\Types$ tel que :
  \begin{enumerate}
  \item $\typ t \in \TypesB$;
    \item si $a\in \Types$ et $b\in\TypesB$, alors $\mtype{a,b}\in\TypesB$.
  \end{enumerate}
\end{defi}


Les expressions de type booléen sont ces expressions qui lorsqu'on leur fournit tous leurs argument finissent par donner un résultat de type \typ t.

Maintenant nous pouvons définir la conséquence logique pour tous ces types en procédant de manière récursive.
Le cas initial est celui de la conséquence entre expressions de type \typ t qui correspond à la définition de base rappelée ci-dessus.  Ensuite pour tout type booléen complexe, $\satisf$ est défini comme suit :

\begin{defi}[Conséquence logique généralisée]\is{consequence logique@conséquence logique!\elid\ généralisée}
  Soit $\mtype{a,b} \in \TypesB$, \vrb\alpha\ et $\vrb\beta\in\ME_{\mtype{a,b}}$ et $\vrb x\in\VAR_{\mtyp a}$ :
  $\vrb\alpha\satisf\vrb\beta$ ssi $\xlo{\alpha(x)}\satisf\xlo{\beta(x)}$.
\end{defi}

L'idée est que pour vérifier que $\vrb\alpha\satisf\vrb\beta$ nous saturons progressivement les arguments des deux expressions.  Nous savons que $\Xlo\alpha(x)$ et $\Xlo\beta(x)$ sont de type \mtyp b qui est lui aussi un type booléen, en vertu de la définition~\ref{d:TBooleen} ; nous pouvons alors réappliquer «en boucle» la vérification de $\satisf$ sur ces deux nouvelles expressions jusqu'à ce que nous arrivions au type \typ t qui est pris en charge par la définition de base.
Reprenons notre exemple.  Pour vérifier que $\prd{éléphant}\satisf\prd{animal}$, il nous faut vérifier que ${\Xlo\prd{éléphant}(x)}\satisf\Xlo{\prd{animal}(x)}$. 
Nous sommes maintenant avec deux expressions de type \typ t qui contiennent toutes les deux la variable libre \vrb x. 
Nous appliquons alors la définition~\ref{d:conslogw} et cette définition nous demande d'envisager toutes les assignations possibles $g$.  C'est précisément cela qui garantit la cohérence de la conséquence entre prédicats.  Car ${\Xlo\prd{éléphant}(x)}\satisf\Xlo{\prd{animal}(x)}$ dit que pour \emph{toute} valeur possible de \vrb x, si \vrb x est un éléphant, alors \vrb x est un animal\footnote{C'est comme si \vrb x était globalement liée par un quantificateur universel. Et d'ailleurs ${\Xlo\prd{éléphant}(x)}\satisf\Xlo{\prd{animal}(x)}$ équivaut logiquement à $\satisf\Xlo\forall x [\prd{éléphant}(x)\implq\prd{animal}(x)]$.}.
Et nous savons que cela est vrai\footnote{En supposant que nous avons à ce sujet un postulat de signification comme ceux de \S\ref{sss:pds}.}, ce qui nous permet de conclure que $\prd{éléphant}\satisf\prd{animal}$.
De la même façon nous pouvons démontrer ${\Xlo\lambda x\,\prd{aimer}(x,\cns a)}\satisf{\Xlo\lambda x\exists y\,\prd{aimer}(x,y)}$ ou ${\Xlo\lambda y\lambda x\,\prd{adorer}(x,y)}\satisf{\Xlo\lambda y\lambda x\,\prd{aimer}(x,y)}$.


Bien sûr, on peut aussi définir la conséquence entre prédicats en passant par la relation d'inclusion de leurs dénotations ensemblistes : $\prd{éléphant}\satisf\prd{animal}$ ssi pour tout \Modele, $w$ et $g$, $\Ch{\denote{\prd{éléphant}}}^{\Modele,w,g}\inclus\Ch{\denote{\prd{animal}}}^{\Modele,w,g}$. 
Mais en procédant comme nous l'avons fait, nous montrons que la conséquence entre prédicats s'obtient à partir de la conséquence logique classique entre phrases. 
Et cette conséquence généralisée nous permet assez facilement de caractériser une propriété notable de certaines expressions et que l'on appelle la \kw{monotonie}.

\largerpage[2]

\begin{defi}[Monotonie]\label{d:Monotonie}
Soit $a$ et $b\in\TypesB$, $\vrb\gamma\in\ME_{\mtype{a,b}}$, $\vrb\alpha$ et $\vrb\beta\in\ME_{\mtyp a}$.
\begin{enumerate}
  \item \vrb\gamma\ est \kwo{monotone croissant} ssi : si $\vrb\alpha\satisf\vrb\beta$ alors $\xlo{\gamma(\alpha)}\satisf\xlo{\gamma(\beta)}$.
  \item \vrb\gamma\ est \kwo{monotone décroissant} ssi : si $\vrb\alpha\satisf\vrb\beta$ alors $\xlo{\gamma(\beta)}\satisf\xlo{\gamma(\alpha)}$.
\end{enumerate}
\end{defi}


\sloppy

Ce que la définition dit, c'est que les expressions monotones croissantes conservent à leur propre niveau les conséquences logiques que l'on peut observer au niveau de leur position argumentale, alors que les monotones décroissantes inversent ces conséquences\footnote{À cet égard, dans la littérature anglophone, ces propriétés sont également appelées, respectivement, \alien{upward entailing context} et \alien{downward entailing context}.  Ici contexte doit être pris dans le sens d'environnement syntactico-sémantique.}.  Et parallèlement, il existe des expressions qui ne sont pas monotones, c'est-à-dire qui «détruisent» les conséquences logiques.

\fussy

Les propriétés de monotonie sont sémantiquement pertinentes pour plusieurs raisons.  D'abord, avec la définition~\ref{d:Monotonie}, nous pouvons les vérifier formellement dans {\LO}.  Mais nous pouvons également, parfois assez facilement, repérer ces propriétés directement dans les énoncés de la langue\footnote{En vérité, pour être tout à fait rigoureux, ce qui est «facile» à démontrer c'est qu'un environnement \emph{n'est pas} monotone ; il suffit pour cela de trouver un contre-exemple.  Pour proposer une hypothèse de monotonie, on peut au mieux procéder par induction en examinant de nombreux exemples variés.}.  Par conséquent, si nous constatons qu'un certain environnement syntactico-sémantique se trouve être monotone (dé)croissant, alors nous saurons que sa traduction correcte dans {\LO} devra aussi satisfaire cette propriété.  C'est donc un outil pratique pour nous aider à valider des analyses sémantiques.
Pour émettre l'hypothèse qu'un environnement linguistique donné, appelons-le C, est monotone, la méthode est, dans ses grandes lignes, la suivante.  D'abord, il faut s'assurer qu'il y a un moyen de traduire C dans {\LO} par une expression fonctionnelle (comme \vrb\gamma\ dans la déf.~\ref{d:Monotonie}).  Ensuite, on considère deux expressions linguistiques A et B dont on sait qu'elles sont en relation de conséquence logique $\text{A}\satisf\text{B}$ (parce qu'on sait que A et B se traduisent respectivement par \vrb\alpha\ et \vrb\beta\ et que $\vrb\alpha\satisf\vrb\beta$) et qui peuvent s'insérer grammaticalement dans C. Notons C(A) et C(B) l'insertion de A et B dans C.  Si, en supposant que C(A) est vrai, on constate que C(B) est nécessairement vrai aussi, alors on peut supposer que C est monotone croissant. Si à l'inverse, en supposant que C(B) est vrai, on constate que C(A) est nécessairement vrai, alors c'est l'hypothèse que C est monotone décroissant que l'on peut envisager.  Pour renforcer les conclusions, il est prudent de recommencer le test en variant A et B car la définition \ref{d:Monotonie} vaut pour n'importe quels \vrb\alpha\ et \vrb\beta. 

Voici quelques exemples.
Comme la monotonie croissante ne change pas les conséquences logiques, on considère souvent que c'est un peu un cas par défaut.  Illustrons-la tout de même avec la position de complément d'un verbe d'attitude comme \sicut{penser} ou \sicut{dire}.
Nous savons que \Next[a] $\satisf$ \Next[b] (ce sont nos A et B).

\ex.
\a. Alice a la grippe et Bruno a un rhume. 
\b. Alice a la grippe.


Et nous constatons que que \Next[a] $\satisf$ \Next[b].  C'est donc un indice pour estimer que \sicut{penser} est monotone croissant sur sa position de complément.


\ex.
\a. Charles pense qu'Alice a la grippe et Bruno un rhume.
\b. Charles pense qu'Alice a la grippe.


Le cas exemplaire de la monotonie décroissante est celui de la négation ($\Xlo\lambda\phi\neg\phi$, \ie\ \sicut{il est faux que}).  En reprenant {\LLast} nous avons cette fois \Next[b] $\satisf$ \Next[a]\footnote{Et \ref{x:MD3a} $\not\satisf$ \ref{x:MD3b} car \ref{x:MD3a} est vrai si Alice a la grippe et Bruno n'a pas de rhume, et dans ce cas \ref{x:MD3b} est faux.}.

\ex.
\a. Il est faux qu'Alice a la grippe et Bruno un rhume.\label{x:MD3a}
\b. Il est faux qu'Alice a la grippe.\label{x:MD3b}


De même, les adverbes de quantification \sicut{parfois} et \sicut{souvent}, employé dans des phrases simples, sont monotones croissants, alors que \sicut{rarement} est monotone décroissant.  Nous savons que \sicut{boire du whisky} $\satisf$ \sicut{boire de l'alcool}, et nous constatons que \Next[a] $\satisf$ \Next[b] et \NNext[b] $\satisf$ \NNext[a].

\ex.
\a. Charles boit souvent du whisky.
\b. Charles boit souvent de l'alcool.

\ex.
\a. Charles boit rarement du whisky.
\b. Charles boit rarement de l'alcool.



Nous verrons d'autres exemples plus illustratifs de monotonie (dé)croissante en 
\S\ref{ss:PtésDet}.  Mais nous pouvons dores et déjà faire une observation intéressante.  Il se trouve que dans {\LO} l'implication matérielle $\Xlo\implq$ est monotone décroissante pour sa position d'antécédent (et monotone croissante pour sa position de conséquent), c'est-à-dire que si $\xlo\phi\satisf\xlo\psi$, alors $\xlo{[\psi\implq\chi]}\satisf\xlo{[\phi\implq\chi]}$.   On peut trouver en français des exemples de conditionnelles qui \emph{semblent} confirmer cela, comme \Next\ où \Next[a] $\satisf$ \Next[b].

\ex.
\a. S'il pleut, la route sera glissante.
\b. S'il pleut et qu'il fait nuit, la route sera glissante.

Mais en fait il existe de nombreux contre-exemples comme {\Next} : \Next[a] $\not\satisf$ \Next[b].

\ex. \label{x:MD5}
\a. Si tu avales du poison, tu meurs.\label{x:MD5a}
\b. Si tu avales du poison et que tu prends un antidote, tu meurs.


Cela tend à montrer que, comme nous l'avons déjà laisser entendre, l'implication matérielle n'est pas une traduction sémantiquement tout à fait adéquate pour rendre compte des structures conditionnelles en \sicut{si..., alors...} des langues naturelles.  C'est pourquoi nous reviendrons sur leur analyse au chapitre~\ref{Ch:modalites} (vol.~2)\footnote{On pourrait arguer, à l'inverse, qu'en fait un locuteur qui asserte \ref{x:MD5a} fait un usage abusif de la conditionnelle, que littéralement il dit quelque chose de faux (tout en le présentant comme vrai) et que c'est par un mécanisme de réinterprétation (peut-être pragmatique) que l'on comprendra qu'il s'autorise à négliger des exceptions, etc. Mais ce serait là ce que l'on appelle en sciences une hypothèse \alien{ad hoc}, c'est-à-dire une hypothèse supplémentaire qui vient complexifier l'analyse dans le but principal de sauvegarder la proposition initiale, en l'occurrence ici que les conditionnelles se traduisent par des implications matérielles.  Il me semble plus raisonnable au moins d'explorer la piste d'une réanalyse des conditionnelles qui rende compte directement de \ref{x:MD5}.}.


Un autre intérêt à considérer la monotonie en sémantique est lié à l'étude de certaines expressions de la langue que l'on appelle les  \kwo{termes à polarité négative} (ang.\ \alien{negative polarity items} ou NPI). 
Ce sont des expressions comme, entre autres, \sicut{any} et \sicut{ever} en anglais, et \sicut{jamais}, \sicut{aucun}, \sicut{le moindre}, \sicut{quoi/qui que ce soit}, \sicut{du tout}, \sicut{bézef}, \sicut{croyable}, \sicut{broncher}, \sicut{lever le petit doigt}... en français. 
L'emploi grammatical de ces expressions est régi par des contraintes spécifiques.  On observe en effet qu'elles ne peuvent apparaître que dans des {«contextes  négatifs»} ; mais c'est là une caractérisation informelle, car ces contextes ne se résument pas simplement à la portée d'une négation comme \sicut{ne... pas} ou \sicut{il est faux que} ni même à la présence de $\Xlo\neg$ dans la traduction sémantique.
C'est pourquoi il a été proposé\footnote{Cf. notamment \citet{Ladusaw:80}.\Andexn{Ladusaw, W.}} une description plus précise qui identifie ces contextes légitimant les NPI aux environnements monotones décroissants.  C'est ainsi ce qui peut expliquer le contraste en {\Next} :

\ex.
\a. *Il fait souvent le moindre effort.
\b. Il fait rarement le moindre effort.


Les termes à polarité négative constituent un sujet sémantique particulièrement complexe et une immense littérature leur est consacrée.  Nous ne faisons ici qu'effleurer très grossièrement la question (il existe une variété de sous-catégories de ces termes qui n'ont pas toutes le même comportement et la monotonie telle que nous l'avons définie ici ne suffit pas à expliquer entièrement le phénomène : par exemple les antécédents de conditionnelles ne sont pas monotones décroissants mais ils légitiment les NPI).  Mais cela montre qu'il y a une pertinence à étudier des propriétés telles que la monotonie.
C'est d'ailleurs également corroboré par l'observation que les environnements monotones décroissants (et plus généralement ceux qui légitiment les NPI) ont naturellement tendance à suspendre les implicatures scalaires\footnote{Cf.\ par exemple \citet[chap.~4]{Horn:89}.\Andexn{Horn, L.}}.\is{implicature!\elid\ scalaire} Par exemple en \Next[a] la disjonction est interprétée exclusivement par implicature scalaire, alors qu'en \Next[b] elle est interprétée inclusivement (donc sans l'implicature) :

\ex.
\a. Je prends souvent un dessert ou du fromage au restaurant (mais pas souvent les deux).
\b. Je prends rarement un dessert ou du fromage au restaurant (\zarb mais pas rarement les deux).





\medskip

\begin{exo}\label{exo:lEns}
Supposons qu'en assimilant les fonctions et les ensembles, nous décidions de représenter sous forme de prédicats de \LO\ quelques notions de la théorie des ensembles. % comme ci-dessous. 
Sachant que \vrb x est de type \typ e et \vrb P et \vrb Q de type \et, donnez pour chaque prédicat défini ci-dessous un \lterme\ qui lui est équivalent (et qui ne contient pas de constante non logique).

\begin{enumerate}
\item \(\denote{\Xlo\prd{élément-de}(x,P)}^{\Modele,w,g}=1\) ssi \(\denote{\vrb x}^{\Modele,w,g}\in\Ch{\denote{\Xlo P}}^{\Modele,w,g}\)
\item \(\denote{\Xlo\prd{inclus}(P,Q)}^{\Modele,w,g}=1\) ssi \(\Ch{\denote{\Xlo P}}^{\Modele,w,g}\inclus\Ch{\denote{\Xlo Q}}^{\Modele,w,g}\)
\item \(\denote{\Xlo\prd{disjoint}(P,Q)}^{\Modele,w,g}=1\) ssi \(\Ch{\denote{\Xlo P}}^{\Modele,w,g}\cap\Ch{\denote{\Xlo Q}}^{\Modele,w,g}=\Evide\)
\item \(\Ch{\denote{\Xlo\prd{intersection}(P,Q)}}^{\Modele,w,g}= \Ch{\denote{\Xlo P}}^{\Modele,w,g}\cap\Ch{\denote{\Xlo Q}}^{\Modele,w,g}\)
\item \(\Ch{\denote{\Xlo\prd{union}(P,Q)}}^{\Modele,w,g}= \Ch{\denote{\Xlo P}}^{\Modele,w,g}\cup\Ch{\denote{\Xlo Q}}^{\Modele,w,g}\)
\item \(\denote{\Xlo\prd{vide}(P)}^{\Modele,w,g}=1\) ssi \(\Ch{\denote{\Xlo P}}^{\Modele,w,g}=\Evide\)
\item \(\denote{\Xlo\prd{singleton}(P)}^{\Modele,w,g}=1\) ssi \(\Ch{\denote{\Xlo P}}^{\Modele,w,g}\) contient un et un seul élément
\item \(\Ch{\denote{\Xlo\prd{parties-de}(P)}}^{\Modele,w,g}= \powerset(\Ch{\denote{\Xlo P}}^{\Modele,w,g})\) 
\end{enumerate}

\begin{solu} (p. \pageref{exo:lEns})

\begin{enumerate}
\item \(\prd{élément-de} = \Xlo\lambda P\lambda x[P(x)]\)
\item \(\prd{inclus} = \Xlo\lambda Q\lambda P\forall x[[P(x)]\implq[Q(x)]]\)
\item \(\prd{disjoint} = \Xlo\lambda Q\lambda P\neg\exists x[[P(x)]\wedge[Q(x)]]\)
\item \(\prd{intersection} = \Xlo\lambda Q\lambda P\lambda x[[P(x)]\wedge[Q(x)]]\)
\item \(\prd{union} = \Xlo\lambda Q\lambda P\lambda x[[P(x)]\vee[Q(x)]]\)
\item \(\prd{vide} = \Xlo\lambda P\neg\exists x[P(x)]\)
\item \(\prd{singleton} = \Xlo\lambda P\exists x[[P(x)]\wedge \forall y[[P(y)]\implq y=x]]\)
\item \(\prd{parties-de} = \Xlo\lambda P\lambda Q\forall x[[Q(x)]\implq[P(x)]]\)

NB : ce dernier \lterme\ est identique à \prd{inclus} (c'est normal car $A\in\powerset(B)$ ssi $A\inclus B$).
\end{enumerate}
\end{solu}
\end{exo}

\newpage

\input{exo/notationsPTQ}

%\input{exo/OEdipe}


\subsection{Applications}
%-------------

\subsubsection{Une version plus «catégorique»}
%''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{sss:Categ}

Commençons par un peu de vocabulaire.  Les constantes logiques de {\LO} ($\xlo\neg$, $\xlo\wedge$, $\xlo\vee$, $\xlo\implq$, $\xlo\ssi$, $\Xlo=$, $\xlo\forall$, $\xlo\exists$, etc.) sont ce que l'on appelle des symboles \kwi{syncatégorématiques}{syncategorematique@syncatégorématique}. Par opposition, les constantes non logiques et les variables du langage sont, eux, des symboles \kwi{catégorématiques}{categorematique@catégorématique}.
Un symbole catégorématique est un symbole à qui le système attribue une interprétation propre et autonome ; autrement dit \vrb\alpha\ est catégorématique si $\denote{\vrb\alpha}^{\Modele,w,g}$ est défini (par la définition~\ref{d:SemLOt}).  À l'inverse, un symbole syncatégorématique est un symbole dont l'usage (syntaxique) et l'interprétation sont toujours définis «en compagnie» d'une ou plusieurs autres expressions de {\LO}.  
Par exemple, $\xlo\neg$ \is{negation@négation}
est syncatégorématique parce que $\xlo\neg$ en soi n'est pas une expression bien formée de {\LO} (elle n'a pas de type) et que $\denote{\Xlo\neg}^{\Modele,w,g}$ n'est pas défini. Ce que nous savons interpréter c'est $\denote{\Xlo\neg\phi}^{\Modele,w,g}$ : il faut que $\xlo\neg$ soit accompagné d'une formule.  Les règles (\RSem\ref{SemT=}--\ref{SemTExt}) de la définition~\ref{d:SemLOt} peuvent, à cet égard, être appelées les règles d'interprétation syncatégorématiques de {\LO}.  Plus un langage contient de symboles syncatégorématiques, plus ses règles syntaxiques et sémantiques sont nombreuses.


Pourtant nous savons bien  assigner --~au moins informellement~-- une
interprétation à la négation $\xlo\neg$ : elle consiste à inverser la
valeur de vérité de la formule qui suit.    
D'ailleurs nous avions vu (\S\ref{ConnVfctel}) que c'est un opérateur vérifonctionnel, ce qui signifie qu'il «dénote» une fonction de vérité, en l'occurrence de $\DEUX^{\DEUX}$.  C'est la fonction \Next.


\ex. {\small
\(\left[\begin{array}{c@{\qquad\quad}c}
    \Rnode{d1}{1} &  \Rnode{a1}{1}\\
    \Rnode{d0}{0} &  \Rnode{a0}{0}
  \end{array}\right]\ncline[nodesep=2pt]{->}{d1}{a0}\ncline[nodesep=2pt]{->}{d0}{a1}
  \)} \label{x:f-neg}


Or rien ne nous empêche de concevoir dans {\LO} une expression \emph{catégorématique} qui dénote \Last.  Ce sera une constante de type \type{t,t}.
Appelons-la \prd{non}. 
Alors les formules $\Xlo\prd{non}(\phi)$ et $\Xlo\neg\phi$ sont exactement équivalentes. 

Nous pouvons ainsi donner une version catégorématique de tous les connecteurs vérifonctionnels. Pour les connecteurs binaires, ce seront des constantes de types \type{t,\type{t,t}}, qui prennent leur dénotation dans  $(\DEUX^{\DEUX})^{\DEUX}$. 
Par exemple, pour $\xlo\wedge$ nous aurons la constante \prd{et}, et la formule $\Xlo[[\prd{et}(\psi)](\phi)]$, simplifiable en $\Xlo\prd{et}(\phi,\psi)$, sera équivalente à $\Xlo[\phi\wedge\psi]$.  Nous nous débarrasserions alors des règles (\RSyn\ref{SynTConn}) et (\RSem\ref{SemTConn}) de {\LO}.  Cependant, nous devrions ajouter par ailleurs une définition qui précise le sens de ces constantes afin de garantir qu'elles répliquent correctement nos connecteurs vérifonctionnels ; quelque chose comme {\Next} (pour chaque constante concernée) :


\ex. 
Quels que soient $\Modele$, $w$ et $g$, 
\(\denote{\prd{et}}^{\Modele,w,g} =
\small
\left[\begin{array}{c@{\qquad}c@{}}
\Rnode{1}{1} & \Rnode{a}{\stx}\left[\begin{array}{c@{\qquad\quad}c}
    \Rnode{d01}{1} &  \Rnode{a01}{1}\\
    \Rnode{d00}{0} &  \Rnode{a00}{0}
  \end{array}\right]\ncline[nodesep=2pt]{->}{d01}{a01}\ncline[nodesep=2pt]{->}{d00}{a00}\\
\Rnode{0}{0} & \Rnode{b}{\stx}\left[\begin{array}{c@{\qquad\quad}c}
    \Rnode{d11}{1} &  \Rnode{a11}{1}\\
    \Rnode{d10}{0} &  \Rnode{a10}{0}
  \end{array}\right]\ncline[nodesep=2pt]{->}{d11}{a10}\ncline[nodesep=2pt]{->}{d10}{a10}
\end{array}\right]\ncline[nodesep=2pt]{->}{1}{a}\ncline[nodesep=2pt]{->}{0}{b}
\)


Une telle définition en soi ne fait pas partie des règles de la définition~\ref{d:SemLOt} ; elle est donnée «en annexe», comme la définition de n'importe quel prédicat, et fonctionne donc un peu comme un postulat de signification 
(cf.\ \S\ref{sss:pds}).

\sloppy

Bien entendu, le gain n'est pas considérable, et les versions catégorématiques de connecteurs sont présentées ici simplement à titre d'illustration de ce que permet un langage comme {\LO} typé.  Nous continuerons à utiliser nos connecteurs syncatégorématiques, car nous en avons pris l'habitude et ils offrent des modes d'écritures plus simples et plus naturelles.
Par exemple si la négation phrastique du français peut se traduire en {\LO} par \prd{non} (ou $\Xlo\lambda \phi\,\prd{non}(\phi)$), nous aurons aussi bon compte à la traduire simplement par $\Xlo\lambda \phi\neg \phi$ (qui bien sûr dénote aussi la fonction \ref{x:f-neg}) ;  de même pour la conjonction \sicut{et} qui se traduira par $\Xlo\lambda\psi\lambda\phi[\phi\wedge\psi]$ plutôt que par \prd{et} ou $\Xlo\lambda\psi\lambda\phi\,\prd{et}(\phi,\psi)$.

\fussy

Notons que nous avions déjà discuté, sans le dire, de la «catégorématisation» du symbole $\xlo=$ (p.~\pageref{=categ}) pour constater que ce n'était pas si simple, car on ne pourrait pas assigner un type unique à la constante qui remplacerait $\xlo=$. Cela montre que les symboles syncatégorématiques ont un pouvoir expressif utile et parfois supérieur à celui des constantes non logiques de {\LO}.  
De même, nous ne pouvons pas vraiment donner une version catégorématique de $\vrb\lambda$.  En revanche, nous pouvons le faire pour les quantificateurs et nous en tirerons profit en \S\ref{s:QG} ; quant à $\Xlo\textIntn$, $\Xlo\textExtn$ et les opérateurs modaux, leur cas sera abordé, d'une certaine manière, \alien{infra} en \S\ref{s:Ty2}.

Notons, pour terminer, qu'une constante catégorématique valant pour l'implication peut être intéressante d'un point de vue représentationnel (et compositionnel). Appelons-là \prd{si} ; nous aurons intérêt à la définir de telle sorte que $\Xlo[[\prd{si}(\phi)](\psi)]$ soit équivalente à $\Xlo[\phi\implq\psi]$. 
Dans ce cas, nous poserons que son sens est défini par \Next. 

\ex. 
Quels que soient $\Modele$, $w$ et $g$, 
\(\denote{\prd{si}}^{\Modele,w,g} =
\small
\left[\begin{array}{c@{\qquad}c@{}}
\Rnode{1}{1} & \Rnode{a}{\stx}\left[\begin{array}{c@{\qquad\quad}c}
    \Rnode{d01}{1} &  \Rnode{a01}{1}\\
    \Rnode{d00}{0} &  \Rnode{a00}{0}
  \end{array}\right]\ncline[nodesep=2pt]{->}{d01}{a01}\ncline[nodesep=2pt]{->}{d00}{a00}\\
\Rnode{0}{0} & \Rnode{b}{\stx}\left[\begin{array}{c@{\qquad\quad}c}
    \Rnode{d11}{1} &  \Rnode{a11}{1}\\
    \Rnode{d10}{0} &  \Rnode{a10}{0}
  \end{array}\right]\ncline[nodesep=2pt]{->}{d11}{a11}\ncline[nodesep=2pt]{->}{d10}{a11}
\end{array}\right]\ncline[nodesep=2pt]{->}{1}{a}\ncline[nodesep=2pt]{->}{0}{b}
\)

Mieux vaudra alors éviter d'appliquer la règle de suppression des crochets (qui produit la formule $\Xlo\prd{si}(\psi,\phi)$ peu intuitive) ; 
la notation $\Xlo[[\prd{si}(\phi)](\psi)]$ (éventuellement simplifiée en $\Xlo\prd{si}(\phi)(\psi)$) montre en effet que \prd{si} est une traduction naturelle du subordonnant conditionnel \sicut{si} du français, car nous voyons que \prd{si} prend en premier argument la subordonnée conditionnelle \vrb\phi\ (qu'introduit \sicut{si}) puis en second argument la principale \vrb\psi. 
C'est ainsi plus proche de la structure syntaxique d'une phrase conditionnelle\footnote{Cependant, rien ne nous empêche de conserver le symbole $\Xlo\implq$ en posant que \sicut{si} se traduit par le \lterme\ \mbox{$\Xlo\lambda\phi\lambda\psi[\phi\implq\psi]$}.}, et c'est même très similaire, dans l'aspect «graphique», de ce nous proposerons au chapitre \ref{Ch:modalites} (vol.~2) %en \S\ref{s:conditionnelles} 
pour une analyse précise de ce type de phrases (où nous verrons que l'implication matérielle est en fait mal appropriée).

\subsubsection{Lecture \dere\ des expressions référentielles}
%''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''
\label{sss:dere}
\is{de re@\alien{de re}}

Au chapitre précédent (\S\ref{sss:derededicto}), nous avons vu comment représenter sémantiquement la lecture \dedicto\ d'une expression référentielle. 
Pour  \sicut{\OE dipe$_1$ voulait épouser sa$_1$ mère}, la traduction est \Next, où le \GN\ apparaît dans la portée de l'opérateur d'intensionnalité $\Xlo\Intn$ :


\ex. 
\(\Xlo\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},\atoi y\,
  \prd{mère}(y,\cns{\oe})))\) \label{x:OEd^1dd}


\sloppy

Nous avons également vu que l'analyse de la lecture \dere\ était plus problématique car nous n'avions pas d'endroit, hors de la portée de $\Xlo\Intn$, où insérer $\Xlo\atoi y\,\prd{mère}(y,\cns{\oe})$.  Le \lcalcul\ résout ce problème. 
La traduction \Next\ nous donne les conditions de vérité de la phrase avec l'interprétation \dere\ du \GN.

\fussy

\ex. 
\(\Xlo[\lambda x\,\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},x))(\atoi y\,\prd{mère}(y,\cns{\oe}))]\)
\label{x:OEd^1dr}


\sloppy

La \breduc\ n'est pas autorisée ici car l'argument $\Xlo\atoi y\,\prd{mère}(y,\cns{\oe})$ se retrouverait dans la portée de $\Xlo\Intn$ (cf. \S\ref{ss:lambconv}) ;  \ref{x:OEd^1dr} ne se ramène donc pas à \ref{x:OEd^1dd}.
Et les deux formules ne sont pas équivalentes.  
Comme nous l'avions vu, $\Xlo\Intn\prd{épouser}(\cns{\oe},\atoi y\,\prd{mère}(y,\cns{\oe}))$ dénote l'ensemble de tous les mondes dans lesquels \OE dipe épouse sa mère ; d'un monde à l'autre, celle qui est la mère d'\OE dipe peut être une femme différente, mais dans chacun de ces mondes, \OE dipe l'épouse.  
Ainsi \ref{x:OEd^1dd} est vraie dans un monde $\w$ ssi \OE dipe souhaite que cet ensemble de mondes contienne $\w$.

\fussy

En revanche dans \ref{x:OEd^1dr}, l'objet de \prd{vouloir} est la proposition $\Xlo\Intn\prd{épouser}(\cns{\oe},x)$, qui dénote l'ensemble de tous les mondes dans lesquels \OE dipe épouse \vrb x. 
L'identité de \vrb x (\ie\ sa dénotation) dépend de l'assignation $g$, mais ce sera le même individu pour tous les mondes de la proposition.  Par exemple, si $g(\vrb x)=\Obj{Jocaste}$, alors $\Xlo\Intn\prd{épouser}(\cns{\oe},x)$ dénotera l'ensemble des mondes où \OE dipe épouse Jocaste (qu'elle soit ou non sa mère dans ces mondes).
Et $\Xlo\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},x))$ est vraie dans $\w$ ssi \OE dipe veut épouser \vrb x dans $\w$.  
Ensuite par \lamb-abstraction, $\Xlo\lambda x\,\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},x))$ dénote dans $\w$ la fonction caractéristique de l'ensemble de tous les individus qu'\OE dipe veut épouser dans $\w$. 
À cette fonction, \ref{x:OEd^1dr} donne l'argument $\Xlo\atoi y\,\prd{mère}(y,\cns{\oe})$.  Donc en l'interprétant dans $\w$, \ref{x:OEd^1dr} sera vraie ssi la dénotation dans $\w$ de $\Xlo\atoi y\,\prd{mère}(y,\cns{\oe})$ (c'est-à-dire celle qui est véritablement la mère d'\OE dipe dans $\w$) appartient à l'ensemble des personnes qu'\OE dipe veut épouser dans $\w$.  Ce sont bien les conditions de vérité de la phrase avec la lecture \alien{de re} du \GN\ \sicut{sa mère}.

{\LO} a maintenant l'expressivité requise pour différencier les lectures \alien{de dicto} et \alien{de re} dans tous les cas de figure.  Il reste encore cependant un point d'achoppement pour l'analyse complète du phénomène, mais il ne réside pas exactement dans le pouvoir expressif de {\LO}.  Il est lié à des considération d'interface syntaxe-sémantique et c'est celui que soulevait l'exercice \ref{exo:homfem} p.~\pageref{exo:homfem}. 
Nous reviendrons sur cette question en \S\ref{s:Ty2} et à la fin du chapitre \ref{ch:ISS}.


\subsubsection{Types et domaines de définition des fonctions}
%'''''''''''''''''''''''''''''''''''''''''''''''''''
\label{sss:DomDef}

Une expression de type \mtype{b,a} dénote une fonction de $\DoM_{\mtyp a}^{\DoM_{\mtyp b}}$, c'est-à-dire dont nous savons que l'ensemble de départ est $\DoM_{\mtyp b}$.  
Au chapitre \ref{Ch:t+m} (\S\ref{s:intension} p. \pageref{H:DomDefF}), nous avions vu qu'il arrive parfois de devoir  faire la distinction entre l'ensemble de départ d'une fonction et son \kwo{domaine de définition}\footnote{On le nomme parfois aussi simplement le \emph{domaine} de la fonction.  Il ne faudra pas confondre le domaine de définition d'une fonction et le domaine de dénotation (déf.~\ref{d:DoM} p.~\pageref{d:DoM}) d'un \lterme.\is{domaine!\elid\ de denotation@\elid\ de dénotation}}\is{domaine!\elid\ de definition@\elid\ de définition (d'une fonction)}.  
Rappelons que le domaine de définition est un sous-ensemble de l'ensemble de départ qui ne contient que les éléments pour lesquels la fonction est définie, c'est-à-dire auxquels elle attribue une valeur.  %Par exemple s'il l'on dit que la fonction numérique $x \mapsto \frac{1}{x}$ appartient à $\mathbb R^{\mathbb R}$, il est alors important de préciser qu'elle n'est pas définie pour $0$ et donc que son domaine est l'ensemble $\mathbb R$ privé de $0$ (souvent noté $\mathbb R^*$). 
Dans un système sémantique comme \LO\ typé, indiquer les domaines de définition des fonctions dénotées par les \lterme s peut s'avérer utile notamment pour signaler les présuppositions\is{presupposition@présupposition} déclenchées par telle ou telle unité lexicale ou construction syntaxique (et c'est ce que nous évoquions déjà en \S\ref{s:intension}).  
Par exemple, en anglais, le nom \sicut{bachelor} (\sicut{célibataire}) présuppose que l'individu en question est de sexe masculin (et probablement adulte).  
Nous aimerions alors que l'analyse sémantique puisse conclure que \Next\ n'a pas de valeur de vérité (dès que nous savons qu'Elizabeth est une femme) plutôt que de conclure qu'elle est fausse.

\ex.
Elizabeth is a bachelor.


Au chapitre \ref{Ch:1}, nous avions proposé de scinder l'analyse des phrases contenant une présupposition en deux parties, le présupposé (\sicut{Elizabeth est un homme}) et le proféré (\sicut{Elizabeth est non mariée}), en entendant que dans les mondes où le présupposé est faux, alors il n'est pas utile de calculer le proféré : celui-ci n'est pas défini. 
Avec nos dénotations fonctionnelles, nous pouvons maintenant rendre cette analyse plus opérationnelle, directe et explicative : il suffit de poser que la fonction dénotée par \sicut{bachelor} (de type \et) est définie seulement pour les individus de \Unv A qui sont des hommes adultes, elle ne retournera aucune valeur pour \Obj{Elizabeth} dans les mondes où celle-ci est une femme.

Cependant, formellement, dans {\LO} nous pouvons seulement dire que \prd{bachelor} est de type \et, dénotant une fonction dont l'ensemble de départ est tout \Unv A. Notre système de types ne nous permet pas directement de délimiter le domaine de définition de cette fonction. 
Pour suppléer à cela, il est parfois fait usage d'une notation spéciale dans l'écriture des \lterme s qui se présente comme une variante additionnelle de la \labstraction.  Regardons tout de suite sa définition syntaxique :

\begin{defi}[\ulambda-abstraction avec domaine de définition]
\begin{enumerate}[syn] %[(\RSyn1)]
\item[(\RSyn\ref{SynTlamb}$'$)] si $\vrb\alpha \in \ME_a$, $\vrb\phi\in\ME_{\typ t}$ et $\vrb v \in \VAR_b$, alors $\xlo{\lambda v\Df\phi\,\alpha} \in \ME_{\mtype{b,a}}$ 
\end{enumerate}
\end{defi}

Dans l'écriture $\Xlo\lambda v\Df\phi\,\alpha$, la formule \vrb\phi\ joue un peu le rôle d'un filtre sur la variable-argument \vrb v pour dire que la fonction dénotée par le \lterme\ ne sera définie que pour les éléments de $\DoM_{\mtyp b}$ pour lesquels \vrb\phi\ est vraie.  Par exemple, la traduction de \sicut{bachelor} pourra alors être \Next, où la formule $\Xlo[\prd{adult}(x)\wedge\prd{male}(x)]$ qui délimite le domaine de la fonction dénotée est la présupposition de l'unité lexicale :

\ex.
\(\sicut{bachelor} \leadsto 
\Xlo\lambda x\Df[\prd{adult}(x)\wedge\prd{male}(x)]\,\neg\prd{married}(x)\)


\sloppy
Pour montrer que cette notation n'est pas une simple sorcellerie graphique, nous devons immédiatement en donner la règle d'interprétation sémantique.  Celle-ci se déduit assez facilement de (\RSem\ref{SemTlamb}) en remarquant que le \lterme\ $\Xlo\lambda v\phi$ (que nous pouvons reconstruire à partir de $\Xlo\lambda v\Df\phi$) est de type \type{\mtyp b,t}, autrement dit il dénote la fonction caractéristique d'un sous-ensemble de $\DoM_{\mtyp b}$  qui est, par vocation, le domaine de définition de $\Xlo\Xlo\lambda v\Df\phi\, \alpha$.

\fussy

\begin{defi}[Restriction du domaine de définition d'un \ulambda-terme]
\begin{enumerate}[sem] %[(\RSem1)]
\item[(\RSem\ref{SemTlamb}$'$)] si $\vrb\alpha \in \ME_a$ et $\vrb v \in \VAR_b$, alors
 \(\denote{\Xlo\lambda v\Df\phi\, \alpha}^{\Modele,w,g}\) est la fonction de
 \(\DoM_a^{\DoM_b}\) qui pour tout \(\Obj{x}\in %\DoM_b\cap
\Ch{\denote{\Xlo\lambda v\phi}}^{\Modele,w,g}\) donne
 \(\Obj{x} \mapsto \denote{\Xlo\alpha}^{\Modele,w,g_{[\Obj{x}/v]}}\) et qui ne donne aucune valeur pour les autres \Obj x de $\DoM_b$.
\end{enumerate}
\end{defi}

\sloppy

Cette définition implique bien que  \Last\ ne donnera le résultat $1$ ou $0$ que pour les arguments qui sont dans $\Ch{\denote{\Xlo\lambda x[\prd{adult}(x)\wedge\prd{male}(x)]}}^{\Modele,w,g}$ (l'ensemble des hommes de $w$). 
La règle (\RSem\ref{SemTlamb}$'$) montre aussi que \Last\ n'est pas du tout équivalent à 
\(\Xlo\lambda x[[\prd{adult}(x)\wedge\prd{male}(x)]\wedge\neg\prd{married}(x)]\)
ni à 
\(\Xlo\lambda x[[\prd{adult}(x)\wedge\prd{male}(x)]\implq\neg\prd{married}(x)]\)
: si leur argument dénote une femme, le premier de ces \lterme s donnera le résultat $0$ et le second le résultat~$1$.

\fussy

Avec ce mécanisme, nous pouvons intégrer de nombreuses présuppositions dans nos traductions.  Par exemple, le verbe \sicut{regretter} présuppose la vérité de sa subordonnée.  Au chapitre \ref{Ch:t+m}, nous avons vu que les verbes d'attitudes propositionnelles se traduisent par des prédicats qui prennent une proposition en deuxième argument.  Une proposition est une expression de type \type{s,t} et ces prédicats sont donc de type \type{\type{s,t},\type{e,t}} (nous y reviendrons au chapitre suivant). 
Si \vrb p est une variable de type \type{s,t}, alors \sicut{regretter} avec sa présupposition peut se traduire par :

\ex.
\(\sicut{regretter} \leadsto
\Xlo\lambda p\Df\Extn p\,\lambda x\,\prd{regretter}(x,p)
\)

$\Xlo\Extn p$ est une formule de type \typ t, et le domaine de définition de \Last\ est \(\Ch{\denote{\Xlo\lambda p\Extn p}}^{\Modele,w,g}\), qui est l'ensemble de toutes les propositions qui sont vraies dans le monde $w$. 

\sloppy

Préciser les domaines de définition est une pratique assez naturelle dès lors que nous sommes amenés à manipuler des fonctions et c'est particulièrement utile pour la description des entrées lexicales.  Mais il faut savoir que cela ne suffit pas à régler entièrement le traitement sémantique des présuppositions (comme la question de leurs projections, leurs liens avec le contexte, etc.). 
Les restrictions $\Xlo\Df\phi$ sont des sortes d'appendices de la variable \lamb-abstraite et nous ne devons normalement pas appliquer la \breduc\ habituelle quand elles sont présentes, au risque de faire disparaître $\Xlo\Df\phi$ et ainsi de perdre l'information présuppositionnelle. 
%\footnote{En fait, si l'argument donné au \lterme\ n'appartient pas au domaine de définition, non seulement il ne faut pas effectuer la \breduc, mais il faut aussi interrompre le calcul car l'application fonctionnelle échoue. Dans les autres cas, la \breduc\ peut être moins nocive, \emph{mais} si l'argument a une dénotation qui dépend de $g$ (par exemple c'est une variable ou il contient une variable libre), alors la réussite de l'application fonctionnelle dépendra aussi de $g$.  Autrement dit, la restriction  $\Xlo\Df\phi$  sera aussi un filtre sur les assignations valides pour interpréter l'expression et le discours en cours.  Tracer ce genre de filtrage des assignations demande un aménagement supplémentaire du système formel que nous n'opérerons pas ici, mais c'est une piste intéressante à suivre pour le traitement dynamique des présuppositions.}.
En effet, si une expression complexe $\Xlo\gamma$ de \LO\ contient un \lterme\  $\Xlo\lambda v\Df\phi\,\alpha$, la restriction $\Xlo\Df\phi$  peut se communiquer à $\Xlo\gamma$ : si \vrb\gamma\ est fonctionnelle, alors son domaine de définition sera aussi affecté.  Par exemple \(\Xlo[\lambda x\Df[\prd{adult}(x)\wedge\prd{male}(x)]\,\neg\prd{married}(x)(\cns j)]\), de type \typ t, n'aura une dénotation dans $w$ que si \cns j dénote un homme dans $w$ ; et donc l'intension de cette formule, qui est une fonction de $\set{0;1}^{\Unv W}$, verra son domaine de définition limité aux mondes dans lesquels \cns j est un homme.  
Nous retrouvons ici ce qui était dit sur l'intension des expressions présuppositionnelles en \S\ref{s:intension}.  Et cela montre également la voie vers un calcul compositionnel des présuppositions :  le présupposé de l'application fonctionnelle $\Xlo[\lambda v\Df\phi\,\alpha(\beta)]$ est $\Xlo[\lambda v\phi(\beta)]$ (et sa partie proférée est $\Xlo[\lambda v\alpha(\beta)]$ où l'on peut appliquer la \breduc).   Maintenir explicitement la propagation des présuppositions dans {\LO} demanderait un important  développement formel du langage que nous n'opérerons pas ici, nous nous contenterons de continuer à scinder, quand c'est nécessaire, le contenu des expressions (en contributions présupposée {\vs} proférée). 
Nous faisons ce choix seulement pour des raisons de simplicité, mais sachons que ce rôle des restrictions $\Xlo\Df\phi$ annonce, dans l'esprit, une façon de traiter dynamiquement les présuppositions dans un système formel.

\fussy

\medskip\largerpage[-1]

Je voudrais profiter de cette discussion sur les domaines de définitions pour faire quelques remarques sur la notion de types en sémantique et sur leur rôle dans le système et l'analyse des expressions de la langue.

Les types sont des catégories de dénotations et servent donc à encoder les propriétés combinatoires des expressions interprétables.  Parmi ces catégories, nous avons le type \typ e qui regroupe tous les éléments de \Unv A, c'est-à-dire tous les objets qui peuplent le monde.  On pourrait avoir l'idée, assez naturelle, que cette catégorie n'est pas particulièrement fine et estimer qu'on y gagnerait à ajouter de la variété dans la catégorisation des objets de \Unv A. 
Cela permettrait d'introduire dans le système ce que l'on appelle les \kwo{restrictions de sélection},\is{restriction!\elid\ de selection@\elid\ de sélection} c'est-à-dire ces informations lexicales qui précisent les catégories de choses que certains prédicats s'attendent à trouver pour leurs arguments.  
Par exemple, il semble raisonnable de considérer que le deuxième argument du prédicat \prd{boire} devra dénoter quelque chose de liquide, que le premier argument de \prd{lire} dénotera un être humain (ou une entité douée de raison), etc. 
Utiliser à cet effet un système de types affinés et détaillés peut être une option prometteuse et performante.  Si nous avions, par exemple, un type \textsc{liqu} pour les expressions qui dénotent des choses liquides de \Unv A, nous pourrions poser que \prd{boire} est de type \type{\textsc{liqu},\et} pour coder dans {\LO} sa restriction de sélection --~ce qui, par la même occasion, serait une autre façon de délimiter le domaine de définition de la fonction dénotée\footnote{Mais inversement, on peut aussi utiliser, pour le même effet, le mécanisme vu précédemment.  Les restrictions de sélection, au sens le plus strict, sont normalement des présuppositions.  La traduction de \sicut{boire} peut alors être :
\ExNBP
\ex.
\(\sicut{boire} \leadsto \Xlo\lambda y\Df\prd{liquide}(y)\,\lambda x\,\prd{boire}(x,y)\)\par\vspace{-1\baselineskip}}.  


\largerpage[-1]

De telles stratégies sont assez souvent déployées en sémantique lexicale,\is{semantique@sémantique!\elid\ lexicale} 
en logique et en intelligence artificielle%
\footnote{De nombreux travaux sont consacrés à ces approches ; voir par exemple les discussions dans  \citet{Pust:95}\Andexn{Pustejovsky, J.} et \citet{Asher:11}.\Andexn{Asher, N.}\label{fn:GL-WoW}}%
, mais habituellement il est plutôt prudent de dissocier formellement, d'une manière ou d'une autre, le système des types logiques que nous manipulons dans {\LO} et celui des types ontologiques qui détaillent les catégories de choses --~et pour les distinguer, nous appellerons ces derniers des \kwo{sortes}\is{sorte}.  
La raison en est que les types et les sortes, même s'ils sont conceptuellement reliés,  n'ont pas exactement les mêmes propriétés formelles au sein du système. 
D'abord les types de \Types\ (avec \typ e, \typ t, \typ s) sont mutuellement exclusifs : par définition, une expression donnée de {\LO} ne peut pas avoir différents types.  Les sortes doivent, elles, être des \emph{sous-types} de \typ e organisés dans une vaste hiérarchie, que l'on appelle une taxonomie, c'est-à-dire un inventaire structuré des catégories de choses qui composent \Unv A.  Ainsi \textsc{liqu} serait un sous-type de \typ e et, par transitivité, \prd{boire} serait aussi de type \eet.  Pour que les sortes soient alors vraiment opérationnelles dans \LO, il faudrait ajouter du contrôle sur la règle d'application fonctionnelle (par exemple en spécifiant qu'il faut prendre en compte le type le plus précis des expressions).   De plus, les taxonomies qui organisent les sortes ne sont pas des structures strictement ordonnées par une simple relation d'inclusion (comme dans : les canaris sont des oiseaux qui sont des animaux qui sont des êtres animés qui sont des individus concrets etc.) : il arrive fréquemment que des objets doivent être vus sémantiquement comme relevant de deux sortes distinctes qui ne sont pas des sous-types l'une de l'autre, engendrant ainsi des croisements de catégories complexes à gérer formellement.  Un exemple classique est celui de \sicut{livre} dont la dénotation contient des entités qui sont  à la fois des objets matériels (que l'ont peut acheter, tenir, ranger, abîmer...) et des objets abstraits informationnels (des contenus que l'on peut lire, écrire, comprendre, apprécier...).  
Enfin les sortes doivent normalement être manipulées formellement avec beaucoup de souplesse, sans quoi elles nuiraient à la flexibilité sémantique propre aux langues.  Les restrictions de sélections ne sont souvent que des tendances, pas des règles infaillibles qui devraient bloquer les interprétations.  Il serait fautif, par exemple, de poser que l'argument de \prd{miauler} doit appartenir à la sorte \textsc{chat}, car vous et moi pouvons très bien miauler ; et si nous restreignons cet argument à la sorte \textsc{animé}, ce qui semble plus raisonnable, nous excluons les emplois dérivés ou  métaphoriques (\sicut{le moteur a miaulé puis s'est arrêté d'un coup})  qui, même s'ils n'ont probablement pas à être résolus entièrement par la sémantique compositionnelle, ne doivent peut-être pas être rejetés purement et simplement par un échec d'interprétation.  Et rappelons qu'au chapitre \ref{Ch:1} (\S\ref{sss:anomalies} p. \pageref{x:anom}) nous avions convenu de ne pas compter les invraisemblances comme de véritables et graves anomalies sémantiques (ce qui va de pair avec la liberté imaginative qu'induit l'utilisation des mondes possibles en sémantique intensionnelle).

Par conséquent, les sortes enrichissent indéniablement le système, en particulier lorsqu'il s'agit de s'attaquer sérieusement à des questions de sémantique lexicale\footnote{Voir par exemple \citet{Kleiber:99}\Andexn{Kleiber, G.} pour un panorama détaillé de ces questions.}, mais si l'on souhaite les intégrer à un système sémantique compositionnel, elles doivent alors s'accompagner d'un appareil formel approprié, encadré par une logique plus flexible que la logique classique, capable d'inférences révisables et d'une complexité qui dépasse vertigineusement la portée du présent ouvrage\footnote{Voir par exemple les références citées en note \ref{fn:GL-WoW} \alien{supra}.}.  Nous n'utiliserons pas ici de sous-types, et la seule sorte que nous manipulons dans \LO\ (jusqu'à présent) est \typ e ;  dans plusieurs des chapitres suivants (ainsi que, d'une certaine manière, dans la prochaine section) nous introduirons de nouvelles sortes, pour refléter dans le langage l'enrichissement ontologique que nous aurons apporté au modèle, mais ces sortes seront en fait des types à part entière, c'est-à-dire disjoints de \typ e.






\section{\Tyz\ et \LOz}
%======================
\label{s:Ty2}\is{Ty2@{\Tyz}}

Nous allons ici introduire un nouveau langage sémantique qui exploite plus encore le \lcalcul\ typé.  Notre langage {\LO} s'appuie sur la Logique Intensionnelle de \textcite{PTQ}, et à ce titre il est donc intensionnel, comme nous l'avons vu au chapitre précédent, notamment parce que les extensions sont calculées relativement à un indice de monde possible qui peut varier au cours de l'interprétation.  Le langage qui va être présenté ici est, lui, extensionnel, en ce sens qu'il satisfait  techniquement le principe d'extensionnalité ;\is{extensionnalité!principe d'\elid} mais qu'on se rassure, ce n'est pas une régression par rapport à ce que nous avons vu jusqu'ici, au contraire.  Car nous allons voir que ce langage est, à sa manière, également intensionnel, dans la mesure où il conserve les mondes possibles de \Unv W mais en les manipulant différemment.  Il s'appuie sur ce que l'on appelle en anglais la \alien{Two-sorted Type Theory} (littéralement : Théorie des types «à deux sortes»),\is{sorte} habituellement abrégée en {\Tyz}, introduite par \citet{Gallin:75}.\Andex{Gallin, D.}
Contrairement à ce que nous avons fait jusqu'ici, nous n'allons pas présenter ce langage comme une nouvelle mouture améliorée de {\LO}, mais comme un second langage que nous maintiendrons en parallèle ; et pour le distinguer, nous le nommerons {\LOz}.\is{LO2@\LOz} 


\subsection{Extensionnaliser l'intensionnalité}
%-----------------------------------------------

Le principe fondamental de {\Tyz} et {\LOz} est que nous allons nous autoriser à avoir, dans le langage même,  des expressions qui dénotent des mondes possibles.  En pratique, il s'agira de variables,\is{variable!\elid\ de mondes} que nous noterons \vrbz w, \vrbz{w'}, \vrbz{w''}... ou éventuellement \vrbz v, \vrbz u\footnote{Nous pourrions également nous donner des constantes de mondes possibles, mais ça ne sera ni utile ni réaliste, car nous ne pouvons pas identifier un monde possible précis dans \Unv W.}. 
Cela a un première implication immédiate : dans {\LOz}, \typ s\is{s (type)}\is{type!s} devient un type à part entière\footnote{D'où l'appellation de \alien{two-sorted} où le terme de «sorte» renvoie aux deux sortes d'entités de base du modèle auxquelles le langage peut référer directement, à savoir les objets de \Unv A et les mondes de \Unv W.}, celui de ces variables.  Et les variables de mondes vont jouer un rôle similaire aux indices intensionnels de {\LO}, mais à l'intérieur des écritures de \LOz. 
Les indices de mondes servent de paramètres pour interpréter les constantes non logiques (notamment les prédicats) via la fonction d'interprétation $\FI$ (cf.\ $\FI(\w,\xlo{\alpha})$) ;  dans {\LOz} les variables de mondes vont, de même, paramétrer le calcul des dénotations mais, cette fois, en tant qu'\emph{arguments} donnés directement aux prédicats. 


Prenons un exemple.  Le verbe \sicut{dormir} du français se traduit dans {\LO} par le prédicat \prd{dormir} de type \et.  Comme {\LO} est intensionnel, nous pouvons dire que \prd{dormir} représente le sens\is{sens} de \sicut{dormir} dans le langage sémantique%
\footnote{En vérité, c'est un peu inexact : nous avons vu en \S\ref{s:intension} que le sens (\ie\ l'intension) \emph{dépend} d'un modèle $\Modele$ (intensionnel) et d'un contexte (que nous formalisons pour l'instant au moyen de d'une assignation $g$) ; ainsi en toute rigueur, le sens de \sicut{dormir} est donné par $\denote{\prd{dormir}}^{\Modele,g}$. Mais comme nous avons mis tout ce que nous pouvions dans $\Modele$ (cf.\ \S\ref{ss:vclw}) et que $g$ ne concerne globalement que quelques expressions (les variables libres), l'approximation est assez peu nocive et la corrélation entre l'écriture de \prd{dormir} et les règles de calcul données par $\denote{\prd{dormir}}^{\Modele,g}$ est assez bonne. 

Par ailleurs il est important de ne pas se laisser dérouter par la nuance qui faite ici entre \prd{dormir} qui \emph{représente} ou \emph{symbolise} le sens de \sicut{dormir} et $\Xlo\Intn\prd{dormir}$ qui \emph{dénote} le sens de \sicut{dormir}.}.  
En revanche, nous ne pouvons pas directement écrire une expression qui représente la dénotation de \sicut{dormir} par rapport au monde $\w$.  Pour ce faire nous sommes obligés de sortir de {\LO} en notant $\denote{\prd{dormir}}^{\Modele,\w,g}$ qui nous fera ensuite calculer $\FI(\w,\prd{dormir})$.  
Dans {\LOz}, nous allons utiliser à la place le prédicat \prdzz{dormir} de type \type{s,\et}.  En fait ce prédicat est équivalent au $\Xlo\Intn\prd{dormir}$ de {\LO} : il dénote la propriété de dormir, la fonction qui pour tout monde possible renvoie la dénotation de \sicut{dormir} dans ce monde.
Mais maintenant dans {\LOz} nous avons des termes de types \typ s : si \vrbz w est une variable de ce type, alors par application fonctionnelle, nous pouvons écrire $\Xloz[\prdz{dormir}'(w)]$ qui est de type {\et} et dénote le résultat que renvoie la propriété de dormir pour le monde dénoté par \vrbz w, c'est-à-dire la dénotation de \sicut{dormir} dans ce monde. 
Autrement dit {\LOz} nous permet de représenter graphiquement à la fois les intensions (\prdzz{dormir}) et les extensions ($\Xloz\prdz{dormir}'(w)$), en faisant apparaître explicitement le caractère fonctionnel des intensions.\is{intension}
Et injecter de cette manière les mondes possibles à l'intérieur du langage est ce qui rend {\LOz} extensionnel (nous verrons précisément pourquoi \alien{infra}). 

L'ajout d'un argument \vrbz w va donc concerner toutes les expressions qui, dans {\LO}, s'interprètent avec $\FI$, c'est-à-dire, comme annoncé ci-dessus, les constantes non logiques.  Cela vaut donc aussi pour les constantes d'individus : dans {\LO} nous manipulerons des constantes de \emph{concepts d'individus}.  Ainsi nous aurons par exemple la constante $\Xloz\cnsz a'$  de type \type{s,e} pour le concept d'Alice, sachant que l'individu \Obj{Alice} sera dénoté par $\Xloz \cnsz a'(w)$. 
Et la phrase \sicut{Alice dort} se traduira donc par $\Xloz[[\prdz{dormir}'(w)]([\cnsz a'(w)])]$ ou $\Xloz\prdz{dormir}'(w)(\cnsz a'(w))$ ou $\Xloz\prdz{dormir}'(\cnsz a'(w),w)$, etc.
Nous voyons donc que de {\LO} à {\LOz}, les constantes voient leur arité augmenter de 1. 
Certes cela a pour conséquence de surcharger les écritures des formules ; à cet égard, pour nous faciliter un peu la vie, nous allons nous accorder la simplification de notation suivante.

\begin{nota}
Si $\xloz\alpha$ est une expression de type \mtype{\typ s,a} et \vrbz w un terme de type \typ s, nous nous autoriserons à réécrire \(\Xloz[\alpha(w)]\) en \(\Xloz\alpha_w\).
\end{nota}


Ainsi nous pourrons écrire plus simplement  $\Xloz\prdz{dormir}'_w(\cnsz a'_w)$.
Notons également que les variables (du moins celles que nous avons l'habitude d'utiliser jusqu'ici) n'ont pas besoin d'un argument de type \typ s car leur dénotation ne dépend que des assignations, pas des mondes possibles.  De la sorte, \Next[a] se traduit dans {\LOz} par \Next[b], qui se glose en : pour tout individu \vrbz x, si \vrbz x est un enfant de \vrbz w, alors \vrbz x dort dans \vrbz w (\vrbz x est, comme il se doit, de type \typ e). 

\ex.  \label{x:LO2.1}
\a. Tous les enfants dorment.
\b. \(\Xloz\forall x [\prdz{enfant}'_w(x)\implq\prdz{dormir}'_w(x)]\)




\subsection{Définition de \LOz}
%------------------------------

La définition formelle de {\LOz} est, à peu choses près, la même que celle de {\LO} vue dans ce chapitre.  
La principale différence, comme mentionné ci-dessus,  réside dans l'ensemble des types manipulés ; {\LOz} s'appuie sur l'ensemble $\Types_2$  défini comme suit :\is{T2@$\Types_2$} 

\begin{defi}[$\Types_2$]
{$\Types_2$} est le plus petit ensemble tel que :
\begin{enumerate}
\item \(\typ{e}, \typ t, \typ s \in \Types_2\) ;
\item si \(a \in \Types_2\) et \(b \in \Types_2\), alors \(\mtype{a,b} \in
\Types_2\).
\end{enumerate}
\end{defi}%

À partir de là, les règles de syntaxe et de sémantique de {\LO} (déf.\ \ref{RSyn:ltype} p.~\pageref{RSyn:ltype} et \ref{d:SemLOt} p.~\pageref{d:SemLOt}) sont reprises telles quelles pour {\LOz} mais de manière quelque peu «allégée».  D'abord le vocabulaire de {\LOz} va se passer des symboles liés à l'intensionnalité $\Xlo\textIntn$, $\Xlo\textExtn$, $\Xlo\doit$, $\Xlo\peut$, $\Xlo\doitn{n}$, $\Xlo\peutn{n}$, car nous allons voir qu'ils deviennent redondants.


\begin{defi}[Vocabulaire de {\LOz}]
Le vocabulaire de {\LOz} comporte :
\begin{itemize}
\item un ensemble de variables $\VAR_a$ et un ensemble de constantes
$\CON_a$ pour chaque type $a$ de {$\Types_2$} ;
\item un ensemble de symboles logiques : \set{\xloz\neg ; \xloz\wedge ; \xloz\vee$,
$\xloz\implq ; \xloz\ssi ; \xloz= ; \xloz\forall ; \xloz\exists ; \xloz\atoi ; 
%\xloz\doit ; \xloz\peut ; 
\xloz\lambda} ;
\item les crochets $\Xloz[\,]$ et les parenthèses $\Xloz(\,)$.
\end{itemize}
\end{defi}

Nous pouvons deviner dès à présent que le rôle de $\Xlo\textIntn$ sera réalisé par des \labstraction s sur des variables de mondes (nous avons d'ailleurs vu que \prdzz{dormir}, \ie\ $\Xloz\lambda w\,\prdz{dormir}'(w)$, équivaut à $\Xlo\Intn\prd{dormir}$), que celui de $\Xlo\textExtn$ sera réalisé par application fonctionnelle d'un argument de monde, et ceux des opérateurs modaux par des quantifications ($\Xloz\forall$, $\Xloz\exists$) sur des variables de mondes. 


\begin{defi}[Syntaxe de {\LOz}] \label{RSyn:ltype2z}
%^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
\begin{enumerate}[synz] %[({\small Syn$'$.}1)]
\item si $\vrbz\alpha \in \VAR_a$ ou $\vrbz\alpha \in \CON_a$, alors $\vrbz\alpha \in \ME_a$ ;
\label{SynTBase2}
\item si $\vrbz\alpha \in \ME_{\mtype{b,a}}$ et $\vrbz\beta \in \ME_b$, alors
$\xloz{[\alpha(\beta)]} \in \ME_a$ ;
\label{SynTApp2}
\item si $\vrbz\alpha$ et $\vrbz\beta \in \ME_a$, alors $\xloz{[\alpha=\beta]} \in \ME_{\mathrm{t}}$ ;
\label{SynT=2}
\item si \(\vrbz\phi, \vrbz\psi  \in \ME_{\mathrm{t}}\), alors :
  \begin{enumerate}
     \item \(\xloz{\neg\phi} \in \ME_{\mathrm{t}}\),
     \item \(\xloz{[\phi \wedge \psi]}, \xloz{[\phi \vee \psi]}, 
       \xloz{[\phi \implq\psi]}\) et \(\xloz{[\phi \ssi \psi]} \in \ME_{\mathrm{t}}\) ;
  \end{enumerate}
\label{SynTConn2}
\item si $\vrbz\phi \in \ME_{\mathrm{t}}$ et $\vrbz v \in \VAR_a$, alors $\Xloz\forall v \phi$ et
     $\xloz{\exists v \phi} \in \ME_{\mathrm{t}}$, et $\xloz{\atoi v \phi} \in \ME_a$ ;
\label{SynTQ2}
\item si $\vrbz\alpha \in \ME_a$ et $\vrbz v \in \VAR_b$, alors $\xloz{\lambda v
     \alpha} \in \ME_{\mtype{b,a}}$.
\label{SynTlamb2}
\end{enumerate}
\end{defi}


Pour établir la sémantique de {\LOz}, nous devons d'abord définir ce qu'est un modèle approprié pour ce langage.  Un modèle intensionnel pour {\LO} est un quadruplet \(\Modele=\tuple{\Unv A,\Unv W,\Unv R,\FI}\) ; 
un modèle pour {\LOz} est un triplet \(\Modele_2=\tuple{\Unv A,\Unv W,\FI'}\) qui se distingue du précédent d'abord en se débarrassant de la spécification des relations d'accessibilité \Unv R (nous allons voir pourquoi), et surtout par sa fonction d'interprétation $\FI'$ qui «redevient» une fonction à un argument, définie sur \CON.  Pour cette raison, un tel modèle est en soi extensionnel.\is{modele@modèle!\elid\ extensionnel}

Les domaines de dénotation $\DoM_{\mtyp a}$ (pour tout type \mtyp a) sont définis comme pour {\LO}, en ajoutant bien sûr que  $\DoM_{\typ s}=\Unv W$.
Et comme d'habitude, les fonctions d'assignation $g$ sont définies sur \VAR, assignant des valeurs selon le type de chaque variable.

\largerpage[-1]

Les règles d'interprétation de {\LOz} définissent la valeur sémantique de toute expression \vrbz\alpha\ par rapport à un modèle extensionnel et une assignation donnée $g$, c'est-à-dire $\denote{\vrbz\alpha}^{\Modele,g}$.  Car dans {\LOz}, les mondes de \Unv W n'ont plus le statut d'indices  «satellisés» sur $\denote{\,}$ pour le calcul des valeurs sémantiques. 


\begin{defi}[Sémantique {\LOz}]\label{d:SemLOtz}
Soit un modèle extensionnel \(\Modele=\tuple{\Unv{A},\Unv{W},\FI}\) et une assignation $g$.
\begin{enumerate}[semz] %[({\small Sem$'$.}1)]
\item si $\vrbz\alpha \in \CON$,
\(\denote{\Xloz\alpha}^{\Modele,g}=F(\vrbz\alpha)\) ;
\\
si $\vrbz\alpha \in \VAR$, \(\denote{\Xloz\alpha}^{\Modele,g}=g(\vrbz\alpha)\) ;
\label{SemTBasez}
\item \(\denote{\Xloz\alpha(\beta)}^{\Modele,g} =
\denote{\Xloz\alpha}^{\Modele,g}(\denote{\Xloz\beta}^{\Modele,g})\) ;%
\label{SemTAppz}
\item \(\denote{\Xloz\alpha=\beta}^{\Modele,g}=1\) ssi
  \(\denote{\Xloz\alpha}^{\Modele,g}=\denote{\Xloz\beta}^{\Modele,g}\) ; 
\label{SemT=z}
\item  \(\denote{\Xloz\neg\phi}^{\Modele,g}=1\) ssi
\(\denote{\Xloz\phi}^{\Modele,g}=0\) ; \\
 \(\denote{\Xloz\phi \wedge \psi}^{\Modele,g}=1\),  ssi
 \(\denote{\Xloz\phi}^{\Modele,g}=1\) et
 \(\denote{\Xloz\psi}^{\Modele,g}=1\) ;  \\ 
 \(\denote{\Xloz\phi \vee \psi}^{\Modele,g}=1\),  ssi
 \(\denote{\Xloz\phi}^{\Modele,g}=1\) ou
 \(\denote{\Xloz\psi}^{\Modele,g}=1\) ;  \\ 
 \(\denote{\Xloz\phi \implq \psi}^{\Modele,g}=1\),  ssi
 \(\denote{\Xloz\phi}^{\Modele,g}=0\) ou
 \(\denote{\Xloz\psi}^{\Modele,g}=1\) ;  \\ 
 \(\denote{\Xloz\phi \ssi \psi}^{\Modele,g}=1\),  ssi
 \(\denote{\Xloz\phi}^{\Modele,g}=\denote{\Xloz\psi}^{\Modele,g}\) ;  
%[\phi \vee \psi], [\phi \implq
%     \psi]\) et \([\phi \ssi \psi] \in \ME_t\) ;
\label{SemTConnz}
\item si $\vrbz v \in \VAR_a$, alors :\\
\(\denote{\Xloz\forall v \phi}^{\Modele,g}=1\) ssi pour tout \(\Obj{x}
\in \DoM_a\), \(\denote{\Xloz\phi}^{\Modele,g_{[\Obj{x}/\vrbz v]}}=1\) ;
\\
\(\denote{\Xloz\exists v \phi}^{\Modele,g}=1\) ssi il existe \(\Obj{x}
\in \DoM_a\) t.q. \(\denote{\Xloz\phi}^{\Modele,g_{[\Obj{x}/\vrbz v]}}=1\) ;
\\
\(\denote{\Xloz\atoi v \phi}^{\Modele,g}\) est défini ssi 
il existe un \emph{unique} $\Obj x \in \DoM_a$ 
%=\Obj{x}\) ssi \(\Obj{x}
%\in \DoM_a\) et \Obj{x} est l'\emph{unique} élément de $\DoM_a$ 
t.q. \(\denote{\Xloz\phi}^{\Modele,g_{[\Obj{x}/\vrbz v]}}=1\) ; alors \(\denote{\Xloz\atoi v \phi}^{\Modele,g} = \Obj x\) ;%
\label{SemTQz}
\item si $\vrbz\alpha \in \ME_a$ et $\vrbz v \in \VAR_b$, alors
 \(\denote{\Xloz\lambda v \alpha}^{\Modele,g}\) est la fonction de
 \(\DoM_a^{\DoM_b}\) qui pour tout \(\Obj{x}\in\DoM_b\) donne
 \(\Obj{x} \mapsto \denote{\Xloz\alpha}^{\Modele,g_{[\Obj{x}/v]}}\).
\label{SemTlambz}
\end{enumerate}
\end{defi}


\sloppy 
Techniquement, $\denote{\vrbz\alpha}^{\Modele,g}$ est donc l'extension, \ie\ la dénotation, de \vrbz\alpha\ par rapport à \Modele\ et $g$.  Or nous savons depuis longtemps maintenant que la dénotation d'une expression dépend aussi d'un certain état de chose, c'est-à-dire d'un monde %d'évaluation 
de \Unv W.  
Mais ce paramètre n'est pas perdu puisque, comme nous l'avons vu, il est incorporé dans les écritures de {\LOz} sous la forme d'une variable libre.  
Ainsi c'est à présent la fonction d'assignation $g$ qui nous donne accès au monde d'évaluation.
Par exemple, en reprenant la traduction de \ref{x:LO2.1}, nous saurons que
\(\denote{\Xloz\forall x [\prdz{enfant}'_w(x)\implq\prdz{dormir}'_w(x)]}^{\Modele,g}\)
est la dénotation de \sicut{tous les enfants dorment} par rapport au monde $g(\vrbz w)$.
Comme {\LOz} est extensionnel, il n'y a pas de notation spéciale dans le métalangage pour représenter l'intension d'une expression\footnote{C'est-à-dire une notation comme $\denote{\vrb\alpha}^{\Modele,g}$ dans \LO.}, mais l'extension de toute expression de type \type{s,\mtyp a} équivaut à une intension.  Par exemple $\denote{\Xloz\prdz{dormir}'}^{\Modele,g}$ est l'extension, par rapport à $g$, de \prdzz{dormir} de type \type{s,\et}, autrement dit l'intension du verbe \sicut{dormir} ; de même \(\denote{\Xloz\lambda w\forall x [\prdz{enfant}'_w(x)\implq\prdz{dormir}'_w(x)]}^{\Modele,g}\) est l'intension de \sicut{tous les enfants dorment} car \vrbz w n'est plus libre mais liée par $\Xloz\lambda w$. 
De fait, il existe une procédure régulière qui à toute expression de {\LO} fait correspondre une expression de {\LOz} équivalente, ce qui prouve que {\LOz}, bien qu'extensionnel, est (au moins) aussi expressif que {\LO}.

\fussy

Cette procédure de correspondance est présentée dans la section suivante, mais terminons ici en montrant pourquoi {\LOz} satisfait le principe d'extensionnalité\is{extensionnalité!principe d'\elid} (cf. \S\ref{s:limitesExt} p.~\pageref{pr:ext}).
Reprenons la prémisse du principe : soit deux expressions \vrbz\beta\ et \vrbz\gamma\ de \LOz\ telles que, \emph{pour toute assignation $g$},  \(\denote{\vrbz\beta}^{\Modele,g}=\denote{\vrbz\gamma}^{\Modele,g}\). 
Alors de deux choses l'une : soit \vrbz\beta\ et \vrbz\gamma\ ne contiennent aucune variable libre de monde, soit elles en contiennent une (ou éventuellement plusieurs).  Dans le premier cas, cela veut dire que les extensions de \vrbz\beta\ et \vrbz\gamma\ ne dépendent d'aucun monde ; et si elles sont identiques, alors nous pouvons remplacer l'une par l'autre dans une expression plus grande \vrbz\alpha, même si \vrbz\alpha\ contient des variables libres de monde, nous obtiendrons toujours le même résultat en calculant \(\denote{\vrbz\alpha}^{\Modele,g}\).
Dans le second cas, si les extensions de \vrbz\beta\ et \vrbz\gamma\ sont identiques pour toute assignation $g$, cela veut dire que la ou les variables libres de \vrbz\beta\ sont les mêmes que celles de {\vrbz\gamma}, et donc les contenus de \vrbz\beta\ et \vrbz\gamma\ seront toujours évalués par rapport aux mêmes mondes ; là encore nous pouvons les remplacer l'une par par l'autre dans \vrbz\alpha.
De fait, nous ne pouvons pas partir de la prémisse $\denote{\Xloz\atoi x\,\prdz{mère}'_w(x,\cnsz{\oe}'_w)}^{\Modele,g}=\denote{\Xloz\cnsz j'_w}^{\Modele,g}$ (quelle que soit $g$), car cela voudrait dire que la mère d'\OE dipe est \emph{nécessairement} Jocaste dans \Modele, ce qui est faux (elle l'est dans certains mondes mais pas dans tous).  Finalement, la prémisse \(\denote{\vrbz\beta}^{\Modele,g}=\denote{\vrbz\gamma}^{\Modele,g}\) pour toute assignation $g$, n'est autre que l'équivalence sémantique que nous avons vue au chapitre \ref{Ch:t+m} (\S\ref{ss:vclw} p. \pageref{d:eqsemw}) et le principe d'extensionnalité  dans \LOz\ revient au principe de synonymie (théorème \ref{th:syno} p.~\pageref{th:syno}) qui autorise à substituer des expressions équivalentes.



\subsection{De \LO\ à \LOz}
%-------------------------
\label{ss:LO-LO2}

La correspondance \LO--\LOz\ se formalise précisément, mais d'abord, pour nous familiariser avec les traductions de \LOz, regardons quelques exemples.

Commençons par un petit point pratique.  Aux constantes d'individus de {\LO} correspondent dans {\LOz} des constantes de concept d'individus de type \type{s,e}.   Les constantes que nous traitons comme des désignateurs rigides seront des fonctions qui retournent toujours le même résultat.  Par exemple si \prdzz a dénote le concept d'Alice, alors $\Xloz\prdz a'_w$ dénotera \Obj{Alice} quelle que soit la valeur de \vrbz w.  Nous pouvons simuler la constance de ces fonctions en nous autorisant à avoir aussi dans {\LOz} des constantes de type \typ e pour les désignateurs rigides.  Même si cela n'est pas indispensable, cela nous permet d'alléger un peu les écritures : si \sicut{Alice} se traduit directement par \cnsz a de type \typ e, alors nous pourrons écrire $\Xloz\prdz{dormir}'_w(\cnsz a)$ au lieu de $\Xloz\prdz{dormir}'_w(\cnsz a'_w)$.

\sloppy

Comme annoncé ci-dessus, l'opérateur d'intensionnalité $\Xlo\textIntn$ devient une \lamb-abstraction sur une variable de monde.  C'est ce qu'illustre la traduction d'une complétive en \Next. 

\fussy

\ex.
\a. Charles croit qu'Alice dort.
\b. {\LO} : \(\Xlo\prd{croire}(\cns c,\Intn[\prd{dormir}(\cns a)]) \)
\b. {\LOz} : \(\Xloz \prdz{croire}'_w(\cnsz c,\lambda w_1[\prdz{dormir}'_{w_1}(\cnsz a)])\)


\sloppy
Dans \Last[c], \vrbz w est la variable libre (de monde) et elle dénote donc le monde d'évaluation de la formule, celui dans lequel Charles a la croyance décrite dans la phrase.  
Quant au \lterme\ $\Xloz\lambda w_1[\prdz{dormir}'_{w_1}(\cnsz a)]$, il dénote la fonction qui, pour tout monde possible, renvoie $1$ ssi Alice dort dans ce monde.  C'est bien, par définition, la proposition exprimée par \sicut{qu'Alice dort}. 

\fussy

Les modalités aléthiques que nous encodons par $\Xlo\doit$ et $\Xlo\peut$ dans {\LO} deviennent dans {\LOz} des quantifications respectivement universelles et existentielles sur des mondes possibles :

\ex.
\a. {\LO} : \(\Xlo\doit\forall x [\prd{oiseau}(x)\implq\prd{animal}(x)]\)
\b. {\LOz} : \(\Xloz\forall w\forall x [\prdz{oiseau}'_w(x)\implq\prdz{animal}'_w(x)]\)

\ex.
\a. {\LO} : \(\Xlo\peut\prd{immortel}(\cns a)\)
\b. {\LOz} : \(\Xloz\exists w\,\prdz{immortel}'_w(\cnsz a)\)


La correspondance s'avère plus intéressante pour nos opérateurs modaux $\Xlo\doitn n$ et $\Xlo\peutn n$.  Rappelons que (\RSem\ref{SemTMod}) interprète ces modalités en restreignant la quantification sur les mondes au moyen d'une relation d'accessibilité ;\is{relation!\elid\ d'accessibilité} le choix de celle-ci dépend du contexte, ce que nous avons implémenté par le jeu des pseudo-variables \vrb n interprétées par $g$ pour sélectionner des relations de \Unv R.  Or ce principe peut directement être exprimé dans {\LOz} car nous disposons de variables de type
\type{s,\type{s,t}}, qui est précisément le type des relations entre mondes possibles.  Ainsi, si \vrbz R est une variable de ce type, \Next[a] pourra se traduire par \Next[c] :

\ex. 
\a. Alice doit dormir.
\b. {\LO} : \(\Xlo\doitn{n}\prd{dormir}(\cns a) \)
\b. {\LOz} : \(\Xloz \forall w'[R(w,w')\implq \prdz{dormir}'_{w'}(\cnsz a)]\)


\sloppy

\Last[c] donne une écriture moins condensée que \Last[b], mais elle a l'avantage d'être beaucoup plus explicite quant à l'interprétation de la modalité : 
nous voyons immédiatement que c'est une quantification, que la dénotation de la formule dépend du monde d'évaluation \vrbz w et que la relation d'accessibilité \vrbz R est déterminée par le contexte, c'est-à-dire par $g$, car c'est une variable libre. 

\fussy

Notons également que ces exemples nous montrent  d'où vient le second volet de la contrainte sur la \breduc\ (déf.~\ref{d:breduc2} p.~\pageref{d:breduc2}) qui interdit les substitutions dans la portée d'un opérateur intensionnel : c'est en fait un cas particulier du premier volet qui interdit qu'une variable libre de l'argument se retrouve liée dans le corps du \lterme\ après réduction.  En effet, {\LOz} fait clairement apparaître que les opérateurs intensionnels sont des lieurs de variables de mondes ($\Xloz\lambda w$, $\Xloz\forall w$, $\Xloz\exists w$). 

\medskip

Nous pouvons maintenant définir formellement la procédure de correspondance entre les expressions de {\LO} et celles de \LOz.  Pour ce faire, nous devons d'abord préciser comment passer d'un modèle intensionnel donné pour {\LO} à un modèle extensionnel pour {\LOz} de telle sorte que les calculs de valeurs sémantiques dans les deux langages nous donnent les mêmes résultats. 
Les deux modèles partagent bien sûr les mêmes ensembles \Unv A et \Unv W :

\ex.
Pour un modèle $\Modele=\tuple{\Unv A,\Unv W,\Unv R,\FI}$ de {\LO} il existe un modèle extensionnel $\Modele_2$ de {\LOz} tel que $\Modele_2=\tuple{\Unv A,\Unv W,\FI'}$ où $\FI'$ est définie suivant la règle \Next.


La fonction d'interprétation $\FI'$ de $\Modele_2$ doit être liée à \FI\ de \Modele\ de manière à imposer que tout le vocabulaire «lexical» de {\LO}, c'est-à-dire ses constantes non logiques, se retrouve dans {\LOz} dans une version intensionnalisée :


\ex.
Pour toute constante 
$\Xlo\alpha$ de type \mtyp a de {\LO}, il existe une constante
$\Xloz\alpha'$ de type \mtype{\typ s,a} de {\LOz} telle que pour tout $\w$ de \Unv W, $\FI'(\xloz{\alpha'})(\w) =  \FI(\w,\vrb\alpha)$.\footnote{En effet, puisque $\Xloz\alpha'$ est de type \type{s,\mtyp a}, alors $\FI'(\xlo{\alpha'})$ est une fonction sur \Unv W à laquelle nous pouvons donner un monde $\w$ comme argument. Cette règle dit simplement que $\FI'(\xlo{\alpha'})$ est la même chose que la fonction $\w\longmapsto \FI(\w,\vrb\alpha)$.}


\newpage

Cela veut dire que si {\LO} possède, par exemple, le prédicat \prd{dormir} de type \et, alors {\LOz} doit comporter le prédicat \prdzz{dormir} de type \type{s,\et} tel que la dénotation de \prdzz{dormir} dans $\Modele_2$ soit identique à celle de $\Xlo\Intn\prd{dormir}$ dans \Modele.


À partir de là nous pouvons définir une fonction qui à chaque expression de {\LO} associe une expression de {\LOz} de même extension.  Comme l'extension dépend toujours d'un certain monde possible, cette  fonction doit être indexée par une certaine variable de type \typ s.  Appelons la fonction \Fz[] et prenons la variable \vrbz u de $\VAR_{\typ s}$. 
Nous définissons \Fz[\vrbz u] afin que pour chaque monde \w\ de \Unv W et pour chaque expression $\Xlo\alpha$ de {\LO} il existe une expression $\Fz[\vrbz u](\vrb\alpha)$ de {\LOz} telle que \(\denote{\Xlo\alpha}^{\Modele,\w,g}=\denote{\Fz[\vrbz u](\vrb\alpha)}^{\Modele,g_{[\w/\vrbz u]}}\).
La variante $g_{[\w/\vrbz u]}$ garantit que \vrb u dénote \w\ et donc que \Fz[\vrbz u](\vrb\alpha) sera bien interprété par rapport au même monde que \vrb\alpha\footnote{Il faut remarquer que, pour simplifier, nous considérons que {\LO} et {\LOz} partagent globalement les mêmes fonctions d'assignation, c'est-à-dire que les expressions de {\LO} sont interprétées par rapport à des assignations définies aussi pour des variables de {\LOz} qui n'existent pas dans {\LO}.  }.  
Nous pouvons maintenant définir \Fz[\vrbz u] pour chaque schéma d'expressions que produit la syntaxe de {\LO}.

\begin{defi}[Conversion de \LO\ à \LOz]
\begin{enumerate}
\item  \begin{enumerate}
  \item si \(\vrb\alpha\in \CON_{\mtyp a}\), \(\Fz[\vrbz u](\vrb\alpha)=\xloz{[\alpha'(u)]} = \xloz{\alpha'_u}\)
  \item si \(\vrb v\in \VAR_{\mtyp a}\), \(\Fz[\vrbz u](\vrb v)=\xloz{v}\)
  \end{enumerate}
\item \(\Fz[\vrbz u](\xlo{[\alpha(\beta)]})=\xloz{[}\Fz[\vrbz u](\vrb\alpha)\xloz(\Fz[\vrbz u](\vrb\beta)\xloz{)]}\)
\item \(\Fz[\vrbz u](\xlo{[\alpha=\beta]})=\xloz{[}\Fz[\vrbz u](\vrb\alpha)\mathrel{\xloz=}\Fz[\vrbz u](\vrb\beta)\xloz{]}\)
\item  \begin{enumerate}
  \item \(\Fz[\vrbz u](\xlo{\neg\phi})=\xloz{\neg}\Fz[\vrbz u](\vrb\phi)\)
  \item \(\Fz[\vrbz u](\xlo{[\phi\wedge\psi]})=\xloz[\Fz[\vrbz u](\vrb\phi)\mathrel{\xlo\wedge}\Fz[\vrbz u](\vrb\psi)\xloz]\) \quad (idem pour $\xlo\vee$, $\xlo\implq$ et $\xlo\ssi$)
\end{enumerate}
\item  \begin{enumerate}
  \item \(\Fz[\vrbz u](\xlo{\doitn n\phi})=\xloz{\forall u' [R(u,u')\implq{}}\Fz[\xloz u'](\vrb\phi)\xloz]\) \quad où $g(\vrbz R)=R_{g(\vrb n)}$ (avec $R_{g(\vrb n)}\in\Unv R$)
  \item \(\Fz[\vrbz u](\xlo{\peutn n\phi})=\xloz{\exists u' [R(u,u')\wedge{}}\Fz[\xloz u'](\vrb\phi)\xloz]\) \quad où $g(\vrbz R)=R_{g(\vrb n)}$ (avec $R_{g(\vrb n)}\in\Unv R$)
  \end{enumerate}
\item \(\Fz[\vrbz u](\xlo{\forall v\phi})=\xloz{\forall}\Fz[\vrbz u](\vrb v)\,\Fz[\xloz u](\vrb\phi)\) \quad (idem pour $\Xlo\exists$ et $\Xlo\atoi$)
\item \(\Fz[\vrbz u](\xlo{\lambda v\alpha})=\xloz{\lambda}\Fz[\vrbz u](\vrb v)\,\Fz[\xloz u](\vrb\alpha)\) 
\item \(\Fz[\vrbz u](\xlo{\Intn\alpha})=\xloz{\lambda u'}\,\Fz[\xloz u'](\vrb\alpha)\) 
\item \(\Fz[\vrbz u](\xlo{\Extn\alpha})=\xloz{[}\Fz[\xloz u](\vrb\alpha)\xloz{(u)]}\) 
\end{enumerate}
\end{defi}

Cette définition de \Fz\ montre que, modulo la conversion, tout {\LO} est inclus dans \LOz\ et ainsi que \LOz\ est au moins aussi expressif que {\LO}.  «Au moins» car, \emph{en théorie}, \LOz\ peut l'être beaucoup plus.  Nous pouvons déjà nous en  rendre compte en réexaminant $\Types_2$ : $\Types_2$ inclut $\Types$ plus une infinité de types supplémentaires.  C'est parce que  $\Types_2$ autorise à avoir \typ s en seconde position d'un type complexe, comme dans \type{e,s}, \type{s,s}, \type{\type{s,t},s}, \type{\type{e,s},t}...
Autrement dit, \LOz\ peut contenir des expressions fonctionnelles qui renvoient un monde possible comme résultat.  La question qui peut se poser est : a-t-on vraiment besoin de tous ces nouveaux types pour faire de l'analyse sémantique des langues naturelles ? 
\citet{Zimmermann:89}\Andex{Zimmermann, T. E.} suggère que ce n'est probablement pas le cas et qu'empiriquement, les travaux qui utilisent des langages \Tyz\ en sémantique n'exploitent en fait que $\Types \cup \set{\typ s}$, mais pas tout $\Types_2$, comme ensemble de types admissibles.   
Et sous cette condition, il démontre que cette version «allégée» de \Tyz\ est complètement équivalente à la Logique Intensionnelle de Montague (sur laquelle se fonde \LO). Le principal intérêt d'utiliser \LOz\ est alors essentiellement pratique et réside dans l'avantage qu'il offre à expliciter simplement les analyses sémantiques.  C'est en partie pour cette raison que je le présente ici, tout en le maintenant séparé de {\LO} (que nous continuerons à utiliser la plupart du temps dans cet ouvrage). 

Je voudrais cependant, pour terminer, évoquer un exemple d'application  qui illustre ce que permet {\LOz}, avec une implication particulièrement intéressante.  Il s'agit encore une fois de l'ambiguïté \alien{de dicto} \vs\ \alien{de re} :\is{de dicto@\alien{de dicto}}\is{de re@\alien{de re}}

\ex.
\a. \OE dipe voulait épouser sa mère.
\b. \(\Xloz \prdz{vouloir}'_w(\cnsz{\oe},\lambda w_1\,\prdz{épouser}'_{w_1}(\cnsz{\oe},\atoi x\,\prdz{mère}'_{w_1}(x,\cnsz{\oe})))\) \taquet{2cm}{(de dicto)}
\b. \(\Xloz \prdz{vouloir}'_w(\cnsz{\oe},\lambda w_1\,\prdz{épouser}'_{w_1}(\cnsz{\oe},\atoi x\,\prdz{mère}'_{w}(x,\cnsz{\oe})))\) \taquet{2cm}{(de re)}


\sloppy
La différence entre les deux traductions semble subtile, mais elle est cruciale.  En \Last[b], le prédicat \prdz{mère} est interprété avec le monde $\Xloz w_1$ lié par $\Xloz \lambda w_1$ dans la proposition enchâssée, alors qu'en \Last[c] il est interprété avec \vrbz w le monde d'évaluation globale de la formule.  
La formule \Last[b] est la conversion directe par \Fz[\vrbz w] de la formule 
\(\Xlo\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},\atoi x\,
  \prd{mère}(x,\cns{\oe})))\) de \LO.  En revanche, il n'y a pas de formule de {\LO} qui peut \emph{directement} se convertir en \Last[c].  Mais \Last[c] est en fait le résultat de la \breduc\ de 
\(\Xloz [\lambda y\,\prdz{vouloir}'_w(\cnsz{\oe},\lambda w_1\,\prdz{épouser}'_{w_1}(\cnsz{\oe},y))(\atoi x\,\prdz{mère}'_{w}(x,\cnsz{\oe}))]\), formule qui elle équivaut par \Fz[\vrbz w] à 
\(\Xlo[\lambda y\,\prd{vouloir}(\cns{\oe},\Intn\prd{épouser}(\cns{\oe},y))(\atoi x\,\prd{mère}(x,\cns{\oe}))]\) de {\LO}%
\footnote{\tolerance=300 L'unique différence est que dans la formule de \LOz\ la \breduc\ est autorisée et qu'elle ne l'est pas dans celle de \LO.  C'est parce que \LOz\ peut manipuler plusieurs variables de type \typ s différentes alors que \LO\ fonctionne comme une version de {\LOz} qui ne posséderait qu'une seule, et toujours la même, variable \vrbz w. En fait la formule de {\LOz} donnée ci-dessus équivaut à \(\Xloz [\lambda y\,\prdz{vouloir}'_w(\cnsz{\oe},\lambda w\,\prdz{épouser}'_{w}(\cnsz{\oe},y))(\atoi x\,\prdz{mère}'_{w}(x,\cnsz{\oe}))]\) où la \breduc\ n'est pas permise, mais {\LOz} a, bien sûr, le droit de renommer les occurrences liées de la variable \vrbz w.} 
et que nous avons présentée précédemment.  Du point de vue des conditions de vérité, {\LO} n'est donc pas moins efficace que {\LOz} pour rendre compte de l'ambiguïté, mais {\LOz} structure la traduction d'une manière qui peut faire la différence du point de vue de la construction compositionnelle du sens de la phrase.
Car \Last[c] ouvre la possibilité d'analyser le \GN\ \sicut{sa mère} dans sa position syntaxique normale, sans passer par la \labstraction\ $\Xlo\lambda y$ des formules ci-dessus.  Nous verrons au chapitre suivant, \S\ref{conclu:ISS}, que cette option donne un avantage déterminant à {\LOz} pour l'interface syntaxe-sémantique.

\fussy

%\newpage
\bigskip


\largerpage[-1]

\nocite{DWP:81,BlackburnBos:2005,Cann:94} 
%\defbibnote{debibtypes}{\small
\subsection*{Repères bibliographiques}
La plupart des manuels de sémantique formelle comportent une introduction au \lcalcul\ typé qui peut compléter celle présentée ici; cf.\ \citet[][chap.~4]{DWP:81}, \citet[chap.~7]{ChierchiaMcCG:90}, \citet[][chap.~13]{PtMW:90}, \citet[][chap.~4]{Gamut:2}, \citet[][chap.~4 \& 5]{Cann:94}, \citet[][chap.~2]{HeimKratzer:97}, \citet[][chap.~9]{Jacobson:14}, \citet[][chap.~3]{Winter:16}...  Pour une excursion plus originale vers une application à la sémantique computationnelle, \citet{BlackburnBos:2005} proposent  une très bonne introduction et \citet{lambdacalc} offrent un logiciel disponible en ligne pour s'entraîner au calcul de dérivations sémantiques.
%}

%\sloppy
%\printbibliography[segment=\therefsegment,heading=subbibliography,prenote=debibtypes]



\fussy
