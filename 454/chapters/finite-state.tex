\begin{underthehood}
	\underthehoodsection{Finite-state automata}
\label{uth:fsas}
	

Regular expressions are closely related to \keyword{finite-state
  automata} (FSAs). In this section we will explain what finite-state
automata are and show how the connection can be made to regular
expressions.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm, semithick]

      \node[initial,state]   (A)              {$1$};
      \node[state,accepting] (B) [right of=A] {$2$};
      \path (A) edge node {a} (B);
    \end{tikzpicture}
    \caption{A first automaton}
    \label{finite:state:first}
\end{figure}

To get a sense of what FSAs are and how they correspond to strings, we
can start with an example.  Figure~\ref{finite:state:first} shows a
finite-state automaton that matches a single letter \exword{a}. It has
two \keywordAs{states}{state} ($1$ and $2$) and one \keyword{edge}
that links them. This edge is \keywordAs{labeled}{edge label} with the
letter \exword{a}. There is a start arrow marking state $1$ as initial
and special formatting (a double circle) marking state $2$ as
final. The idea of a finite automaton is that it matches all the paths
that can go from the initial state to the final state. This automaton
is especially boring: it only has one path, and the only sequence it
can match is the single letter \exword{a}.

We say that the automaton \keywordAs{generates}{generation} the language
corresponding to the paths. The language generated by the simple
automaton in Figure~\ref{finite:state:first} is just as boring: the
sequence containing a single letter \exword{a} is in the language, and
everything else is not.  (Recall back in
section~\ref{sec:semi-structured} that we can talk about languages as
being sets of strings.)  We relax this a little in
Figure~\ref{finite:state:second}, which allows \exword{b} and \exword{c} as well
as \exword{a}.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm, semithick]

      \node[initial,state]   (A)              {$1$};
      \node[state,accepting] (B) [right of=A] {$2$};
      \path (A) edge  [bend left]  node {a} (B)
            (A) edge               node {b} (B)
            (A) edge  [bend right] node {c} (B);
    \end{tikzpicture}
    \caption{A second automaton}
    \label{finite:state:second}
\end{figure}

This automaton is still pretty dull, and so is the language that it
generates (three different one-letter strings).

The next automaton (shown in figure~\ref{finite:state:third}) is less
dull.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
      semithick]

      \node[initial,state]   (A)              {$1$};
      \node[state,accepting] (B) [right of=A] {$2$};
		  
      \path (A) edge [loop above] node {a} (A)
            (A) edge [bend left]  node {a} (B)
            (A) edge              node {b} (B)
            (A) edge [bend right] node {c} (B);
    \end{tikzpicture}
    \caption{An automaton with a loop}
    \label{finite:state:third}
\end{figure}

What has happened here is that we have made an edge, labeled with
\exword{a} that loops around as many times as necessary, making \exword{a}s,
then finishes off with a choice of \exword{a},\exword{b} or \exword{c}. This is
powerful, because it describes an infinite (but still possibly dull)
language consisting of all the strings that start off with a sequence
of \exword{a}s and finish with at least one of either \exword{a}, \exword{b} or \exword{c}.
This language can also be described by the regular expression
/\texttt{+a*(a|b|c)+}/.
	
It turns out to be useful to think of regular expressions as a
\emph{notation} for finite state automata. That is, when we write
down a regular expression, it is a precise description of some finite
automaton. Going the other way, if you have an automaton, you can
write it down as a corresponding regular expression. This allows us to
use finite-state automata as a way of being mathematically precise
about what regular expressions mean. We say that finite-state automata
provide the \keyword{semantics} for regular expressions. In computer
science and linguistics, when we talk about \emph{semantics}, you can
think of the term as a synonym for \emph{mathematically precise meaning}.

	
Thus, every finite-state automaton can be associated with a set of
strings that it accepts. One of the simplest automata has two states
($1$ and $2$) and a single arc, labeled with the letter \exword{a} running
from $1$ to $2$, just as in Figure~\ref{finite:state:first} 
This automaton, which we will call $x$, accepts \exword{a} and
nothing else. The set of strings that it accepts is therefore
\{\exword{a}\}. Another simple automaton is the one with two states $1$ and
$2$, a single arc running from $1$ to $2$, this time with the label
\exword{b}. This automaton, which we call $y$, accepts \exword{b}, the sole
member of the set \{\exword{b}\}.

Now that we have two automata, $x$ and $y$, we can think about
combining them. We can do this in two ways: in parallel or in
sequence. If we take the first option, we create an automaton with two
states, as before, but with two arcs, each running from $1$ to $2$,
with one of the arcs labeled \exword{a} and the other labeled \exword{b}. This
new automaton, which we can give the name $x$ times $y$, corresponds
to the language \{\exword{a}, \exword{b}\}. Obviously, we could keep adding arcs
between $1$ and $2$, creating automata that accept more and more
single letters;
Figure~\ref{finite:state:second} shows the case for 3 letters. If we
instead choose to combine $x$ and $y$ in series, we get a three state
automaton, with states $1$ $2$ $3$, one arc between $1$ and $2$, and
one between $2$ and $3$.  We can then, for example, make $x$ . $y$ ($x$ \keywordAs{concatenated}{concatenation} with $y$),
which has the label \exword{a} on the arc between $1$ and $2$ and the label
\exword{b} on the arc between $2$ and $3$, as in
Figure~\ref{finite:state:fourth}.  This accepts just one two letter
string: the single member of the set \{\exword{ab}\}.  We could also make
$y$ . $x$ with the label \exword{b} on the arc between $1$ and $2$ and
\exword{a} on the arc between $2$ and $3$.
Generalizing this, it is easy to see how to build automata that accept
strings of length 3, 4, 5, and greater, and how to add labeled arcs so
as to accommodate more symbols, such as all the lower-case letters
\exword{a}-\exword{z}.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm, semithick]

      \node[initial,state]   (P)              {$1$};
      \node[state]           (Q) [right of=P] {$2$};
      \node[state,accepting] (R) [right of=Q] {$3$};
      \path (P) edge node {a} (Q);
      \path (Q) edge node {b} (R);
    \end{tikzpicture}
    \caption{An automaton with three states}
    \label{finite:state:fourth}
\end{figure}

As automata involve movement, it may help to think of traveling by
plane and to view an automaton as your flight path.  In this case, the
states of the automaton correspond to airports and the arcs correspond
to flight routes between the airports.  If you've flown, you know that
at every airport, they ask you for a new boarding pass, with a new
``label'', i.e., indicating your next destination.  You reach your
destination only if you are able to present the right boarding passes
in the right sequence.  This is illustrated in
figure~\ref{finite:state:flights}: to go from Indianapolis to Atlanta
to Orlando, you start in IND (airport code for Indianapolis), and if
you have a boarding pass to Atlanta, you are allowed to go to ATL.
Any other boarding pass, and your trip fails.  Likewise, you next need
a boarding pass to Orlando to make it to MCO.  Roughly speaking, this
is how a finite-state automaton works; instead of boarding passes,
though, we try to match strings.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm, semithick]

      \node[initial,state]   (P)              {$IND$};
      \node[state]           (Q) [right of=P] {$ATL$};
      \node[state,accepting] (R) [right of=Q] {$MCO$};
      \path (P) edge node {Atlanta} (Q);
      \path (Q) edge node {Orlando} (R);
    \end{tikzpicture}
    \caption{Viewing an automaton as a flight path}
    \label{finite:state:flights}
\end{figure}

Returning to our automata examples, the simple two-state automaton
that we started with is not the simplest, after all. There are also
automata with just one state. Such automata only make sense if their
single state is both an initial (starting) state and a final
(accepting) state, i.e., a legitimate end point. The simplest
automaton of all has one state and no arcs, and accepts exactly one
string: the empty string `'.

More usefully, there are also one-state automata that have arcs. For
example, if $1$ is both initial and final, and there is a single arc
looping from $1$ to $1$ labeled with \exword{a} -- as in
Figure~\ref{finite:state:fifth} -- the automaton accepts any sequence
made up exclusively of \exword{a}s. These include \exword{a},
\exword{aa}, \exword{aaa} and indeed the empty string `' (which can
be viewed, somewhat strangely, as a sequence of no \exword{a}s at
all).  Notice that this automaton, while finite, accepts an infinite
set of strings. There is no limit on the number of \exword{a}s.

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node distance=2.8cm,
      semithick]
      \node[initial,state,accepting]   (A)              {$1$};
      \path (A) edge [loop above] node {a} (A);
    \end{tikzpicture}
    \caption{A one-state automaton with a loop}
    \label{finite:state:fifth}
\end{figure}

Obviously, we can add more arcs, with more labels, and make single
state automata that accept a larger range of strings. And we can
combine these automata in series or in parallel to accept yet further
strings. For example, it is easy to make an automaton that accepts a
series of \exword{a}s followed by a series of \exword{b}s, as in
Figure~\ref{finite:state:sixth}, which corresponds to \texttt{/a*b*/}.
(Think about how you would have to change it to correspond to
\texttt{/a+b+/}.)

\begin{figure}
    \begin{tikzpicture}[->,>=stealth',shorten >=1pt,auto,node
      distance=2.8cm, semithick]

      \node[initial,state,accepting] (P)              {$1$};
      \node[state,accepting]         (Q) [right of=P] {$2$};
      \node[state,accepting]         (R) [right of=Q] {$3$};
      \path (P) edge [loop above] node {a} (P);
      \path (P) edge node {a} (Q);
      \path (Q) edge [loop above] node {b} (Q);
      \path (Q) edge node {b} (R);
    \end{tikzpicture}
    \caption{An automaton for \texttt{/a*b*/}}
    \label{finite:state:sixth}
\end{figure}

Perhaps the most important take-home point from this section is that
for every regular expression you can write down, there is a
corresponding finite-state automaton, and for every automaton, you can
write down a corresponding regular expression. Automata are simpler
(all that you need to understand are states, arcs, labels, and initial
and final states) but regular expressions are more concise, because
they have convenience features like the \texttt{*} and \texttt{+}
operators, and other abbreviations. It is a bit tiresome to write out
all the arcs that are involved in the automaton that goes with a
regular expression like /\texttt{[A-Z][a-z]+}/, but reassuring to know
that you could do it if you wanted to.  It would be very reasonable
for a simple implementation of regular expression matching, for
example, to create and make use of the corresponding automata as
internal data structures.

\end{underthehood}
